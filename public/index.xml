<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CYRUS STUDIO</title>
    <link>https://cyrus-studio.github.io/blog/</link>
    <description>Recent content on CYRUS STUDIO</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 24 Jun 2025 21:07:57 +0800</lastBuildDate>
    <atom:link href="https://cyrus-studio.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>手把手教你用 Chrome 断点调试 Frida 脚本，JS 调试不再是黑盒</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-chrome-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95-frida-%E8%84%9A%E6%9C%ACjs-%E8%B0%83%E8%AF%95%E4%B8%8D%E5%86%8D%E6%98%AF%E9%BB%91%E7%9B%92/</link>
      <pubDate>Tue, 24 Jun 2025 21:07:57 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-chrome-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95-frida-%E8%84%9A%E6%9C%ACjs-%E8%B0%83%E8%AF%95%E4%B8%8D%E5%86%8D%E6%98%AF%E9%BB%91%E7%9B%92/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;使用 Chrome 断点调试 JS 只需要在执行 frida 命令时，加上下面参数即可：&#xA;--runtime=v8 --debug 参数说明：&#xA;&amp;ndash;runtime=v8，指定 Frida 使用 V8 引擎（Google Chrome 使用的 JS 引擎）来运行 JS 脚本。默认 Frida 使用 QuickJS 引擎（轻量但功能有限，调试能力较差）。&#xA;&amp;ndash;debug，启用调试模式，输出更多细节信息，包括：脚本加载日志、错误栈追踪、JS 异常信息等&#xA;关于 Frida 的详细使用参考：一文搞懂如何使用 Frida Hook Android App&#xA;比如：&#xA;启动应用并附加到当前启动进程 frida -H 127.0.0.1:1234 -l classloader_utils.js -f com.shizhuang.duapp --runtime=v8 --debug 附加到当前设备的前台应用 frida -H 127.0.0.1:1234 -F -l classloader_utils.js --runtime=v8 --debug 当你看到：Chrome Inspector server listening on port 9229，这说明你已经成功开启了一个 Frida（V8 模式）调试服务&#xA;(anti-app) PS D:\Python\anti-app\frida_java&amp;gt; frida -H 127.</description>
    </item>
    <item>
      <title>逆向某物 App 登录接口：热修复逻辑挖掘隐藏参数、接口完整调用</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%83%AD%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91%E6%8C%96%E6%8E%98%E9%9A%90%E8%97%8F%E5%8F%82%E6%95%B0%E6%8E%A5%E5%8F%A3%E5%AE%8C%E6%95%B4%E8%B0%83%E7%94%A8/</link>
      <pubDate>Sun, 22 Jun 2025 22:38:57 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%83%AD%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91%E6%8C%96%E6%8E%98%E9%9A%90%E8%97%8F%E5%8F%82%E6%95%B0%E6%8E%A5%E5%8F%A3%E5%AE%8C%E6%95%B4%E8%B0%83%E7%94%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;uuid 参数分析 通过反编译 ff.l0.c 方法可以知道 uuid 来自于 he.a.i.t() 方法&#xA;map.put(&amp;#34;uuid&amp;#34;, he.a.i.t()); 具体参考：&#xA;逆向某物 App 登录接口：抓包分析 + Frida Hook 还原加密算法&#xA;逆向某物 App 登录接口：还原 newSign 算法全流程&#xA;查找一下 he.a.i 在哪些 dex 有引用&#xA;2|wayne:/data/data/com.shizhuang.duapp/cyrus # grep -rl &amp;#34;he.a.i&amp;#34; *.txt&#xD;11994176_class_list.txt&#xD;11994176_class_list_execute.txt&#xD;1321896_class_list_execute.txt&#xD;1571616_class_list.txt&#xD;1571616_class_list_execute.txt&#xD;8183732_class_list.txt&#xD;8183732_class_list_execute.txt&#xD;8391604_class_list_execute.txt&#xD;9085048_class_list.txt&#xD;9085048_class_list_execute.txt 通过 jadx 反编译 he.a 源码如下：&#xA;package he;&#xD;/* loaded from: 11994176_dex_file_execute.jar:he/a.class */&#xD;public class a {&#xD;public static i i = new C0253a();&#xD;/* renamed from: he.</description>
    </item>
    <item>
      <title>逆向某物 App 登录接口：还原 newSign 算法全流程</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E8%BF%98%E5%8E%9F-newsign-%E7%AE%97%E6%B3%95%E5%85%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 22 Jun 2025 21:24:23 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E8%BF%98%E5%8E%9F-newsign-%E7%AE%97%E6%B3%95%E5%85%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;newSign 参数分析 通过 Hook Java 层加密算法得到 newSign 参数相关信息如下：&#xA;具体参考：逆向某物 App 登录接口：抓包分析 + Frida Hook 还原加密算法&#xA;入参：&#xA;MD5 update data Utf8: dWWoXlbR3K87j2N27Dkv4uOPUnOsh0xrJ5t+atsiQXC+/dIN8Kof9Gm2x1kil7S/A+KLRtWKw+AfFWotfKtx+5J+ONciO*********************************************************************************************kK+Xiqtb6FajKK3aJ2vwB5l5lAKIhnvpOWXFWqYSQJy5g7oQ61Vwo+6MVB3U/wBT2CpM7AKDFH2Xj9Krb/0jNsPgNnA== MD5 加密后的结果：&#xA;MD5 digest result Hex: 8f03e2117c**********d9b9b18c58 调用堆栈：&#xA;MessageDigest.digest() is called!&#xD;java.lang.Throwable&#xD;at java.security.MessageDigest.digest(Native Method)&#xD;at ff.l0.h(RequestUtils.java:3)&#xD;at ff.l0.c(RequestUtils.java:12)&#xD;at lte.NCall.IL(Native Method)&#xD;at com.shizhuang.duapp.common.helper.net.interceptor.HttpRequestInterceptor.intercept(HttpRequestInterceptor.java)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:10)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:1)&#xD;at kb.b.intercept(MergeHostAfterInterceptor.java:11)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:10)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:1)&#xD;at kb.d.intercept(MergeHostInterceptor.java:8)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:10)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:1)&#xD;at okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:13)&#xD;at okhttp3.RealCall.execute(RealCall.java:8)&#xD;at retrofit2.OkHttpCall.execute(OkHttpCall.java:18)&#xD;at retrofit2.</description>
    </item>
    <item>
      <title>ADB 命令使用大全（建议收藏） Android 调试必备</title>
      <link>https://cyrus-studio.github.io/blog/posts/adb-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F-android-%E8%B0%83%E8%AF%95%E5%BF%85%E5%A4%87/</link>
      <pubDate>Sun, 22 Jun 2025 14:12:55 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/adb-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F-android-%E8%B0%83%E8%AF%95%E5%BF%85%E5%A4%87/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;基础adb命令 # 重启adb adb kill-server&#xD;# 查看已连接的设备&#xD;adb devices&#xD;# 进入命令行&#xD;adb shell&#xD;# 使用 -s 参数来指定设备&#xD;adb -s &amp;lt;设备序列号&amp;gt; shell&#xD;# 显示日志&#xD;adb logcat 获取 API Level 进入 adb shell ，执行下面命令获取当前 Android 系统的 API Level（即 SDK 版本）：&#xA;getprop ro.build.version.sdk 以下是 Android 版本与 API Level 的对应表 （截至 Android 15）：&#xA;Android 版本 API Level 代号 发布时间 Android 15 35 Vanilla Ice Cream 2024年9月 Android 14 34 Upside Down Cake 2023年10月 Android 13 33 Tiramisu 2022年8月 Android 12L 32 2022年3月 Android 12 31 Snow Cone 2021年10月 Android 11 30 Red Velvet Cake 2020年9月 Android 10 29 Q 2019年9月 Android 9 28 Pie 2018年8月 Android 8.</description>
    </item>
    <item>
      <title>安卓抓包实战：使用 Charles 抓取 App 数据全流程详解</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%BD%BF%E7%94%A8-charles-%E6%8A%93%E5%8F%96-app-%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 22 Jun 2025 14:12:55 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%BD%BF%E7%94%A8-charles-%E6%8A%93%E5%8F%96-app-%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;抓包环境准备 1. 下载安装charles charles下载地址：https://www.charlesproxy.com/latest-release/download.do&#xA;2. SSL代理设置 SSL Proxying Settings&amp;hellip;&#xA;说明：如果需要抓 PC 上的数据就开启 Windows Proxy，如果只是抓手机上的数据可以不用开启。&#xA;配置说明：&#xA;*:443 — 表示拦截所有域名的 HTTPS 请求&#xA;*:80 — 表示拦截所有域名的 HTTP 请求&#xA;3. Enable transparent HTTP proxying 打开 Proxy Settings 勾选 Enable transparent HTTP proxying&#xA;transparent HTTP proxying：客户端无需设置代理，Charles 通过网络层拦截（如防火墙、端口转发、网关路由等）来强制把 HTTP 流量转发到 Charles&#xA;4. 设置Charles与Clash共存 如果开启了Clash，需要设置Charles与Clash共存&#xA;打开扩展代理设置&#xA;分别点击 Web Proxy、Seure Web Proxy 和 SOCKS Proxy 设置一下Clash的地址和端口&#xA;5. 共享热点 通过 ipconfg 或者打开【网络和Internet】找到电脑的 ip 地址&#xA;电脑开启共享热点，手机连接热点并设置代理&#xA;6. 安装证书 手机端访问 http://chls.</description>
    </item>
    <item>
      <title>逆向某物 App 登录接口：抓包分析 &#43; Frida Hook 还原加密算法</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90-&#43;-frida-hook-%E8%BF%98%E5%8E%9F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 21 Jun 2025 16:33:56 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90-&#43;-frida-hook-%E8%BF%98%E5%8E%9F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;登录接口抓包分析 使用 Charles 分析登录接口，打开 APP，输入用户名和密码，点击登录后，可以看到会调用一个 unionLogin 接口&#xA;Charles 的详细使用教程参考：安卓抓包实战：使用 Charles 抓取 App 数据全流程详解&#xA;response：&#xA;{&#xD;&amp;#34;code&amp;#34;: 704,&#xD;&amp;#34;data&amp;#34;: &amp;#34;3YlD20Mglo7XabT4cSg0p_sFlOH7UrRp2-SV2xAVsXYfLssqWSX1NpUQ9HhlWEnRgXF0phtI-2BfqI9Cl1cGmih8veCmWZU-ItqKSv_gs3stFlw_*****************************************fRv25yucw==&amp;#34;,&#xD;&amp;#34;status&amp;#34;: 704&#xD;} curl 转 request（https://spidertools.cn/#/curl2Request）&#xA;通过 Python 请求接口&#xA;import requests&#xD;import json&#xD;headers = {&#xD;&amp;#34;ipvx&amp;#34;: &amp;#34;**************&amp;#34;,&#xD;&amp;#34;webua&amp;#34;: &amp;#34;Mozilla/5.0 (Linux; Android 7.1.2; MI8 Build/N2G47J; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/66.0.3359.158 Mobile Safari/537.36/duapp/5.43.0(android;7.1.2)&amp;#34;,&#xD;&amp;#34;app_build&amp;#34;: &amp;#34;5.43.0.10&amp;#34;,&#xD;&amp;#34;cookieToken&amp;#34;: &amp;#34;&amp;#34;,&#xD;&amp;#34;ltk&amp;#34;: &amp;#34;*****************************************&amp;#34;,&#xD;&amp;#34;duplatform&amp;#34;: &amp;#34;android&amp;#34;,&#xD;&amp;#34;appId&amp;#34;: &amp;#34;duapp&amp;#34;,&#xD;&amp;#34;duchannel&amp;#34;: &amp;#34;xiaomi&amp;#34;,&#xD;&amp;#34;humeChannel&amp;#34;: &amp;#34;&amp;#34;,&#xD;&amp;#34;duv&amp;#34;: &amp;#34;5.</description>
    </item>
    <item>
      <title>破解 VMP&#43;OLLVM 混淆：通过 Hook jstring 快速定位加密算法入口</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%A0%B4%E8%A7%A3-vmp&#43;ollvm-%E6%B7%B7%E6%B7%86%E9%80%9A%E8%BF%87-hook-jstring-%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%85%A5%E5%8F%A3/</link>
      <pubDate>Fri, 20 Jun 2025 16:43:26 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%A0%B4%E8%A7%A3-vmp&#43;ollvm-%E6%B7%B7%E6%B7%86%E9%80%9A%E8%BF%87-hook-jstring-%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%85%A5%E5%8F%A3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;VMP 壳 + OLLVM 的加密算法 某电商APP的加密算法经过dex脱壳分析，找到参数加密的方法在 DuHelper.doWork 中&#xA;package com.shizhuang.duapp.common.helper.ee;&#xD;import com.meituan.robust.ChangeQuickRedirect;&#xD;import lte.NCall;&#xD;/* loaded from: base.apk_classes9.jar:com/shizhuang/duapp/common/helper/ee/DuHelper.class */&#xD;public class DuHelper {&#xD;public static ChangeQuickRedirect changeQuickRedirect;&#xD;static {&#xD;NCall.IV(new Object[]{282});&#xD;}&#xD;public static native int checkSignature(Object obj);&#xD;public static String doWork(Object obj, String str) {&#xD;return (String) NCall.IL(new Object[]{283, obj, str});&#xD;}&#xD;public static native String encodeByte(byte[] bArr, String str);&#xD;public static native String getByteValues();&#xD;public static native String getLeanCloudAppID();&#xD;public static native String getLeanCloudAppKey();&#xD;public static native String getWxAppId(Object obj);&#xD;public static native String getWxAppKey();&#xD;} DuHelper.</description>
    </item>
    <item>
      <title>逆向 JNI 函数找不到入口？动态注册定位技巧全解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91-jni-%E5%87%BD%E6%95%B0%E6%89%BE%E4%B8%8D%E5%88%B0%E5%85%A5%E5%8F%A3%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%AE%9A%E4%BD%8D%E6%8A%80%E5%B7%A7%E5%85%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 19 Jun 2025 21:32:15 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91-jni-%E5%87%BD%E6%95%B0%E6%89%BE%E4%B8%8D%E5%88%B0%E5%85%A5%E5%8F%A3%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%AE%9A%E4%BD%8D%E6%8A%80%E5%B7%A7%E5%85%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 使用 IDA Pro 静态分析时，JNI 函数并没有出现在导出表中，根本找不到函数实现的位置。&#xA;这是因为很多 App 为了安全性和混淆目的，采用了 JNI 动态注册（RegisterNatives） 的方式，绕开了传统的静态绑定机制。&#xA;那么遇到这种情况我们该怎么办？&#xA;通过源码分析JNI 函数调用流程 ArtMethod 是 ART 虚拟机中用于表示 Java 方法的底层结构体，Java 中每个方法在运行时都会对应一个 ArtMethod 实例，用于管理其执行入口、访问标志、Dex 信息等元数据。&#xA;entry_point_from_jni_ 是 ArtMethod 结构体的一个字段，专门用于存储 Java 方法对应的 JNI 函数地址。&#xA;在编译 JNI 方法时，ArtJniCompileMethodInternal 中通过调用 EntryPointFromJniOffset 方法获取 entry_point_from_jni_ 字段的偏移，并生成一条调用该 jni 函数的机器指令插入到编译结果中。&#xA;// 9. Plant call to native code associated with method.&#xD;// 计算 ArtMethod 中 JNI 入口地址的字段偏移（即 ptr_sized_fields_.data_ 偏移）&#xD;// 根据目标指令集（如 arm64、x86）传入对应的指针大小（PointerSize::k64 或 k32）&#xD;MemberOffset jni_entrypoint_offset =&#xD;ArtMethod::EntryPointFromJniOffset(InstructionSetPointerSize(instruction_set));&#xD;// 这部分代码生成了一条机器指令，用于调用 ArtMethod::entry_point_from_jni 所指向的 native 函数：&#xD;__ Call(main_jni_conv-&amp;gt;MethodStackOffset(), // 栈中 ArtMethod* 相对偏移&#xD;jni_entrypoint_offset, // ArtMethod 内部 entry_point_from_jni 字段的偏移&#xD;mr_conv-&amp;gt;InterproceduralScratchRegister()); // 用于保存临时地址的寄存器 https://cs.</description>
    </item>
    <item>
      <title>一文搞懂如何使用 Frida Hook Android App</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-frida-hook-android-app/</link>
      <pubDate>Wed, 18 Jun 2025 16:50:01 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-frida-hook-android-app/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Frida Frida 通过注入自定义 JavaScript 代码，可以 Hook 函数、修改参数、监控函数调用和拦截返回值，适用于逆向工程、调试和安全分析等场景。&#xA;使用 Frida 前需要先下载和安装包括：&#xA;Frida 是核心库，提供 API 和功能。&#xA;Frida-Tool 是命令行工具，通常与 Frida 版本相对应。&#xA;Frida-Server 是运行在 Android 设备上的服务器端组件，允许 Frida 客户端与设备进行通信。&#xA;环境准备 1. 安装 frida 和 frida-tools pip install frida-tools 2. frida server 获取设备CPU架构&#xA;adb shell getprop ro.product.cpu.abi 下载与设备对应架构的 frida-server：https://github.com/frida/frida/releases&#xA;把 frida-server 推送到设备 /data/local/tmp 目录下&#xA;adb push D:\app逆向\Frida\frida-server-16.5.2-android-arm64 /data/local/tmp/fs 启动 frida-server&#xA;# 启用超级管理员&#xD;adb root&#xD;# 进入命令行&#xD;adb shell # 添加可执行权限&#xD;chmod +x /data/local/tmp/fs&#xD;# 启动frida-server&#xD;/data/local/tmp/fs 3.</description>
    </item>
    <item>
      <title>搞懂 Android Hook 的两大核心：PLT Hook 与 Inline Hook 全解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%90%9E%E6%87%82-android-hook-%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%A0%B8%E5%BF%83plt-hook-%E4%B8%8E-inline-hook-%E5%85%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 17 Jun 2025 04:05:05 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%90%9E%E6%87%82-android-hook-%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%A0%B8%E5%BF%83plt-hook-%E4%B8%8E-inline-hook-%E5%85%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 在 Android Native 层开发和逆向分析中，Hook 技术是一项绕不开的核心能力。&#xA;Hook 技术是一种在应用运行时拦截或替换系统或自身函数行为的手段，常见实现包括 PLT Hook、Inline Hook。&#xA;PLT Hook 和 Inline Hook 是两种不同层次和机制的函数 Hook 技术，常用于逆向工程、安全分析、壳保护或热修复等场景。&#xA;PLT hook 和 Inline hook 有什么区别？ 特性 PLT Hook（符号级） Inline Hook（指令级） Hook 层级 链接层（.plt 或 GOT） 指令层（函数入口指令） Hook 对象 动态库导出的函数 任意函数（不一定导出） 修改内容 修改函数地址指针 修改指令流（如跳转指令） Hook 粒度 通常是库间调用 可以精确到任意函数、库内调用 稳定性 较高 稍差（依赖指令结构、架构） 跨平台兼容性 更好 架构相关（ARM32/ARM64） PLT Hook 原理（也叫 GOT Hook） ELF 中动态链接时使用 PLT（Procedure Linkage Table） 和 GOT（Global Offset Table） ；</description>
    </item>
    <item>
      <title>深入解析 AES 加密算法：原理、变体与 LibTomCrypt 在 Android 中的实战应用</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-aes-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%98%E4%BD%93%E4%B8%8E-libtomcrypt-%E5%9C%A8-android-%E4%B8%AD%E7%9A%84%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 16 Jun 2025 18:42:40 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-aes-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%98%E4%BD%93%E4%B8%8E-libtomcrypt-%E5%9C%A8-android-%E4%B8%AD%E7%9A%84%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 AES（Advanced Encryption Standard，高级加密标准） 是一种 对称加密算法，用于加密和解密数据。AES 由 美国国家标准与技术研究院（NIST） 在 2001 年正式发布，取代了 DES 和 3DES，目前被广泛应用于 网络安全、金融、通信 等领域。&#xA;支持 128（16字节）、192（24字节）、256（32字节） 位密钥。&#xA;特性 描述 加密方式 对称加密（加密和解密使用相同的密钥） 分组长度 128 位（16 字节） 密钥长度 128 位、192 位、256 位（分别对应 10、12、14 轮加密） 安全性 目前无已知有效攻击，比 3DES 更安全 运算模式 支持 ECB、CBC、CFB、OFB、CTR 等模式 关于算法的详细介绍可以参考这篇文章：常用加解密算法介绍&#xA;LibTomCrypt LibTomCrypt 是一个开源的轻量级加密库，提供了多种加密算法和密码学相关功能。它是用 C 语言编写的，专注于嵌入式系统和资源受限的设备，非常适合在 Android 等平台上使用。&#xA;特点:&#xA;算法支持丰富：包括对称加密（AES、DES 等）、非对称加密（RSA、ECC 等）、哈希算法（SHA-256、MD5 等）&#xA;轻量级，代码简单。&#xA;支持多种加密模式：ECB、CBC、CFB、OFB 等。&#xA;适用场景: 如果你需要一个开源、可自定义的库。&#xA;集成 LibTomCrypt 到 Android 工程 在 Android Studio 中集成 LibTomCrypt 并调用 JNI，可以按以下步骤操作：</description>
    </item>
    <item>
      <title>Frida Native 层 Hook 技巧：JNI 函数调用、字符串解析、so 加载</title>
      <link>https://cyrus-studio.github.io/blog/posts/frida-native-%E5%B1%82-hook-%E6%8A%80%E5%B7%A7jni-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90so-%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Sun, 15 Jun 2025 02:25:04 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/frida-native-%E5%B1%82-hook-%E6%8A%80%E5%B7%A7jni-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90so-%E5%8A%A0%E8%BD%BD/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;RegisterNatives RegisterNatives 是 JNI（Java Native Interface）的一部分，用于在 Java 类和本地 C/C++ 代码之间注册本地方法。其原型如下：&#xA;jint RegisterNatives(JNIEnv* env, jclass clazz, const JNINativeMethod* methods, jint method_count); 参数说明：&#xA;env：JNIEnv 指针。&#xA;clazz：Java 类的 jclass 句柄。&#xA;methods：指向 JNINativeMethod 结构体数组的指针。&#xA;method_count：要注册的方法数量。&#xA;其中，methods 结构体的定义如下：&#xA;typedef struct {&#xD;const char* name; // 方法名称（指向字符串）&#xD;const char* signature; // 方法签名（指向字符串）&#xD;void* fnPtr; // 方法的本地实现（指向本地函数）&#xD;} JNINativeMethod; 可以看到，每个 JNINativeMethod 结构体由 三个指针 组成：&#xA;name（方法名指针）&#xA;signature（方法签名指针）&#xA;fnPtr（本地方法指针）&#xA;一般会有两个 RegisterNatives 函数，CheckJNI 版本只有在调试选项打开时才会调用，我们一般用 JNI 的那个就行。&#xA;[+] Found RegisterNatives symbol: _ZN3art12_GLOBAL__N_18CheckJNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi at 0x780d7757a8&#xD;[+] Found RegisterNatives symbol: _ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi at 0x780d7eed10 通过 hook RegisterNatives 实现监控 app 中动态注册的 JNI 函数。代码如下：</description>
    </item>
    <item>
      <title>一文搞懂 SO 脱壳全流程：识别加壳、Frida Dump、原理深入解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-so-%E8%84%B1%E5%A3%B3%E5%85%A8%E6%B5%81%E7%A8%8B%E8%AF%86%E5%88%AB%E5%8A%A0%E5%A3%B3frida-dump%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 11 Jun 2025 01:23:58 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-so-%E8%84%B1%E5%A3%B3%E5%85%A8%E6%B5%81%E7%A8%8B%E8%AF%86%E5%88%AB%E5%8A%A0%E5%A3%B3frida-dump%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;加壳 so 识别 使用 IDA 打开 so 提示无法正确识别 ELF 文件结构。&#xA;section 定义无效或不符合预期格式。&#xA;有很多红色的汇编代码块，表示错误或者未能正常解析的地址/数据&#xA;这通常就是 so 可能被“混淆”、“裁剪”或“加壳”了。&#xA;使用 frida_dump 实现 so 脱壳 frida_dump 是基于 frida 的 so 和 dex 的脱壳工具。&#xA;开源地址：https://github.com/lasting-yang/frida_dump&#xA;关于 Frida 的使用参考：使用 Frida Hook Android App&#xA;先把 frida_dump 源码 clone 到本地。&#xA;如果使用的是远程链接，把 dump_so.py 中的&#xA;device: frida.core.Device = frida.get_usb_device() 改成&#xA;device = frida.get_device_manager().add_remote_device(&amp;#34;127.0.0.1:1234&amp;#34;) 比如目标 so 是 libGameVMP.so，通过下面命令执行 dump_so.py&#xA;python dump_so.py libGameVMP.so 输出如下：&#xA;(anti-app) PS D:\Python\anti-app\frida_dump&amp;gt; python dump_so.py libGameVMP.so&#xD;{&amp;#39;name&amp;#39;: &amp;#39;libGameVMP.</description>
    </item>
    <item>
      <title>FART 脱壳某大厂 App &#43; CodeItem 修复 dex &#43; 反编译还原源码</title>
      <link>https://cyrus-studio.github.io/blog/posts/fart-%E8%84%B1%E5%A3%B3%E6%9F%90%E5%A4%A7%E5%8E%82-app-&#43;-codeitem-%E4%BF%AE%E5%A4%8D-dex-&#43;-%E5%8F%8D%E7%BC%96%E8%AF%91%E8%BF%98%E5%8E%9F%E6%BA%90%E7%A0%81/</link>
      <pubDate>Sun, 08 Jun 2025 00:31:08 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/fart-%E8%84%B1%E5%A3%B3%E6%9F%90%E5%A4%A7%E5%8E%82-app-&#43;-codeitem-%E4%BF%AE%E5%A4%8D-dex-&#43;-%E5%8F%8D%E7%BC%96%E8%AF%91%E8%BF%98%E5%8E%9F%E6%BA%90%E7%A0%81/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;FART 脱壳 fartthread 方法在 app 启动的时候（ActivityThread）开启 fart 线程，休眠 60 秒，等待 app 启动完成后自动开始遍历 ClassLoader 的 类列表，发起主动调用。&#xA;FART 脱壳结束得到的文件列表（分 Execute 与 主动调用两类）：&#xA;Execute 脱壳点得到的 dex (*_dex_file_execute.dex）和 dex 中的所有类列表（ txt 文件）&#xA;主动调用时 dump 得到的 dex (*_dex_file.dex）和此时 dex 中的所有类列表，以及该 dex 中所有函数的 CodeItem（ bin 文件）&#xA;wayne:/data/data/com.cyrus.example/cyrus # ls&#xD;1321896_class_list.txt 1437648_dex_file_execute.dex 1488168_class_list_execute.txt 1605504_ins_4714.bin&#xD;1321896_class_list_execute.txt 1437648_ins_4714.bin 1488168_dex_file.dex 198768_class_list.txt&#xD;1321896_dex_file.dex 1448488_class_list.txt 1488168_dex_file_execute.dex 198768_class_list_execute.txt&#xD;1321896_dex_file_execute.dex 1448488_class_list_execute.txt 1488168_ins_4714.bin 198768_dex_file.dex&#xD;1321896_ins_4714.bin 1448488_dex_file.dex 1496608_class_list.txt 198768_dex_file_execute.dex&#xD;1351008_class_list.txt 1448488_dex_file_execute.dex 1496608_class_list_execute.txt 198768_ins_4714.bin&#xD;1351008_class_list_execute.txt 1448488_ins_4714.</description>
    </item>
    <item>
      <title>FART 精准脱壳：通过配置文件控制脱壳节奏与范围</title>
      <link>https://cyrus-studio.github.io/blog/posts/fart-%E7%B2%BE%E5%87%86%E8%84%B1%E5%A3%B3%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E8%84%B1%E5%A3%B3%E8%8A%82%E5%A5%8F%E4%B8%8E%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Wed, 04 Jun 2025 17:42:52 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/fart-%E7%B2%BE%E5%87%86%E8%84%B1%E5%A3%B3%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E8%84%B1%E5%A3%B3%E8%8A%82%E5%A5%8F%E4%B8%8E%E8%8C%83%E5%9B%B4/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 由于 FART 默认会对所有 app 进行脱壳，每次 app 启动都会自动脱壳，而且会对 app 中所有类发起主动调用，这样效率比较慢，遇到 FART 对抗类也不能选择性跳过。&#xA;如何通过一份简单的配置文件，实现对 FART 脱壳过程的精准控制：包括是否启用脱壳、延迟时间、需要主动调用的类列表、排除类规则等。提高脱壳效率，也可以避开一些垃圾类（FART 对抗类）的调用。&#xA;关于 FART 的详细介绍参考下面的文章：&#xA;FART 自动化脱壳框架简介与脱壳点的选择&#xA;FART 主动调用组件设计和源码分析&#xA;移植 FART 到 Android 10 实现自动化脱壳&#xA;FART 自动化脱壳框架一些 bug 修复记录&#xA;使用 Frida 增强 FART：实现更强大的 Android 脱壳能力&#xA;攻防 FART 脱壳：特征检测识别 + 对抗绕过全解析&#xA;通过配置文件控制脱壳节奏与范围 例如，配置项如下：&#xA;# 是否开启脱壳功能（true 开启，false 关闭）&#xD;dump=true&#xD;# 启动后延迟多少毫秒再进行脱壳（单位：毫秒），避免应用初始化未完成&#xD;sleep=60000&#xD;# 明确指定哪些类名或包路径需要主动调用以触发加载（支持通配符 *）&#xD;# 示例：ff.l0.* 表示 ff.l0 包下所有类&#xD;force=ff.l0.*&#xD;# 忽略哪些类或包路径（支持通配符 *）&#xD;# 通常用于排除系统类、常见库类、FART对抗类等&#xD;ignore=androidx.</description>
    </item>
    <item>
      <title>攻防 FART 脱壳：特征检测识别 &#43; 对抗绕过全解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%94%BB%E9%98%B2-fart-%E8%84%B1%E5%A3%B3%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB-&#43;-%E5%AF%B9%E6%8A%97%E7%BB%95%E8%BF%87%E5%85%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 02 Jun 2025 20:08:55 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%94%BB%E9%98%B2-fart-%E8%84%B1%E5%A3%B3%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB-&#43;-%E5%AF%B9%E6%8A%97%E7%BB%95%E8%BF%87%E5%85%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;FART 对抗 某视频 app 的壳在启动的时候会检测 FART 特征，日志输出如下：&#xA;2025-05-29 02:16:25.612 2557-2557 ActivityThread cn.cntv E go into handleBindApplication&#xD;2025-05-29 02:16:25.630 2557-2557 cn.cntv cn.cntv I The ClassLoaderContext is a special shared library.&#xD;2025-05-29 02:16:25.807 1512-17245 ActivityManager system_process I Process cn.cntv (pid 2557) has died: fore TOP 2025-05-29 02:16:25.875 1512-1588 ActivityManager system_process I Start proc 2628:cn.cntv/u0a140 for top-activity {cn.cntv/com.cctv.mcctv.ui.activity.SplashActivity}&#xD;2025-05-29 02:16:25.932 2628-2628 ActivityThread cn.cntv E go into handleBindApplication&#xD;2025-05-29 02:16:25.945 2628-2628 cn.cntv cn.</description>
    </item>
    <item>
      <title>使用 Frida 增强 FART：实现更强大的 Android 脱壳能力</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-frida-%E5%A2%9E%E5%BC%BA-fart%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84-android-%E8%84%B1%E5%A3%B3%E8%83%BD%E5%8A%9B/</link>
      <pubDate>Wed, 28 May 2025 23:24:22 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-frida-%E5%A2%9E%E5%BC%BA-fart%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84-android-%E8%84%B1%E5%A3%B3%E8%83%BD%E5%8A%9B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;FART 和 Frida 结合会发生什么？ 对 FART 进一步增强：&#xA;增强 FART 的脱壳能力：解决对抗 FART 的壳、动态加载的 dex 的 dump 和修复；&#xA;控制 FART 主动调用的范围，让 FART 更精细化，比如按需进行类甚至是函数的修复。&#xA;非双亲委派关系下动态加载的 dex 脱壳问题 由于动态加载的 dex 没有取改变 android 中 ClassLoader 双亲委派关系，所以动态加载的 dex 没有自动脱壳。&#xA;相关文章：&#xA;Android 下的 ClassLoader 与 双亲委派机制&#xA;Android 加壳应用运行流程 与 生命周期类处理方案&#xA;在 android studio 中创建一个 plugin module 其中包含一个 FartTest 类源码如下：&#xA;package com.cyrus.example.plugin&#xD;import android.util.Log&#xD;class FartTest {&#xD;fun test(): String {&#xD;Log.d(&amp;#34;FartTest&amp;#34;, &amp;#34;call FartTest test().&amp;#34;)&#xD;return &amp;#34;String from FartTest.</description>
    </item>
    <item>
      <title>FART 自动化脱壳框架一些 bug 修复记录</title>
      <link>https://cyrus-studio.github.io/blog/posts/fart-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3%E6%A1%86%E6%9E%B6%E4%B8%80%E4%BA%9B-bug-%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Wed, 28 May 2025 00:00:55 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/fart-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3%E6%A1%86%E6%9E%B6%E4%B8%80%E4%BA%9B-bug-%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;open() 判断不严谨 https://github.com/CYRUS-STUDIO/FART/blob/master/fart10/art/runtime/art_method.cc&#xA;比如：&#xA;int dexfilefp = open(dex_path.c_str(), O_RDONLY);&#xD;if (dexfilefp &amp;gt; 0) {&#xD;close(dexfilefp);&#xD;} 这个判断条件其实是不严谨的，导致 if 中 的 close(dexfilefp); 一直没有执行。&#xA;open() 的返回值语义是：&#xA;成功时：返回一个非负整数（即 &amp;gt;= 0），它是打开的文件描述符。&#xA;失败时：返回 -1&#xA;正确的判断方式应该是：&#xA;if (fp &amp;gt;= 0) {&#xD;// 成功打开&#xD;} else {&#xD;// 打开失败，打印错误信息&#xD;LOG(ERROR) &amp;lt;&amp;lt; &amp;#34;open dex file failed&amp;#34;;&#xD;} mkdir failed errno: 13 FART 中通过 mkdir 函数在 sdcard 上创建 dump 文件存放目录，但是这样必须 app 拥有存储卡读写权限。不然 mkdir 会执行失败。&#xA;下面时一个 frida 脚本，调用系统 的 mkdir 函数创建目录</description>
    </item>
    <item>
      <title>移植 FART 到 Android 10 实现自动化脱壳</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%A7%BB%E6%A4%8D-fart-%E5%88%B0-android-10-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3/</link>
      <pubDate>Sat, 24 May 2025 15:17:52 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%A7%BB%E6%A4%8D-fart-%E5%88%B0-android-10-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;FART 源码 FART 是 ART 环境下基于主动调用的自动化脱壳方案。&#xA;关于 FART 详细介绍参考：&#xA;FART 自动化脱壳框架简介与脱壳点的选择&#xA;FART 主动调用组件设计和源码分析&#xA;开源地址：https://github.com/hanbinglengyue/FART&#xA;目前 FART 是基于 Android 6.0 实现，源码文件结构如下：&#xA;把 FART 源码移植到 LineageOS 17.1（Android 10）。&#xA;关于 LineageOS 源码的下载与编译参考：LineageOS源码下载和编译（Xiaomi Mi 6X，wayne）&#xA;移植 FART 到 Android 10 对比 android 6.0 中的源码和 FART 的源码找到修改的地方并移植到 Android 10 源码中&#xA;interpreter.cc 路径：art/runtime/interpreter/interpreter.cc&#xA;Android 6.0 源码：https://cs.android.com/android/platform/superproject/+/android-6.0.0_r1:art/runtime/interpreter/interpreter.cc&#xA;namespace art 中增加 dumpDexFileByExecute 函数声明&#xA;//add&#xD;extern &amp;#34;C&amp;#34; void dumpDexFileByExecute(ArtMethod* artmethod); 在 Execute 函数头部增加 dumpDexFileByExecute 调用&#xA;static inline JValue Execute(&#xD;Thread* self,&#xD;const CodeItemDataAccessor&amp;amp; accessor,&#xD;ShadowFrame&amp;amp; shadow_frame,&#xD;JValue result_register,&#xD;bool stay_in_interpreter = false,&#xD;bool from_deoptimize = false) REQUIRES_SHARED(Locks::mutator_lock_) {&#xD;//add&#xD;LOG(INFO) &amp;lt;&amp;lt; &amp;#34;[Execute]&amp;#34; &amp;lt;&amp;lt; shadow_frame.</description>
    </item>
    <item>
      <title>LineageOS源码下载和编译（Xiaomi Mi 6X，wayne）</title>
      <link>https://cyrus-studio.github.io/blog/posts/lineageos%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91xiaomi-mi-6xwayne/</link>
      <pubDate>Tue, 20 May 2025 19:30:05 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/lineageos%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91xiaomi-mi-6xwayne/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;源码下载 LineageOS官网：https://lineageos.org/&#xA;LineageOS源码 github 地址：https://github.com/LineageOS/android&#xA;LineageOS源码国内镜像地址：https://mirrors.tuna.tsinghua.edu.cn/help/lineageOS/&#xA;源码大概需要150GB的硬盘空间，编译完成差不多300G&#xA;1. 配置git git config --global user.email &amp;#34;you@example.com&amp;#34;&#xD;git config --global user.name &amp;#34;Your Name&amp;#34; 2. 安装 repo mkdir ~/bin&#xD;PATH=~/bin:$PATH&#xD;curl https://storage.googleapis.com/git-repo-downloads/repo &amp;gt; ~/bin/repo&#xD;chmod a+x ~/bin/repo 3. 安装 Git LFS sudo apt install git-lfs&#xD;git lfs install 4. 安装 Android SDK Platform-Tools 在 Linux 中配置 Android SDK Platform-Tools，可以按照以下步骤进行&#xA;4.1 下载 Android SDK Platform-Tools： # cd 到存放 platform-tools 的目录&#xD;cd /mnt/case_sensitive&#xD;# 下载 platform-tools&#xD;wget https://dl.</description>
    </item>
    <item>
      <title>FART 自动化脱壳框架简介与脱壳点的选择</title>
      <link>https://cyrus-studio.github.io/blog/posts/fart-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%E4%B8%8E%E8%84%B1%E5%A3%B3%E7%82%B9%E7%9A%84%E9%80%89%E6%8B%A9/</link>
      <pubDate>Mon, 19 May 2025 23:35:03 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/fart-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%E4%B8%8E%E8%84%B1%E5%A3%B3%E7%82%B9%E7%9A%84%E9%80%89%E6%8B%A9/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;FART简介 ART 环境下基于主动调用的自动化脱壳方案，可以解决函数抽取壳。&#xA;关于函数抽取壳的实现原理可以参考：基于 art 下的类加载机制，实现函数抽取壳&#xA;FART 的作用就是所有这些被抽空的函数的还原和修复，把加固的 dex 整体 dump 下来。&#xA;项目地址：https://github.com/hanbinglengyue/FART&#xA;FART 框架 脱壳组件：将内存中的 Dex 数据完整 dump 出来&#xA;主动调用组件：构造主动调用链，完成对函数粒度的主动调用并完成 CodeItem 的 dump&#xA;修复组件：利用脱壳组件得到的 dex 和主动调用 dump 下来的函数体，完成函数粒度的修复&#xA;FART 中的脱壳点 其中 FART 脱壳组件 选择 Execute 作为脱壳点，它是 Interpreter 模式执行所有 Java 方法的统一入口，能够稳定截获和提取所有解释执行的真实方法，从而达到通用脱壳的目的。&#xA;ART 下函数在运行时可能是解释执行（Interpreter 模式）或编译执行（Quick 模式）。&#xA;为何选择 Execute 作为脱壳点？&#xA;dex2oat 编译流程 关于 dex2oat 以及 vdex、cdex、dex 格式转换&#xA;dex2oat 编译流程入口函数：&#xA;int main(int argc, char** argv) {&#xD;int result = static_cast&amp;lt;int&amp;gt;(art::Dex2oat(argc, argv));&#xD;// Everything was done, do an explicit exit here to avoid running Runtime destructors that take&#xD;// time (bug 10645725) unless we&amp;#39;re a debug or instrumented build or running on a memory tool.</description>
    </item>
    <item>
      <title>FART 主动调用组件设计和源码分析</title>
      <link>https://cyrus-studio.github.io/blog/posts/fart-%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 19 May 2025 23:32:39 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/fart-%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;现有脱壳方法存在的问题 脱壳粒度集中在 DexFile 整体，当前对 apk 保护的粒度在函数粒度，这就导致了脱壳与加固的不对等，无法应对函数粒度的加固保护。&#xA;Dalvik 下的基于主动调用的自动化脱壳方案，首次将粒度下降到函数粒度&#xA;https://github.com/zyq8709/DexHunter&#xA;https://github.com/F8LEFT/FUPK3&#xA;存在问题：&#xA;1、Dalvik 慢慢淡出视野，无法应对 ART 环境&#xA;2、当前没有一个好的脱壳修复框架，无法应用到 VMP 函数的修复&#xA;主动调用相关概念 1、被动调用&#xA;指 app 正常运行过程中发生的调用，该过程只对 dex 中部分的类完成了加载，同时也只是对 dex 中的部分函数完成了调用。&#xA;2、主动调用&#xA;通过构造虚拟调用，从而达到欺骗 “壳” ，让壳误以为 app 在执行正常的函数调用流程从而达成对 dex 中所有类函数的虚拟调用。&#xA;被动调用也可以用来完成函数粒度的修复。如当前通过正常运行 app ，待 app 将 dex 中的类正常加载并完成相关的函数的正常调用后再进行 dex 的 dump 的脱壳方法。&#xA;被动调用脱壳的缺点： 存在修复函数不全的问题。由于测试用例无法覆盖 dex 中所有的函数，导致代码覆盖率低，只能对 app 运行过程中调用过的函数的修复。&#xA;主动调用的优点： 能够覆盖 dex 中所有的函数，从而完成更彻底的函数粒度的修复。同时，函数的修复准确度同主动调用链的构造深度有关。&#xA;FART 中要解决的三个问题 1、如何构造主动调用链并让每一个函数都到达主动调用过程，但是又不影响 app 的正常运行？&#xA;2、如何根据 ArtMethod 定位内存中对应的 CodeItem 的起始地址？&#xA;3、如何遍历 dex 中的所有函数并完成主动调用？</description>
    </item>
    <item>
      <title>如何让 Google 收录 Github Pages 个人博客</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E8%AE%A9-google-%E6%94%B6%E5%BD%95-github-pages-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Fri, 16 May 2025 18:56:56 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E8%AE%A9-google-%E6%94%B6%E5%BD%95-github-pages-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;如何确认自己的网站有没有被 google 收录 假设网址是：https://cyrus-studio.github.io/blog&#xA;搜索：site:https://cyrus-studio.github.io/blog，如果没有任何内容就是没有被收录。&#xA;提交站点到 Google Search Console 点击 “尝试使用 Google Search Console”，输入网址，点击继续&#xA;验证站点所有权，下载一个 googlexxxx.html 文件&#xA;将此文件放在你的 GitHub Pages 仓库下的根目录下，git push 重新构建网站&#xA;确认能正常访问：https://cyrus-studio.github.io/blog/google831ed0d6f75c24f0.html&#xA;点击验证按钮&#xA;验证完成&#xA;等待收录&#xA;提交 Sitemap（可选但推荐） Sitemap 能帮助 Google 更好地理解你的网站结构。&#xA;Hugo 默认生成 sitemap 于：&#xA;https://cyrus-studio.github.io/blog/sitemap.xml 在 Google Search Console 中提交这个 sitemap：&#xA;打开你的属性&#xA;点击左侧“索引 &amp;gt; Sitemap”&#xA;输入 sitemap.xml 并提交&#xA;添加 robots.txt（确认允许爬取） 在你的仓库中添加 robots.txt 文件：&#xA;User-agent: *&#xD;Allow: /&#xD;Sitemap: https://cyrus-studio.github.io/blog/sitemap.xml 确保 Google bot 被允许访问页面。&#xA;git push</description>
    </item>
    <item>
      <title>在 Hugo 博客中集成评论系统 Waline 与 浏览量统计</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%9C%A8-hugo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E9%9B%86%E6%88%90%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F-waline-%E4%B8%8E-%E6%B5%8F%E8%A7%88%E9%87%8F%E7%BB%9F%E8%AE%A1/</link>
      <pubDate>Thu, 15 May 2025 15:41:19 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%9C%A8-hugo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E9%9B%86%E6%88%90%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F-waline-%E4%B8%8E-%E6%B5%8F%E8%A7%88%E9%87%8F%E7%BB%9F%E8%AE%A1/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;关于 Waline Waline 是一个轻量级、快速且安全的评论系统，适用于静态网站。&#xA;其主要特点包括：&#xA;轻量级：前端仅约 50KB，加载速度快。&#xA;支持 Markdown：支持完整的 Markdown 语法，方便用户撰写格式化评论。&#xA;多种部署方式：支持 Vercel、Netlify、CloudBase、Docker 等多种部署方式。&#xA;多种存储后端支持：支持 LeanCloud、MongoDB、MySQL、SQLite 等多种数据库。&#xA;安全性：具备防刷频、IP 黑名单、评论内容重复检查等安全功能。&#xA;社交登录支持：支持 QQ、微信、Telegram 等社交平台登录。&#xA;通知功能：支持邮件、微信、QQ、Telegram 等通知方式。&#xA;Waline 是开源的，采用 GPL-2.0 许可证。&#xA;官网：https://waline.js.org/&#xA;开源地址：https://github.com/walinejs/waline&#xA;快速上手：https://waline.js.org/guide/get-started/&#xA;LeanCloud 设置 (数据库) 创建评论数据存储数据库。&#xA;1、登录 或 注册 LeanCloud 国际版 并进入 控制台&#xA;https://console.leancloud.app/apps&#xA;2、点击左上角 创建应用 并起一个你喜欢的名字 (请选择免费的开发版):&#xA;3、进入应用，选择左下角的 设置 &amp;gt; 应用 Key。你可以看到你的 APP ID,APP Key 和 Master Key。请记录它们，以便后续使用。&#xA;Vercel 部署 (服务端) 1、点击下面链接，跳转至 Vercel 进行 Server 端部署。&#xA;https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample&#xA;注：如果你未登录的话，Vercel 会让你注册或登录，请使用 GitHub 账户进行快捷登录。</description>
    </item>
    <item>
      <title>基于 art 下的类加载机制，实现函数抽取壳</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8E-art-%E4%B8%8B%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E6%8A%BD%E5%8F%96%E5%A3%B3/</link>
      <pubDate>Wed, 14 May 2025 16:12:27 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8E-art-%E4%B8%8B%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E6%8A%BD%E5%8F%96%E5%A3%B3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;ART 下类加载流程 类加载的时机 1、隐式加载：&#xA;创建类的实例&#xA;访问类的静态变量，或者为静态变量赋值&#xA;调用类的静态方法&#xA;使用反射方式来强制创建某个类或接口对应的 java.lang.Class 对象&#xA;初始化某个类的子类&#xA;2、显示加载：&#xA;使用 loadClass() 加载&#xA;使用 forName() 加载&#xA;两者又有所不同。&#xA;类加载的流程 loadClass 和 forName 也是有区别的；&#xA;loadClass 只完成了第一步，就是加载；&#xA;Class.forName 是完成了3步，加载、链接和初始化。&#xA;阶段 发生了什么 加载 字节码文件 -&amp;gt; Class 对象 验证 检查字节码合法性 准备 静态变量分配内存，默认值 解析 符号引用 → 真实引用 初始化 调用 &amp;lt;clinit&amp;gt; 函数，static 代码块执行，静态变量赋值 一个类从“加载” 到 “可以使用” 的完整生命周期：加载（Loading）→ 连接（Linking）→ 初始化（Initialization）。&#xA;加载（Loading）&#xD;↓&#xD;连接（Linking）&#xD;→ 验证（Verification）&#xD;→ 准备（Preparation）&#xD;→ 解析（Resolution）&#xD;↓&#xD;初始化（Initialization）&#xD;↓&#xD;使用（Use）&#xD;↓&#xD;卸载（Unload） 相关文章：Android 下的 ClassLoader 与 双亲委派机制</description>
    </item>
    <item>
      <title>关于 dex2oat 以及 vdex、cdex、dex 格式转换</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%85%B3%E4%BA%8E-dex2oat-%E4%BB%A5%E5%8F%8A-vdexcdexdex-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 10 May 2025 20:26:46 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%85%B3%E4%BA%8E-dex2oat-%E4%BB%A5%E5%8F%8A-vdexcdexdex-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;dex2oat dex2oat 是 Android 系统中的一个核心工具，负责将应用中的 .dex（Dalvik Executable）字节码编译为本地机器代码（native code），以提高运行效率。它的全称是 DEX to OAT（Optimized Android Transport）。&#xA;dex2oat 的作用 在 Android 系统中，Java/Kotlin 编写的应用在编译时会被转换为 .dex 文件。为了提高性能，Android 会将 .dex 文件进一步编译为 .oat 文件（或 .odex/.vdex 文件），以便设备可以直接执行本地代码而不是解释执行 .dex 字节码。&#xA;工作原理（简要流程） 输入：一个或多个 .dex 文件（通常来自 APK 中的 classes.dex）。&#xA;输出：生成 .oat（Optimized Android Executable）、.vdex（Verified DEX）和 .art（Android Runtime）文件。&#xA;过程：&#xA;验证并优化 .dex。&#xA;使用 AOT（Ahead-Of-Time）方式将 .dex 转为本地机器码。&#xA;生成平台相关的可执行文件，用于加快应用启动速度。&#xA;编译模式：&#xA;AOT（Ahead-Of-Time）：安装或开机前就编译好，提高运行速度。&#xA;JIT（Just-In-Time）：运行时动态编译，节省空间但牺牲性能。&#xA;Hybrid（混合）：Android 7.0+ 默认模式，结合 AOT 与 JIT。&#xA;执行时机 第一次开机：系统会对预装的应用使用 dex2oat 编译。&#xA;App 安装时：根据编译策略（speed, quicken, interpret-only 等）选择是否编译。</description>
    </item>
    <item>
      <title>Android 下的 ClassLoader 与 双亲委派机制</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-%E4%B8%8B%E7%9A%84-classloader-%E4%B8%8E-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Tue, 06 May 2025 00:53:33 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-%E4%B8%8B%E7%9A%84-classloader-%E4%B8%8E-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;类加载器 ClassLoader 在 JVM（Java Virtual Machine）中，类加载器（ClassLoader）负责将 .class 文件加载到内存中，并将其转换为 JVM 可以使用的 Class 对象。&#xA;JVM 中主要有以下几种类加载器（ClassLoader）：&#xA;1. 引导类加载器（Bootstrap ClassLoader） 加载内容：JDK 的核心类库（JAVA_HOME/lib 下的类，如 rt.jar、java.lang、java.util 等系统类）。&#xA;由 C/C++ 实现，是 JVM 的一部分，JVM 的启动就是通过 Bottstrap ，不是 Java 类。&#xA;没有父类加载器（即 getParent() 返回 null）。&#xA;2. 拓展类加载器（Extension ClassLoader） 加载内容：JAVA_HOME/lib/ext/ 目录或由 java.ext.dirs 指定的路径中的类。&#xA;实现类：sun.misc.Launcher$ExtClassLoader&#xA;父加载器：Bootstrap ClassLoader&#xA;3. 应用类加载器（Application ClassLoader） 加载内容：用户类路径（classpath）上的类，比如通过 -cp 或 -classpath 指定的类和 jar。&#xA;实现类：sun.misc.Launcher$AppClassLoader&#xA;父加载器：Extension ClassLoader&#xA;我们编写的大部分 Java 应用程序类就是由它加载的，ClassLoader.getSystemClassLoader 返回的就是它。&#xA;自定义类加载器 通过继承 java.lang.ClassLoader 自定义类加载器，实现自己的类加载逻辑，比如从网络、数据库、加密文件中加载类。&#xA;类加载顺序，比如：YourCustomClassLoader.findClass( classX.class)</description>
    </item>
    <item>
      <title>ART 下 Dex 加载流程源码分析 和 通用脱壳点</title>
      <link>https://cyrus-studio.github.io/blog/posts/art-%E4%B8%8B-dex-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%92%8C-%E9%80%9A%E7%94%A8%E8%84%B1%E5%A3%B3%E7%82%B9/</link>
      <pubDate>Sun, 04 May 2025 22:27:06 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/art-%E4%B8%8B-dex-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%92%8C-%E9%80%9A%E7%94%A8%E8%84%B1%E5%A3%B3%E7%82%B9/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;DEF CON DEF CON 是全球最大的计算机安全会议之一（极客的奥斯卡），自1993年6月起，每年在美国内华达州的拉斯维加斯举办。&#xA;官网：https://media.defcon.org/，DEF CON 黑客大会官方的媒体存档站点，提供历年 DEF CON 大会的公开演讲、幻灯片、视频、音频、代码示例和其他相关资源的免费下载。&#xA;在 DEF CON 25（2017 年）上，Check Point 的安全研究员 Slava Makkaveev 和 Avi Bashan 发表了题为《Unboxing Android: Everything You Wanted to Know About Android Packers》的演讲，深入探讨了 Android 应用程序中的加壳技术及其安全影响。&#xA;报告文件地址：&#xA;https://media.defcon.org/DEF%20CON%2025/DEF%20CON%2025%20presentations/DEF%20CON%2025%20-%20Slava-Makkaveev-and-Avi-Bashan-Unboxing-Android.pdf&#xA;对于国内加壳厂商也有分析&#xA;DEF 的安全研究员选择的两个脱壳点：art::OpenAndReadMagic 和 DexFile::DexFile&#xA;Unboxing Android 在 DEF CON 25 (2017) 上，Avi Bashan 和 Slava Makkaveev 提出过一种非常实用的 Android 加壳脱壳技术：&#xA;通过修改 DexFile::DexFile() 构造函数和 OpenAndReadMagic() 方法，可以在应用运行时，拦截 DEX 文件加载过程，从而拿到已经解密后的内存数据，完成脱壳。&#xA;1. DexFile::DexFile 构造函数 可以看到 DexFile::DexFile() 的构造函数参数里包含了：</description>
    </item>
    <item>
      <title>使用 Dex2C 加壳保护 Android APK 代码</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-dex2c-%E5%8A%A0%E5%A3%B3%E4%BF%9D%E6%8A%A4-android-apk-%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 27 Apr 2025 22:38:15 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-dex2c-%E5%8A%A0%E5%A3%B3%E4%BF%9D%E6%8A%A4-android-apk-%E4%BB%A3%E7%A0%81/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Dex2C Dex2C 是一个将 Android 应用中的 DEX 字节码（Java 层代码）转换为语义等效的 C 代码的工具。&#xA;经过 Dex2C 处理后，Java 方法就变成 Native 层的方法了，从而实现源码隐藏保护。&#xA;java 代码：&#xA;object AESUtils {&#xD;// 将普通字符串转换为 IvParameterSpec&#xD;private fun stringToIV(iv: String): IvParameterSpec {&#xD;// 通过 UTF-8 编码将字符串转为字节数组，确保其长度为 16 字节&#xD;val ivBytes = iv.toByteArray(Charsets.UTF_8)&#xD;val ivArray = ByteArray(16)&#xD;System.arraycopy(ivBytes, 0, ivArray, 0, Math.min(ivBytes.size, 16))&#xD;return IvParameterSpec(ivArray)&#xD;}&#xD;} 转换后的 C/C++ 代码：&#xA;#include &amp;#34;Dex2C.h&amp;#34;&#xD;/* LAESUtils;-&amp;gt;stringToIV(Ljava/lang/String;)Ljavax/crypto/spec/IvParameterSpec; */&#xD;extern &amp;#34;C&amp;#34; JNIEXPORT jobject&#xD;JNICALL Java_AESUtils_stringToIV__Ljava_lang_String_2(JNIEnv *env, jobject thiz, jstring p4) {&#xD;jobject v0 = NULL;&#xD;jobject v1 = NULL;&#xD;jobject v2 = NULL;&#xD;jobject v3 = NULL;&#xD;jint v4;&#xD;jobject v5 = NULL;&#xD;jint v6;&#xD;jint v7;&#xD;jclass cls0 = NULL, cls1 = NULL, cls2 = NULL, cls3 = NULL, cls4 = NULL, cls5 = NULL, cls6 = NULL;&#xD;jfieldID fld0 = NULL;&#xD;jmethodID mth0 = NULL, mth1 = NULL, mth2 = NULL, mth3 = NULL, mth4 = NULL;&#xD;v0 = (jobject)&#xD;env-&amp;gt;NewLocalRef(thiz);&#xD;v1 = (jobject)&#xD;env-&amp;gt;NewLocalRef(p4);&#xD;L0:&#xD;LOGD(&amp;#34;0:sget-object \x76\x30\x2c\x20\x4c\x6b\x6f\x74\x6c\x69\x6e\x2f\x74\x65\x78\x74\x2f\x43\x68\x61\x72\x73\x65\x74\x73\x3b\x2d\x3e\x55\x54\x46\x5f\x38\x20\x4c\x6a\x61\x76\x61\x2f\x6e\x69\x6f\x2f\x63\x68\x61\x72\x73\x65\x74\x2f\x43\x68\x61\x72\x73\x65\x74\x3b&amp;#34;);&#xD;{&#xD;#define EX_HANDLE EX_UnwindBlock&#xD;if (v2) {&#xD;LOGD(&amp;#34;env-&amp;gt;DeleteLocalRef(%p):v2&amp;#34;, v2);&#xD;env-&amp;gt;DeleteLocalRef(v2);&#xD;}&#xD;jclass &amp;amp;clz = cls0;&#xD;jfieldID &amp;amp;fld = fld0;&#xD;D2C_RESOLVE_STATIC_FIELD(clz, fld, &amp;#34;kotlin/text/Charsets&amp;#34;, &amp;#34;UTF_8&amp;#34;, &amp;#34;Ljava/nio/charset/Charset;&amp;#34;);&#xD;v2 = (jobject)&#xD;env-&amp;gt;GetStaticObjectField(clz, fld);&#xD;D2C_CHECK_PENDING_EX;&#xD;#undef EX_HANDLE&#xD;}&#xD;LOGD(&amp;#34;4:invoke-virtual \x76\x34\x2c\x20\x76\x30\x2c\x20\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x2d\x3e\x67\x65\x74\x42\x79\x74\x65\x73\x28\x4c\x6a\x61\x76\x61\x2f\x6e\x69\x6f\x2f\x63\x68\x61\x72\x73\x65\x74\x2f\x43\x68\x61\x72\x73\x65\x74\x3b\x29\x5b\x42&amp;#34;);&#xD;{&#xD;#define EX_HANDLE EX_UnwindBlock&#xD;D2C_NOT_NULL(v1);&#xD;jclass &amp;amp;clz = cls1;&#xD;jmethodID &amp;amp;mid = mth0;&#xD;D2C_RESOLVE_METHOD(clz, mid, &amp;#34;java/lang/String&amp;#34;, &amp;#34;getBytes&amp;#34;, &amp;#34;(Ljava/nio/charset/Charset;)[B&amp;#34;);&#xD;jvalue args[] = {{.</description>
    </item>
    <item>
      <title>Android APP 热修复原理</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-app-%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 27 Apr 2025 05:27:30 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-app-%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;dexElements Android 的 ClassLoader（如 PathClassLoader、DexClassLoader）内部结构如下：&#xA;BaseDexClassLoader&#xD;└── pathList : DexPathList&#xD;└── dexElements : Array&amp;lt;DexPathList.Element&amp;gt; DexPathList 是 BaseDexClassLoader 用来管理 .dex 文件、.apk 和 .jar 的内部类，负责构建和维护类加载搜索路径。&#xA;http://aospxref.com/android-10.0.0_r47/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java#51&#xA;dexElements 是 DexPathList 中用于保存所有 .dex 文件对应的元素数组，每个 Element 表示一个可用于加载类和资源的路径项，类加载时会依次查找这些元素。&#xA;http://aospxref.com/android-10.0.0_r47/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java#69&#xA;findClass 方法迭代 dexElements 数组查找类&#xA;http://aospxref.com/android-10.0.0_r47/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java&#xA;热修复原理 合并多个 dexElements 数组是插件化框架或热修复系统中的常见操作。你可以通过反射将多个 dex 元素合并成一个新的数组，然后注入回去。&#xA;这就是热修复的原理，把 新的 dex 添加到 dexElements 前面，那么 findClass 的时候就会优先使用最新的 dex 中的类&#xA;代码实现 通过反射拿到 ClassLoader 中的 dexElements 数组 fun getDexElementsFrom(classLoader: ClassLoader): Array&amp;lt;Any&amp;gt;? {&#xD;return try {&#xD;// 1.</description>
    </item>
    <item>
      <title>Android 加壳应用运行流程 与 生命周期类处理方案</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-%E5%8A%A0%E5%A3%B3%E5%BA%94%E7%94%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-%E4%B8%8E-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%B1%BB%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sun, 27 Apr 2025 05:27:30 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-%E5%8A%A0%E5%A3%B3%E5%BA%94%E7%94%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-%E4%B8%8E-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%B1%BB%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;DexClassLoader DexClassLoader 可以加载任意路径下的 dex，或者 jar、apk、zip 文件（包含classes.dex）。常用于插件化、热修复以及 dex 加壳。&#xA;源码如下：&#xA;public class DexClassLoader extends BaseDexClassLoader {&#xD;public DexClassLoader(String dexPath, String optimizedDirectory,&#xD;String librarySearchPath, ClassLoader parent) {&#xD;super(dexPath, null, librarySearchPath, parent);&#xD;}&#xD;} http://aospxref.com/android-10.0.0_r47/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java&#xA;参数说明&#xA;参数 类型 说明 dexPath String 需要加载的 dex、apk、jar、zip 文件的路径，多个路径用 : 分隔。支持任意目录下的文件。 optimizedDirectory String 用于存放优化后的 dex 文件（即 .odex），在 API level 26 已弃用（Android 8.0 Oreo）。 librarySearchPath String 指定本地库（native library，.so 文件）搜索路径，多个路径用 : 分隔。 parent ClassLoader 父类加载器，用于实现类加载的委托机制。 动态加载 动态加载 = 运行时按需加载代码或资源</description>
    </item>
    <item>
      <title>详解 Android APP 启动流程</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E8%AF%A6%E8%A7%A3-android-app-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Thu, 24 Apr 2025 03:49:04 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E8%AF%A6%E8%A7%A3-android-app-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;APP 启动流程 app 启动流程大概如下：&#xA;发起进程（startActivity/startService...）&#xD;↓&#xD;↓（Binder方式）&#xD;↓&#xD;system_server进程（Process.start）&#xD;↓&#xD;↓（Socket方式）&#xD;↓&#xD;Zygote进程（ZygoteInit.runSelectLoop()） ↓&#xD;新建进程（ActivityThread.main） ActivityThread.main() 是 Android 应用进程的入口函数。&#xA;1. 应用 → AMS（Binder） 由 ActivityManager.getService() 返回的 Binder 接口对象调用系统服务：&#xA;// 应用进程&#xD;ContextImpl.startActivity()&#xD;└── Instrumentation.execStartActivity()&#xD;└── ActivityManager.getService().startActivity() ← AIDL Binder 跨进程&#xD;└── ActivityManagerService.startActivity() 通过 AIDL 实现 Binder 跨进程通信，连接系统服务。&#xA;关于 Android 中 AIDL 实现 Binder 跨进程通信 可以参考：Android中的Service与进程间通信（IPC）详解&#xA;AMS 接口实现：&#xA;http://aospxref.com/android-10.0.0_r47/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java#startActivity&#xA;2. AMS/system_server → zygote（Socket） startActivity 最终调用到 Process.start 方法&#xA;475 /**&#xD;476 * State associated with the zygote process.</description>
    </item>
    <item>
      <title>Android NDK 编译 so 文件 抹除导出符号 反逆向</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-ndk-%E7%BC%96%E8%AF%91-so-%E6%96%87%E4%BB%B6-%E6%8A%B9%E9%99%A4%E5%AF%BC%E5%87%BA%E7%AC%A6%E5%8F%B7-%E5%8F%8D%E9%80%86%E5%90%91/</link>
      <pubDate>Tue, 15 Apr 2025 12:41:19 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-ndk-%E7%BC%96%E8%AF%91-so-%E6%96%87%E4%BB%B6-%E6%8A%B9%E9%99%A4%E5%AF%BC%E5%87%BA%E7%AC%A6%E5%8F%B7-%E5%8F%8D%E9%80%86%E5%90%91/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 NDK 编译 so 默认情况下，所有 public 函数 都会导出，通过 IDA、GHIDRA 可以看到函数名&#xA;但除了必须导出的 JNI 函数外，其余 C/C++ 函数符号不导出其实也完全没影响，编译器/链接器内部可以调用，运行时照样可以正常执行。&#xA;必须导出的 JNI 函数 函数名 是否必须导出 说明 JNI_OnLoad ✅ 是（总是） 系统通过 dlsym() 查找，初始化用 Java_&amp;hellip; ✅ 是（如果用静态注册） Java 层方法通过名称匹配 JNI_OnUnload ❌ 否（可选） 卸载时调用，不导出也不会出错 JNI_OnLoad_LibName（非标准） ❌ 否（特殊系统扩展） Android 未使用 JNI_GetCreatedJavaVMs、JNI_CreateJavaVM ❌ 否 仅在 native 启动 JVM 时使用（一般用不到） 使用 linker version script 精细控制导出 Linker Version Script 是 GNU 链接器（ld）提供的一种机制，用来控制 .so 或 .a 文件中哪些符号可以导出、哪些必须隐藏。&#xA;创建 hide.map 文件（仅导出所有 JNI_ 和 Java_ 开头的 JNI 方法）</description>
    </item>
    <item>
      <title>Frida 调用 kill 命令挂起&amp;恢复 Android 线程</title>
      <link>https://cyrus-studio.github.io/blog/posts/frida-%E8%B0%83%E7%94%A8-kill-%E5%91%BD%E4%BB%A4%E6%8C%82%E8%B5%B7%E6%81%A2%E5%A4%8D-android-%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Wed, 09 Apr 2025 18:17:57 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/frida-%E8%B0%83%E7%94%A8-kill-%E5%91%BD%E4%BB%A4%E6%8C%82%E8%B5%B7%E6%81%A2%E5%A4%8D-android-%E7%BA%BF%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Android 线程相关命令 获取 PID adb shell pidof com.shizhuang.duapp 查看线程信息 方法一：进入 /proc//task 进入 adb shell 执行下面命令&#xA;cd /proc/$(pidof com.shizhuang.duapp)/task&#xD;ls 这个目录中每一个子目录的名字就是该 App 的一个线程的 TID（Thread ID）。&#xA;你还可以进一步查看每个线程的状态：&#xA;cat /proc/$(pidof com.shizhuang.duapp)/task/&amp;lt;tid&amp;gt;/status 例如：&#xA;cat /proc/$(pidof com.shizhuang.duapp)/task/22432/status 方法二：使用 top 或 htop 查看线程 使用 top 查看线程信息&#xA;top -H -p $(pidof com.shizhuang.duapp) -H 表示以线程方式查看&#xA;-p 指定 PID&#xA;或者使用 htop 查看线程信息&#xA;htop -p $(pidof com.shizhuang.duapp) 通过 kill 命令 停止 / 挂起 / 恢复线程 kill 是 Linux 系统中用来向进程发送信号的命令，最常用于终止进程。虽然它名字叫 “kill”，但它可以发送多种信号，不只是“终止”。</description>
    </item>
    <item>
      <title>Frida 中解析 Native 层 jobjectArray 转换 JS 数组</title>
      <link>https://cyrus-studio.github.io/blog/posts/frida-%E4%B8%AD%E8%A7%A3%E6%9E%90-native-%E5%B1%82-jobjectarray-%E8%BD%AC%E6%8D%A2-js-%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 08 Apr 2025 04:02:38 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/frida-%E4%B8%AD%E8%A7%A3%E6%9E%90-native-%E5%B1%82-jobjectarray-%E8%BD%AC%E6%8D%A2-js-%E6%95%B0%E7%BB%84/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;在 native 层，Object[] 类型参数会以 jobjectArray 形式传递进来。你不能直接拿它当作 JS 数组来访问，必须通过 JNI 的方式逐个取出。&#xA;env.js 常用的 JNI 函数在 frida 的 env.js 中都已经定义好了&#xA;https://github.com/frida/frida-java-bridge/blob/main/lib/env.js&#xA;通过下面代码获取 JNIEnv 引用，就可以调用相关的 JNI 函数&#xA;let env = Java.vm.tryGetEnv() 文档：https://frida.re/docs/javascript-api/&#xA;获取数组长度 let arrLen = env.getArrayLength(objArray)&#xD;console.log(&amp;#39;array length is: &amp;#39; + arrLen); 元素类型判断 通过 getObjectClassName 可以获取到对象的类名进而判断该元素的类型。&#xA;// 获取对象的类名&#xD;let className = env.getObjectClassName(objArray)&#xD;console.log(&amp;#39;className: &amp;#39; + className);&#xD;// 判断是否 jobjectArray&#xD;if (className === &amp;#39;[Ljava.lang.Object;&amp;#39;) {&#xD;} 获取数组元素 let element = env.getObjectArrayElement(objArray, i) Int 元素读取 let intElement = Java.</description>
    </item>
    <item>
      <title>Frida Stalker Trace 指令跟踪&amp;寄存器变化监控</title>
      <link>https://cyrus-studio.github.io/blog/posts/frida-stalker-trace-%E6%8C%87%E4%BB%A4%E8%B7%9F%E8%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E5%8C%96%E7%9B%91%E6%8E%A7/</link>
      <pubDate>Mon, 07 Apr 2025 19:37:54 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/frida-stalker-trace-%E6%8C%87%E4%BB%A4%E8%B7%9F%E8%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E5%8C%96%E7%9B%91%E6%8E%A7/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Frida Stalker Frida 的 Stalker 是一个强大的代码追踪工具。&#xA;主要功能&#xA;指令级跟踪：Stalker 可精确到指令级别，对应用的原生代码进行实时监控。&#xA;代码插桩：支持在指定指令前后插入自定义的代码逻辑。&#xA;内存访问监控：可以监视内存读写操作，分析数据流向。&#xA;自定义回调：提供回调函数，方便记录和分析执行轨迹。&#xA;文档：https://frida.re/docs/javascript-api/#stalker&#xA;相关文章：&#xA;使用 Frida Hook Android App&#xA;使用 Frida Stalker 反 OLLVM 算法还原&#xA;Frida Stalker Trace 指令跟踪 在 Stalker.follow 的 transform 回调函数中 处理目标线程执行的每一条汇编指令。&#xA;iterator 是一个 指令迭代器对象，它让你能够 逐条处理目标线程将要执行的原始机器指令。&#xA;iterator 支持的方法&#xA;方法 作用 next() 获取下一条指令 keep() 保留指令（否则会被跳过） putCallout(fn) 插入 JS 回调（运行在主线程） 通过实现 transform 回调 trace 指定函数，打印地址、指令、模块信息&#xA;function getModuleByAddressSafe(address) {&#xD;try {&#xD;// 尝试获取模块&#xD;var module = Process.getModuleByAddress(address);&#xD;// 如果模块存在，返回模块&#xD;if (module) {&#xD;return module;&#xD;} else {&#xD;// 如果没有找到模块，返回 null&#xD;return null;&#xD;}&#xD;} catch (e) {&#xD;// 捕获异常，返回 null&#xD;return null;&#xD;}&#xD;}&#xD;/**&#xD;* 指令跟踪&#xD;*&#xD;* @param targetModuleName 目标模块名&#xD;* @param targetSymbol 函数偏移（或导出名）&#xD;*/&#xD;function trace(targetModuleName, targetSymbol) {&#xD;// 获取模块基地址&#xD;const base = Module.</description>
    </item>
    <item>
      <title>Unidbg Trace 反 OLLVM 控制流平坦化（fla）</title>
      <link>https://cyrus-studio.github.io/blog/posts/unidbg-trace-%E5%8F%8D-ollvm-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96fla/</link>
      <pubDate>Sun, 30 Mar 2025 23:35:02 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/unidbg-trace-%E5%8F%8D-ollvm-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96fla/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;目标 so 分析 目标方法反汇编视图如下&#xA;F5 反汇编代码如下，很明显通过 fla 隐藏了真实的执行流&#xA;__int64 __usercall dynamicBase64Encode@&amp;lt;X0&amp;gt;(const unsigned __int8 *a1@&amp;lt;X0&amp;gt;, unsigned __int64 a2@&amp;lt;X1&amp;gt;, __int64 a3@&amp;lt;X8&amp;gt;)&#xD;{&#xD;int v3; // w8&#xD;int v4; // w8&#xD;unsigned __int8 *v5; // x0&#xD;int v6; // w8&#xD;unsigned __int8 *v7; // x0&#xD;__int64 result; // x0&#xD;int i; // [xsp+20h] [xbp-60h]&#xD;unsigned __int64 v11; // [xsp+30h] [xbp-50h]&#xD;int v12; // [xsp+3Ch] [xbp-44h]&#xD;int v13; // [xsp+40h] [xbp-40h]&#xD;char v16[24]; // [xsp+60h] [xbp-20h] BYREF&#xD;__int64 v17; // [xsp+78h] [xbp-8h]&#xD;v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);&#xD;generateDynamicBase64Alphabet(a2);&#xD;sub_29574(a3);&#xD;v13 = 0;&#xD;v12 = -6;&#xD;v11 = 0LL;&#xD;do&#xD;{&#xD;if ( v11 &amp;gt;= a2 )&#xD;v3 = 491;&#xD;else&#xD;v3 = 26962;&#xD;for ( i = v3; ; i = 24464 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( i == 491 )&#xD;{&#xD;if ( v12 &amp;lt;= -6 )&#xD;v6 = 4827;&#xD;else&#xD;v6 = 2995;&#xD;i = v6;&#xD;}&#xD;if ( i !</description>
    </item>
    <item>
      <title>使用 Frida Stalker 反 OLLVM 算法还原</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-frida-stalker-%E5%8F%8D-ollvm-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F/</link>
      <pubDate>Sun, 30 Mar 2025 04:33:31 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-frida-stalker-%E5%8F%8D-ollvm-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 比如我们像分析某个 so 中偏移为 0x23AD0 的加密函数&#xA;IDA 反汇编 so，可以看到 so 中该函数做了混淆&#xA;控制流平坦化&#xA;Frida Stalker Frida 的 Stalker 是一个强大的代码追踪工具。&#xA;主要功能&#xA;指令级跟踪：Stalker 可精确到指令级别，对应用的原生代码进行实时监控。&#xA;代码插桩：支持在指定指令前后插入自定义的代码逻辑。&#xA;内存访问监控：可以监视内存读写操作，分析数据流向。&#xA;自定义回调：提供回调函数，方便记录和分析执行轨迹。&#xA;文档：https://frida.re/docs/javascript-api/#stalker&#xA;目前 Stalker 对于 arm64 支持比较好，但是 arm32 并不是很完善。&#xA;https://frida.re/docs/stalker/&#xA;关于 Frida 的使用可以参考这篇文章：使用 Frida Hook Android App&#xA;onCallSummary（函数调用摘要) onCallSummary 用于返回函数调用的摘要信息。&#xA;Stalker.follow() 使用 onCallSummary 时，不会实时回调，而是在合适的时间点返回已汇总的调用信息。&#xA;通常是在：&#xA;函数执行结束后&#xA;线程空闲或上下文切换时&#xA;Stalker缓冲区达到一定大小时&#xA;Stalker.flush();&#xA;因此，你会在目标函数执行完毕后，看到 onCallSummary 输出的调用信息。&#xA;summary 数据结构通常类似于以下格式：&#xA;{&#xD;&amp;#34;函数地址&amp;#34;: 调用次数&#xD;} hook 目标函数，跟踪 call 事件并打印 call summary&#xA;function onCallSummary() {&#xD;// 目标 so&#xD;var soName = &amp;#34;libaes.</description>
    </item>
    <item>
      <title>unidbg 加载 so 并调用 so 中函数</title>
      <link>https://cyrus-studio.github.io/blog/posts/unidbg-%E5%8A%A0%E8%BD%BD-so-%E5%B9%B6%E8%B0%83%E7%94%A8-so-%E4%B8%AD%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 27 Mar 2025 17:12:07 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/unidbg-%E5%8A%A0%E8%BD%BD-so-%E5%B9%B6%E8%B0%83%E7%94%A8-so-%E4%B8%AD%E5%87%BD%E6%95%B0/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;unidbg 简介 unidbg 是一个基于 Java 的 Android 动态分析框架，专注于模拟 Android 应用中的 native 代码。以下是它的主要功能：&#xA;支持对so的加载;&#xA;支持对JNI接口函数的模拟调用;&#xA;支持常见syscalls的模拟调用;&#xA;支持ARM32和ARM64。&#xA;支持Android以及iOS&#xA;基于HookZz实现的inline hook&#xA;xHook实现的hook&#xA;iOS fishhook，substrate、whale hook等&#xA;支持gdb、IDA远程调试等高级功能。&#xA;&amp;hellip;&#xA;Unidgb 项目地址：https://github.com/zhkl0228/unidbg&#xA;unidbg 底层引擎 unidbg 的 CPU 指令模拟主要由 dynarmic 和 unicorn 驱动。&#xA;dynarmic 是专注于 ARM 架构的模拟器，虽然它和 unicorn 都提供 ARM 模拟功能，但它们的设计目标和性能特点不同。unicorn 更加通用，而 dynarmic 则更注重效率。&#xA;dynarmic 项目地址：https://github.com/yuzu-mirror/dynarmic&#xA;Unicorn 项目地址：https://github.com/unicorn-engine/unicorn&#xA;dynarmic 与 unicorn 效率对比 clone unidbg 源码到本地并导入 IDEA，在 unidbg-android/src/test/java/com/kanxue/test2&#xA;MainActivity.java 中示例代码实现了爆破 so 中 test 函数 flag 参数（已知 so 中 test 函数参数为一个字符串，该字符串长度为3且仅包含大小写字母），如果 flag 正确函数会返回 true，通过不断调用该 jni 函数测试所有字母组合直到得到正确结果。</description>
    </item>
    <item>
      <title>Android 自定义变形 HMAC 算法</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E5%BD%A2-hmac-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 26 Mar 2025 22:17:56 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E5%BD%A2-hmac-%E7%AE%97%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;HMAC HMAC（Hash-based Message Authentication Code）是一种基于哈希函数的消息认证码，用于验证数据的完整性和真实性。&#xA;HMAC 主要依赖于以下几个要素：&#xA;消息（Message）：需要验证的数据。&#xA;密钥（Key）：共享的秘密密钥，用于保护消息。&#xA;哈希函数（Hash Function）：如 MD5、SHA-256 等。&#xA;HMAC 的计算公式如下：&#xA;其中：&#xA;H 是哈希函数。&#xA;K 是密钥。&#xA;M 是消息。&#xA;opad 是外部填充（0x5c）。&#xA;ipad 是内部填充（0x36）。&#xA;∥ 表示拼接。&#xA;⊕ 表示按位异或。&#xA;所以 HMAC 返回字符串长度取决于具体的哈希函数。&#xA;比如，哈希函数是 MD5 则返回的字符串就是 16 字节（128位），通常由长度为 32 的 十六进制字符串 表示 。&#xA;比如，哈希函数是 SHA256 则返回的字符串就是 32 字节（256位），通常由长度为 64 的 十六进制字符串 表示 。&#xA;HMAC MD5 标准 HMAC MD5 算法实现如下：&#xA;Key 处理： 如果密钥过长，用 MD5 进行压缩至 16 字节。&#xA;如果密钥不足 64 字节，用 0x00 填充至 64 字节。</description>
    </item>
    <item>
      <title>OLLVM 增加 C&amp;C&#43;&#43; 字符串加密功能</title>
      <link>https://cyrus-studio.github.io/blog/posts/ollvm-%E5%A2%9E%E5%8A%A0-cc&#43;&#43;-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Tue, 25 Mar 2025 22:00:30 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/ollvm-%E5%A2%9E%E5%8A%A0-cc&#43;&#43;-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E5%8A%9F%E8%83%BD/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 当我们如果没有对字符串进行加密，使用 IDA 反汇编一下 so 可以看到 C++ 代码中的字符串就直接暴露了。&#xA;字符串加密原理 sobf.c&#xA;#include &amp;lt;stdio.h&amp;gt;&#xD;int main() {&#xD;// 定义字符串常量&#xD;const char *greeting = &amp;#34;Hello, World!&amp;#34;;&#xD;const char *name = &amp;#34;Cyrus&amp;#34;;&#xD;const char *message = &amp;#34;Welcome to C programming.&amp;#34;;&#xD;// 打印字符串常量&#xD;printf(&amp;#34;%s\n&amp;#34;, greeting);&#xD;printf(&amp;#34;My name is %s.\n&amp;#34;, name);&#xD;printf(&amp;#34;%s\n&amp;#34;, message);&#xD;return 0;&#xD;} 生成 ir 文件&#xA;clang -S -emit-llvm sobf.c -o sobf.ll 通过生成 ir 文件可以看到字符串的定义都是 @&amp;quot;??C@ ，引用的的地方通过 @&amp;quot;??C@ 使用&#xA;; ModuleID = &amp;#39;sobf.</description>
    </item>
    <item>
      <title>Android 自定义变形 SHA1 算法</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E5%BD%A2-sha1-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 25 Mar 2025 02:54:38 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E5%BD%A2-sha1-%E7%AE%97%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;标准 SHA1 SHA1（Secure Hash Algorithm 1）是一种广泛使用的 加密哈希函数，用于生成固定长度的 160 位（20 字节）哈希值。它由 美国国家安全局（NSA） 设计，并由 NIST（美国国家标准与技术研究院） 在 1995 年作为 FIPS PUB 180-1 标准发布。&#xA;SHA1 的基本特点&#xA;输出长度：160 位（20 字节）的哈希值，通常以长度为 40 的 hex 字符串表示&#xA;使用 5 个固定的初始哈希值（MD5 是 4 个）&#xA;不可逆性：无法从哈希值反推出原文&#xA;固定性：相同的输入始终会产生相同的输出&#xA;雪崩效应：输入的微小变化会导致输出哈希值的巨大变化&#xA;抗碰撞性（已破坏）：理论上很难找到两个不同的输入产生相同的哈希值&#xA;SHA1 C++ 标准实现如下：&#xA;sha1.h&#xA;#ifndef SHA1_H&#xD;#define SHA1_H&#xD;#include &amp;lt;stdlib.h&amp;gt;&#xD;#include &amp;lt;string.h&amp;gt;&#xD;#include &amp;lt;asm/types.h&amp;gt;&#xD;#define os_memcpy memcpy&#xD;#define os_memset memset&#xD;#define os_memcmp memcmp&#xD;#define os_strlen strlen&#xD;#define MAX_SHA1_LEN 32&#xD;#define SHA1_MAC_LEN 20&#xD;typedef __u8 u8;&#xD;typedef __u32 u32;&#xD;struct SHA1Context {&#xD;u32 state[5];&#xD;u32 count[2];&#xD;unsigned char buffer[64];&#xD;};&#xD;typedef struct SHA1Context SHA1_CTX;&#xD;void SHA1Init(SHA1_CTX *context);&#xD;void SHA1Update(SHA1_CTX *context, const unsigned char *data, u32 len);&#xD;void SHA1Final(unsigned char digest[20], SHA1_CTX *context);&#xD;#endif /* SHA1_H */ sha1.</description>
    </item>
    <item>
      <title>Android 自定义变形 MD5 算法</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E5%BD%A2-md5-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 22 Mar 2025 02:09:55 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E5%BD%A2-md5-%E7%AE%97%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;MD5是一种哈希函数，用于将任意长度的数据映射为一个固定长度的哈希值。它由 Ron Rivest 在 1991 年设计，是继 MD4 之后的改进版本。&#xA;MD5 的基本特征：&#xA;固定长度输出：将任意长度的数据转换为 128 位（16 字节） 的哈希值，通常以 32 位十六进制 字符串表示。&#xA;不可逆性：无法从哈希值反推原始数据。&#xA;雪崩效应：输入的微小变化会导致哈希值完全不同。&#xA;抗碰撞性较弱：不同输入产生相同哈希值的概率较低，但已存在有效的碰撞攻击。&#xA;计算速度快：采用简单的位运算，处理速度快，适合大数据量。&#xA;标准 MD5 标准 MD5 的 C++ 实现如下：&#xA;md5.h&#xA;#ifndef __MD5_INCLUDE__&#xD;/* typedef a 32-bit type */&#xD;#ifdef _LP64&#xD;typedef unsigned int UINT4;&#xD;typedef int INT4;&#xD;#else&#xD;typedef unsigned long UINT4;&#xD;typedef long INT4;&#xD;#endif&#xD;#define _UINT4_T&#xD;/* Data structure for MD5 (Message-Digest) computation */&#xD;typedef struct {&#xD;UINT4 i[2]; /* number of _bits_ handled mod 2^64 */&#xD;UINT4 buf[4]; /* scratch buffer */&#xD;unsigned char in[64]; /* input buffer */&#xD;unsigned char digest[16]; /* actual digest after MD5Final call */&#xD;} MD5_CTX;&#xD;void MD5_Init (MD5_CTX *mdContext);&#xD;void MD5_Update (MD5_CTX *mdContext, unsigned char *inBuf, unsigned int inLen);&#xD;void MD5_Final (unsigned char hash[], MD5_CTX *mdContext);&#xD;#define __MD5_INCLUDE__&#xD;#endif /* __MD5_INCLUDE__ */ md5.</description>
    </item>
    <item>
      <title>使用 Unicorn 还原变异 CRC32 算法</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-unicorn-%E8%BF%98%E5%8E%9F%E5%8F%98%E5%BC%82-crc32-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 18 Mar 2025 20:33:21 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-unicorn-%E8%BF%98%E5%8E%9F%E5%8F%98%E5%BC%82-crc32-%E7%AE%97%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;ARM64Emulator ARM64Emulator 是基于 Unicorn 实现一个轻量级的 ARM64 模拟器，具备代码加载、内存映射、指令执行、反汇编、寄存器监控、Hook、Patch、字符串处理等功能&#xA;项目地址：https://github.com/CYRUS-STUDIO/ARM64Emulator&#xA;这里主要使用 ARM64Emulator 模拟执行 so 中的汇编指令实现算法还原。&#xA;目标应用信息 app 中实现一个 CRC32 算法变形，具体实现在 so 中 modifiedCRC32 函数，现在要通过 unicorn 和 IDA Pro 逆向还原 so 中的算法。&#xA;项目地址：https://github.com/CYRUS-STUDIO/AndroidExample&#xA;目标 so 文件地址：https://github.com/CYRUS-STUDIO/ARM64Emulator/tree/main/examples&#xA;使用 ARM64Emulator 加载 so 并执行 modifiedCRC32 函数的汇编指令实现算法还原。&#xA;from unicorn.arm64_const import *&#xD;import struct&#xD;import re&#xD;from ARM64Emulator import ARM64Emulator&#xD;def modifiedCRC32(data):&#xD;emulator = ARM64Emulator(&amp;#34;libcrc32.so&amp;#34;)&#xD;mu = emulator.mu&#xD;# 字符串地址&#xD;str_addr = emulator.STACK_BASE + emulator.STACK_SIZE&#xD;emulator.mu.mem_map(str_addr, 0x1000) # 4KB&#xD;.</description>
    </item>
    <item>
      <title>基于 Unicorn 实现一个轻量级的 ARM64 模拟器</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8E-unicorn-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84-arm64-%E6%A8%A1%E6%8B%9F%E5%99%A8/</link>
      <pubDate>Tue, 18 Mar 2025 18:21:53 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8E-unicorn-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84-arm64-%E6%A8%A1%E6%8B%9F%E5%99%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;基于 Unicorn 实现一个轻量级的 ARM64 模拟器，具备代码加载、内存映射、指令执行、反汇编、寄存器监控、Hook、Patch、字符串处理等功能，适合用于逆向分析或调试 ARM64 代码。&#xA;初始化与内存管理 代码加载：通过 _load_binary() 将 so 文件加载到内存中。&#xA;内存映射：在 _setup_memory() 中分配 10MB 的代码区和 1MB 的栈区。&#xA;寄存器初始化：在 _setup_registers() 中设置栈指针（SP）和程序计数器（PC）。&#xA;寄存器设置：提供了 set_x0()、set_x1() 和 set_x2() 等方法，用于直接设置寄存器值。&#xA;import capstone&#xD;from unicorn import *&#xD;from unicorn.arm64_const import *&#xD;class ARM64Emulator:&#xD;def __init__(self, so_file: str):&#xD;self.so_file = so_file&#xD;# 分配代码区（TEXT 段）&#xD;self.CODE_BASE = 0x000000 # 假设代码段起始地址&#xD;self.CODE_SIZE = 1024 * 1024 * 10 # 10MB&#xD;# 分配栈区（STACK 段）&#xD;self.STACK_BASE = self.</description>
    </item>
    <item>
      <title>安卓实现魔改版 CRC32 算法</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%AE%89%E5%8D%93%E5%AE%9E%E7%8E%B0%E9%AD%94%E6%94%B9%E7%89%88-crc32-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 13 Mar 2025 23:38:55 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%AE%89%E5%8D%93%E5%AE%9E%E7%8E%B0%E9%AD%94%E6%94%B9%E7%89%88-crc32-%E7%AE%97%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;关于 CRC32 算法介绍可以参考这篇文章：常用加解密算法介绍&#xA;标准 CRC32 算法 创建 crc32.cpp，使用 C++ 实现标准 CRC32 算法&#xA;#include &amp;lt;jni.h&amp;gt;&#xD;#include &amp;lt;string&amp;gt;&#xD;#include &amp;lt;android/log.h&amp;gt;&#xD;#define TAG &amp;#34;CRC32&amp;#34;&#xD;unsigned int crc32_table[256];&#xD;// 初始化 CRC32 查找表&#xD;void init_crc32_table() {&#xD;unsigned int crc;&#xD;for (int i = 0; i &amp;lt; 256; i++) {&#xD;crc = i;&#xD;for (int j = 8; j &amp;gt; 0; j--) {&#xD;if (crc &amp;amp; 1) {&#xD;crc = (crc &amp;gt;&amp;gt; 1) ^ 0xedb88320;&#xD;} else {&#xD;crc &amp;gt;&amp;gt;= 1;&#xD;}&#xD;}&#xD;crc32_table[i] = crc;&#xD;}&#xD;}&#xD;// 计算 CRC32&#xD;unsigned int crc32(const std::string&amp;amp; str) {&#xD;unsigned int crc = 0xffffffff;&#xD;for (size_t i = 0; i &amp;lt; str.</description>
    </item>
    <item>
      <title>安卓逆向魔改版 Base64 算法还原</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E9%AD%94%E6%94%B9%E7%89%88-base64-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F/</link>
      <pubDate>Wed, 12 Mar 2025 21:21:08 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E9%AD%94%E6%94%B9%E7%89%88-base64-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;目标 app 简介 可以看到 app 中共有 4 种 Base64 算法。选中一个随机字符串，可以选择其中一种算法进行编码解码。&#xA;app地址：https://github.com/CYRUS-STUDIO/AndroidExample&#xA;标准 Java Base64 算法还原 使用 jadx 反编译 apk，搜索找到按钮的代码&#xA;因为 app 中 ui 是用 Compose 实现的，所有 ui 都是 Function，所以这里看到 Text 是一个 Function&#xA;在 Function f57lambda2 上按 X 找到调用该 Function 的地方&#xA;再继续找 m6044getLambda2$app_release 的上层调用是 rememberedValue6&#xA;可以看到 rememberedValue6 中实际是调用了Base64ActivityKt.Base64App&amp;hellip;$lambda$16 方法&#xA;rememberedValue6 = new Function0() { // from class: com.cyrus.example.base64.Base64ActivityKt$$ExternalSyntheticLambda6&#xD;@Override // kotlin.jvm.functions.Function0&#xD;public final Object invoke() {&#xD;Unit Base64App$lambda$37$lambda$36$lambda$20$lambda$17$lambda$16;&#xD;Base64App$lambda$37$lambda$36$lambda$20$lambda$17$lambda$16 = Base64ActivityKt.</description>
    </item>
    <item>
      <title>安卓实现魔改版 Base64 算法</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%AE%89%E5%8D%93%E5%AE%9E%E7%8E%B0%E9%AD%94%E6%94%B9%E7%89%88-base64-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 12 Mar 2025 20:57:06 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%AE%89%E5%8D%93%E5%AE%9E%E7%8E%B0%E9%AD%94%E6%94%B9%E7%89%88-base64-%E7%AE%97%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Java 实现标准 Base64 编码和解码 Base64 编码：&#xA;val encoded = Base64.encodeToString(str.toByteArray(), Base64.DEFAULT) Base64 解码：&#xA;val decoded = Base64.decode(str, Base64.DEFAULT)&#xD;val decodedString = String(decoded) C++ 实现标准 Base64 编d码和解码 创建 base64.cpp 实现 Base64 编码和解码&#xA;#include &amp;lt;jni.h&amp;gt;&#xD;#include &amp;lt;string&amp;gt;&#xD;#include &amp;lt;android/log.h&amp;gt;&#xD;static const std::string base64_chars =&#xD;&amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34;&#xD;&amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34;&#xD;&amp;#34;0123456789+/&amp;#34;;&#xD;// 检查字符是否是 Base64 字符&#xD;static inline bool is_base64(unsigned char c) {&#xD;return (isalnum(c) || (c == &amp;#39;+&amp;#39;) || (c == &amp;#39;/&amp;#39;));&#xD;}&#xD;// Base64 编码函数&#xD;std::string base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len) {&#xD;std::string ret;&#xD;int i = 0;&#xD;int j = 0;&#xD;unsigned char char_array_3[3];&#xD;unsigned char char_array_4[4];&#xD;while (in_len--) {&#xD;char_array_3[i++] = *(bytes_to_encode++);&#xD;if (i == 3) {&#xD;char_array_4[0] = (char_array_3[0] &amp;amp; 0xfc) &amp;gt;&amp;gt; 2;&#xD;char_array_4[1] = ((char_array_3[0] &amp;amp; 0x03) &amp;lt;&amp;lt; 4) + ((char_array_3[1] &amp;amp; 0xf0) &amp;gt;&amp;gt; 4);&#xD;char_array_4[2] = ((char_array_3[1] &amp;amp; 0x0f) &amp;lt;&amp;lt; 2) + ((char_array_3[2] &amp;amp; 0xc0) &amp;gt;&amp;gt; 6);&#xD;char_array_4[3] = char_array_3[2] &amp;amp; 0x3f;&#xD;for (i = 0; i &amp;lt; 4; i++) {&#xD;ret += base64_chars[char_array_4[i]];&#xD;}&#xD;i = 0;&#xD;}&#xD;}&#xD;if (i) {&#xD;for (int j = i; j &amp;lt; 3; j++) {&#xD;char_array_3[j] = &amp;#39;\0&amp;#39;;&#xD;}&#xD;char_array_4[0] = (char_array_3[0] &amp;amp; 0xfc) &amp;gt;&amp;gt; 2;&#xD;char_array_4[1] = ((char_array_3[0] &amp;amp; 0x03) &amp;lt;&amp;lt; 4) + ((char_array_3[1] &amp;amp; 0xf0) &amp;gt;&amp;gt; 4);&#xD;char_array_4[2] = ((char_array_3[1] &amp;amp; 0x0f) &amp;lt;&amp;lt; 2) + ((char_array_3[2] &amp;amp; 0xc0) &amp;gt;&amp;gt; 6);&#xD;char_array_4[3] = char_array_3[2] &amp;amp; 0x3f;&#xD;for (int j = 0; j &amp;lt; i + 1; j++) {&#xD;ret += base64_chars[char_array_4[j]];&#xD;}&#xD;while ((i++ &amp;lt; 3)) {&#xD;ret += &amp;#39;=&amp;#39;;&#xD;}&#xD;}&#xD;return ret;&#xD;}&#xD;// Base64 解码函数&#xD;std::string base64_decode(std::string const&amp;amp; encoded_string) {&#xD;int in_len = encoded_string.</description>
    </item>
    <item>
      <title>常用加解密算法介绍</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%B8%B8%E7%94%A8%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 07 Mar 2025 00:25:26 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%B8%B8%E7%94%A8%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;常见加解密工具 CyberChef CyberChef 是一个功能强大的数据处理工具，由 GCHQ（英国政府通信总部）开发。它提供了一系列 加密、解密、编码、解码、数据转换、压缩、哈希、取证分析 等功能，适用于安全研究、数据处理和取证分析等场景。&#xA;CyberChef Web 地址：https://gchq.github.io/CyberChef/&#xA;项目地址：https://github.com/gchq/CyberChef&#xA;openssl OpenSSL 是一个开源加密库，支持 SSL/TLS 协议，实现 RSA、AES、SM2、SM4 等算法，提供加密、证书管理、哈希计算等功能，广泛用于网络安全、身份认证和数据保护。&#xA;项目地址：https://github.com/openssl/openssl&#xA;各种常见的加密算法在 openssl 中都有实现&#xA;cryptopp Crypto++ 是一个开源 C++ 加密库。&#xA;cryptopp 编译相对于 openssl 比较简便，不需要安装特殊依赖环境。&#xA;项目地址：https://github.com/weidai11/cryptopp&#xA;chilkat Chilkat 是一个跨平台加密和网络通信库，收费，不开源，但是已经编译好各种平台的库，直接拿来就用。&#xA;下载地址：https://www.chilkatsoft.com/downloads.asp&#xA;编码算法 编码算法是一种用于数据转换的方法，它将信息从一种格式转换为另一种格式，便于存储和传输。&#xA;Hex Hex 编码是一种将二进制数据转换为十六进制字符串的编码方式&#xA;data = b&amp;#34;Hello&amp;#34;&#xD;hex_encoded = data.hex()&#xD;print(&amp;#34;Hex 编码:&amp;#34;, hex_encoded)&#xD;hex_decoded = bytes.fromhex(hex_encoded)&#xD;print(&amp;#34;Hex 解码:&amp;#34;, hex_decoded.decode()) 输出如下：&#xA;Hex 编码: 48656c6c6f&#xD;Hex 解码: Hello URL Encode / URL Decode URL 编码 是一种用于在 URL 中安全传输特殊字符的编码方式，将非 ASCII 字符、特殊字符转换为百分号（%）+ 两位十六进制数的格式。</description>
    </item>
    <item>
      <title>unidbg 实现 JNI 与 Java 交互</title>
      <link>https://cyrus-studio.github.io/blog/posts/unidbg-%E5%AE%9E%E7%8E%B0-jni-%E4%B8%8E-java-%E4%BA%A4%E4%BA%92/</link>
      <pubDate>Mon, 03 Mar 2025 10:33:06 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/unidbg-%E5%AE%9E%E7%8E%B0-jni-%E4%B8%8E-java-%E4%BA%A4%E4%BA%92/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Android 示例代码 在 com.cyrus.example.unidbg.UnidbgActivity 编写一个静态变量 a 和非静态变量 b，还有 base64 方法。&#xA;代码如下：&#xA;package com.cyrus.example.unidbg&#xD;import android.os.Bundle&#xD;import androidx.appcompat.app.AppCompatActivity&#xD;import android.util.Base64&#xD;class UnidbgActivity : AppCompatActivity() {&#xD;companion object {&#xD;// 静态变量 a&#xD;var a: String? = null&#xD;}&#xD;// 非静态变量 b&#xD;var b: String? = null&#xD;override fun onCreate(savedInstanceState: Bundle?) {&#xD;super.onCreate(savedInstanceState)&#xD;setContentView(R.layout.activity_unidbg)&#xD;// 初始化静态变量 a 和 非静态变量 b&#xD;a = &amp;#34;StaticA&amp;#34;&#xD;b = &amp;#34;NonStaticB&amp;#34;&#xD;}&#xD;// Base64 方法&#xD;fun base64(content: String): String {&#xD;val combined = (a ?</description>
    </item>
    <item>
      <title>使用 AndroidNativeEmu 调用 JNI 函数</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-androidnativeemu-%E8%B0%83%E7%94%A8-jni-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 23 Feb 2025 18:07:48 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-androidnativeemu-%E8%B0%83%E7%94%A8-jni-%E5%87%BD%E6%95%B0/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;AndroidNativeEmu AndroidNativeEmu 专为 Android 原生代码调试和模拟设计，特别关注 JNI 调用和 Android 环境。相比之下，Unicorn 是通用的多平台 CPU 模拟器，适用于更广泛的原生代码分析。&#xA;项目地址：https://github.com/AeonLucid/AndroidNativeEmu&#xA;支持的功能：&#xA;elf 文件解析及 so 加载&#xA;栈支持&#xA;内存管理&#xA;文件系统&#xA;JNI 支持&#xA;常见 syacall 模拟支持&#xA;&amp;hellip;&#xA;但是，暂时不支持 arm64。&#xA;系统调用 AndroidNativeEmu 系统调用的模拟实现都在 cpu/intertupt_handler.py，根据不同的 intno 调用具体的 handler&#xA;目前已经实现的系统调用可以在 syscall_hooks.py 看到&#xA;JNIEnv 对应 JNI 接口的模拟实现在 src/androidemu/java/jni_env.py，通过 write_function_table 方法模拟实现 JNI 函数表&#xA;jni 函数代码是通过 keystone 来生成的，具体代码在：src/androidemu/hooker.py&#xA;so 加载过程中，对 so 中导入符号的 Hook，具体代码在：src/androidemu/native/hooks.py&#xA;AndroidNativeEmu 默认已经实现的外部函数&#xA;native_method 装饰器 native_method 装饰器用于在 AndroidNativeEmu 中将 Python 函数标记为模拟的 JNI 原生方法，允许函数在模拟器中执行并与 Android 的原生方法交互。</description>
    </item>
    <item>
      <title>使用 Unicorn 如何进行栈读写 和 Patch</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-unicorn-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%A0%88%E8%AF%BB%E5%86%99-%E5%92%8C-patch/</link>
      <pubDate>Sun, 23 Feb 2025 17:56:08 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-unicorn-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%A0%88%E8%AF%BB%E5%86%99-%E5%92%8C-patch/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;struct.pack 方法介绍 struct.pack 是 Python 标准库 struct 模块中的一个函数，它用于将 Python 的基本数据类型（如 int、float、long）打包为字节流，以便在二进制文件、网络传输或内存操作（如 Unicorn 仿真器的 mem_write）中使用。&#xA;语法：&#xA;import struct&#xD;struct.pack(format, value) format：指定数据的格式，例如：&#xA;&amp;lt;f：表示小端（&amp;lt;）的 4 字节浮点数（float）&#xA;&amp;lt;d：表示小端的 8 字节双精度浮点数（double）&#xA;value：要转换的 Python 值。&#xA;数据类型格式&#xA;数据类型 有符号格式（小写） 无符号格式（大写） 大小（字节） byte b (char) B (uchar) 1 short h (short) H (ushort) 2 int i (int) I (uint) 4 long q (long long) Q (ulong long) 8 float f (float) 无 4 double d (double) 无 8 其他特殊类型</description>
    </item>
    <item>
      <title>Unicorn Hook 详解：指令、代码块、内存、系统调用等</title>
      <link>https://cyrus-studio.github.io/blog/posts/unicorn-hook-%E8%AF%A6%E8%A7%A3%E6%8C%87%E4%BB%A4%E4%BB%A3%E7%A0%81%E5%9D%97%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AD%89/</link>
      <pubDate>Mon, 10 Feb 2025 00:06:11 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/unicorn-hook-%E8%AF%A6%E8%A7%A3%E6%8C%87%E4%BB%A4%E4%BB%A3%E7%A0%81%E5%9D%97%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%AD%89/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;在 Unicorn 中，Hook（钩子）用于在模拟过程中拦截 CPU 指令执行、内存访问等操作，以便分析和修改执行行为。&#xA;Hook 主要类型 Unicorn 提供了多种 Hook 类型，每种类型用于不同场景：&#xA;Hook 类型 说明 示例 UC_HOOK_CODE 拦截每一条指令执行 监控指令流，反调试 UC_HOOK_BLOCK 拦截每个基本块执行 统计基本块执行次数 UC_HOOK_INTR 拦截中断指令（如 svc #0） 监控系统调用 UC_HOOK_MEM_READ 读取内存前触发 监视变量读取 UC_HOOK_MEM_WRITE 写入内存前触发 监视变量修改 UC_HOOK_MEM_FETCH 取指令前触发 捕获未映射代码执行 UC_HOOK_MEM_READ_UNMAPPED 读取未映射内存 捕获非法内存读取 UC_HOOK_MEM_WRITE_UNMAPPED 写入未映射内存 捕获非法内存写入 UC_HOOK_MEM_FETCH_UNMAPPED 取指未映射内存 捕获非法指令执行 UC_HOOK_INSN 拦截特定指令 监控 syscall、hlt 等 Hook 指令执行 (UC_HOOK_CODE) 用途：&#xA;监控所有执行的指令&#xA;记录寄存器变化&#xA;反调试&#xA;示例代码&#xA;from unicorn import *&#xD;from unicorn.arm64_const import *&#xD;# Hook 回调函数&#xD;def hook_code(mu, address, size, user_data):&#xD;print(f&amp;#34;Executing instruction at 0x{address:X}, size={size}&amp;#34;)&#xD;# 初始化 Unicorn ARM64&#xD;mu = Uc(UC_ARCH_ARM64, UC_MODE_ARM)&#xD;# 分配内存&#xD;BASE = 0x1000&#xD;mu.</description>
    </item>
    <item>
      <title>使用 Unicorn 调用 android so 中的 JNI 方法</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-unicorn-%E8%B0%83%E7%94%A8-android-so-%E4%B8%AD%E7%9A%84-jni-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 10 Feb 2025 00:06:11 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-unicorn-%E8%B0%83%E7%94%A8-android-so-%E4%B8%AD%E7%9A%84-jni-%E6%96%B9%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Android 示例代码 编写一个 jni 方法 add 进行简单的加法运算 ，代码如下：&#xA;#include &amp;lt;jni.h&amp;gt;&#xD;// 实现加法运算&#xD;extern &amp;#34;C&amp;#34;&#xD;JNIEXPORT jint JNICALL&#xD;Java_com_cyrus_example_unicorn_UnicornActivity_add(JNIEnv *env, jobject thiz, jint a, jint b) {&#xD;return a + b;&#xD;} 配置 CMakeLists.txt&#xA;add_library( # 设置库的名称&#xD;unicorn&#xD;# 设置库的类型&#xD;SHARED&#xD;# 设置源文件路径&#xD;unicorn.cpp)&#xD;target_link_libraries( # 将 log 库链接到目标库&#xD;unicorn&#xD;${log-lib}) 完整源码地址：https://github.com/CYRUS-STUDIO/AndroidExample&#xA;编译运行 Android 项目后在 build 目录找打 apk 并解压 libunicorn.so。&#xA;加载 so 并反汇编 通过 IDA 打开 so 文件可以看到 add 方法的开始地址为 0x0608，结束地址为 0x063C</description>
    </item>
    <item>
      <title>Frida 实现 JNI 方法地址跟踪、反汇编、Patch</title>
      <link>https://cyrus-studio.github.io/blog/posts/frida-%E5%AE%9E%E7%8E%B0-jni-%E6%96%B9%E6%B3%95%E5%9C%B0%E5%9D%80%E8%B7%9F%E8%B8%AA%E5%8F%8D%E6%B1%87%E7%BC%96patch/</link>
      <pubDate>Sun, 09 Feb 2025 02:00:32 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/frida-%E5%AE%9E%E7%8E%B0-jni-%E6%96%B9%E6%B3%95%E5%9C%B0%E5%9D%80%E8%B7%9F%E8%B8%AA%E5%8F%8D%E6%B1%87%E7%BC%96patch/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Frida 反汇编 Frida 提供了反汇编 API，主要用于对目标进程的代码进行动态分析，例如：&#xA;获取函数的机器代码并将其反汇编为汇编指令。&#xA;分析内存中的指令流。&#xA;这些功能在 Frida 的 Instruction 类中实现，基于 Capstone 实现的反汇编功能。&#xA;https://frida.re/docs/javascript-api/#instruction&#xA;比如，可以通过 Instruction.parse 方法反汇编指定地址的汇编信息&#xA;[Remote::AndroidExample]-&amp;gt; Instruction.parse(ptr(&amp;#34;0x7e7acdb9a0&amp;#34;));&#xD;{&#xD;&amp;#34;address&amp;#34;: &amp;#34;0x7e7acdb9a0&amp;#34;,&#xD;&amp;#34;groups&amp;#34;: [],&#xD;&amp;#34;mnemonic&amp;#34;: &amp;#34;sub&amp;#34;,&#xD;&amp;#34;next&amp;#34;: &amp;#34;0x7e7acdb9a4&amp;#34;,&#xD;&amp;#34;opStr&amp;#34;: &amp;#34;sp, sp, #0x10&amp;#34;,&#xD;&amp;#34;operands&amp;#34;: [&#xD;{&#xD;&amp;#34;type&amp;#34;: &amp;#34;reg&amp;#34;,&#xD;&amp;#34;value&amp;#34;: &amp;#34;sp&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;type&amp;#34;: &amp;#34;reg&amp;#34;,&#xD;&amp;#34;value&amp;#34;: &amp;#34;sp&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;type&amp;#34;: &amp;#34;imm&amp;#34;,&#xD;&amp;#34;value&amp;#34;: &amp;#34;16&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;regsRead&amp;#34;: [],&#xD;&amp;#34;regsWritten&amp;#34;: [],&#xD;&amp;#34;size&amp;#34;: 4&#xD;} Android 示例代码 定义一个 native 函数 add，计算 1+ 1 + 1 并返回结果。</description>
    </item>
    <item>
      <title>Capstone、Unicorn 与 Keystone</title>
      <link>https://cyrus-studio.github.io/blog/posts/capstoneunicorn-%E4%B8%8E-keystone/</link>
      <pubDate>Sun, 09 Feb 2025 01:39:39 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/capstoneunicorn-%E4%B8%8E-keystone/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Capstone 简介 Capstone 是一个强大的多平台开源反汇编框架，用于将机器码翻译为汇编代码。&#xA;官网：https://www.capstone-engine.org/&#xA;源码地址：https://github.com/capstone-engine/capstone&#xA;文档：https://www.capstone-engine.org/documentation.html&#xA;相关应用：&#xA;Radare2 内部使用 Capstone 作为其反汇编引擎之一。&#xA;Frida 的底层核心使用 Capstone 作为反汇编引擎，用于分析运行时的指令流、解码和显示二进制代码（例如，用户可以通过 Frida 的 API 获取内存中的指令数据，并使用 Capstone 对其进行解码和分析。）&#xA;使用 Capstone 反汇编 .so 文件中的机器码 要反汇编 .so 文件，首先需要提取其中的代码段内容（通常为 .text 段），然后利用 Capstone 进行反汇编。&#xA;1. 安装 capstone pip install capstone 2. 提取 .so 文件中的代码段 使用 readelf 工具获取 .text 段的偏移和大小（ -A 1：表示匹配行后再输出 1 行）：&#xA;readelf -S libvmp-lib.so | grep -A 1 .text&#xD;[14] .text PROGBITS 000000000009d480 0009d480&#xD;00000000000af0f8 0000000000000000 AX 0 0 16 关键信息：</description>
    </item>
    <item>
      <title>使用 Miniconda 管理 Python 环境</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-miniconda-%E7%AE%A1%E7%90%86-python-%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sat, 25 Jan 2025 02:17:46 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-miniconda-%E7%AE%A1%E7%90%86-python-%E7%8E%AF%E5%A2%83/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Miniconda Miniconda 是 Conda 的简化版本，只包含 Conda 包管理器和 Python 的最小安装包，提供了一种轻量级的环境管理和包管理工具。相比于 Anaconda，Miniconda 更小巧灵活，适合那些不需要 Anaconda 提供的完整生态的用户。&#xA;通过 Miniconda，开发者可以更高效地管理和定制自己的开发环境，避免不必要的依赖和资源浪费。&#xA;下载安装 Miniconda：https://docs.anaconda.com/miniconda/&#xA;把 Miniconda3 和 Miniconda3\Scripts 路径添加到 Path 系统环境变量&#xA;完成安装后，打开终端或命令提示符，输入&#xA;conda --version&#xD;python --version 如果显示版本号，说明安装成功。&#xA;创建环境 创建一个新的虚拟环境，指定特定版本的 Python&#xA;conda create -n anti-app python=3.12.6 列出当前可用的 Python 版本&#xA;conda search python 克隆环境 现有环境复制到新的环境&#xA;conda create --name new_env --clone old_env 删除环境 conda remove --name old_env --all 列出所有环境 conda env list 激活环境 conda activate env_name 停用当前环境 conda deactivate 导出当前环境 conda env export &amp;gt; environment.</description>
    </item>
    <item>
      <title>Android Dex VMP 动态加载加密指令流 </title>
      <link>https://cyrus-studio.github.io/blog/posts/android-dex-vmp-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%8A%A0%E5%AF%86%E6%8C%87%E4%BB%A4%E6%B5%81-/</link>
      <pubDate>Mon, 13 Jan 2025 21:33:28 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-dex-vmp-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%8A%A0%E5%AF%86%E6%8C%87%E4%BB%A4%E6%B5%81-/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;上一篇【详解如何自定义 Android Dex VMP 保护壳】实现了 VMP 保护壳。&#xA;为了进一步加强对 dex 指令的保护，实现指令流加密和动态加载，比如使用 AES 加密指令流，在运行时解密执行。&#xA;保存指令流到文件 在 010Editor 中搜索找到 sign 方法的字节码并复制&#xA;新建 Hex 文件&#xA;把 sign 方法字节码粘贴到新建的文件保存文件为 sign&#xA;AES加解密 编写一个 kotlin 语言 AES 加解密算法工具类&#xA;package com.cyrus.vmp&#xD;import java.io.ByteArrayOutputStream&#xD;import java.io.File&#xD;import java.io.FileInputStream&#xD;import java.io.FileOutputStream&#xD;import javax.crypto.Cipher&#xD;import javax.crypto.KeyGenerator&#xD;import javax.crypto.SecretKey&#xD;import javax.crypto.spec.SecretKeySpec&#xD;object AESUtils {&#xD;private const val ALGORITHM = &amp;#34;AES&amp;#34;&#xD;private const val TRANSFORMATION = &amp;#34;AES/ECB/PKCS5Padding&amp;#34; // AES 加密模式&#xD;// 生成一个 128 位的 AES 密钥&#xD;fun generateSecretKey(): SecretKey {&#xD;val keyGenerator = KeyGenerator.</description>
    </item>
    <item>
      <title>详解如何自定义 Android Dex VMP 保护壳</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E8%AF%A6%E8%A7%A3%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89-android-dex-vmp-%E4%BF%9D%E6%8A%A4%E5%A3%B3/</link>
      <pubDate>Mon, 13 Jan 2025 21:14:45 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E8%AF%A6%E8%A7%A3%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89-android-dex-vmp-%E4%BF%9D%E6%8A%A4%E5%A3%B3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 Android Dex VMP（Virtual Machine Protection，虚拟机保护）壳是一种常见的应用保护技术，主要用于保护 Android 应用的代码免受反编译和逆向工程的攻击。&#xA;VMP 保护壳通过将应用的原始 Dex（Dalvik Executable）文件进行加密、混淆、虚拟化等处理，使得恶意用户无法轻易获取到应用的原始代码和逻辑。&#xA;比如，实现一个 Android 下的 Dex VMP 保护壳，用来保护 Kotlin 层 sign 算法，防止被逆向。&#xA;假设 sign 算法源码如下：&#xA;package com.cyrus.example.vmp&#xD;import java.security.MessageDigest&#xD;import java.util.Base64&#xD;object SignUtil {&#xD;/**&#xD;* 对输入字符串进行签名并返回 Base64 编码后的字符串&#xD;* @param input 要签名的字符串&#xD;* @return Base64 编码后的字符串&#xD;*/&#xD;fun sign(input: String): String {&#xD;// 使用 SHA-256 计算摘要&#xD;val digest = MessageDigest.getInstance(&amp;#34;SHA-256&amp;#34;)&#xD;val hash = digest.digest(input.toByteArray())&#xD;// 使用 Base64 编码&#xD;return Base64.</description>
    </item>
    <item>
      <title>移植 OLLVM 到 Android NDK，Android Studio 中使用 OLLVM</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%A7%BB%E6%A4%8D-ollvm-%E5%88%B0-android-ndkandroid-studio-%E4%B8%AD%E4%BD%BF%E7%94%A8-ollvm/</link>
      <pubDate>Tue, 24 Dec 2024 00:01:16 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%A7%BB%E6%A4%8D-ollvm-%E5%88%B0-android-ndkandroid-studio-%E4%B8%AD%E4%BD%BF%E7%94%A8-ollvm/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;OLLVM、LLVM 与 Android NDK 在 Android NDK 中，LLVM/Clang 是默认的编译器。自 Android NDK r18 开始，Google 弃用了 GCC，全面转向使用 LLVM/Clang 作为 NDK 的编译工具链。&#xA;NDK 中 LLVM 所在路径：/toolchains/llvm/prebuilt//bin/&#xA;查看 clang 版本，这里版本是 18.0.2&#xA;(base) PS D:\App\android\sdk\ndk\27.1.12297006\toolchains\llvm\prebuilt\windows-x86_64\bin&amp;gt; ./clang --version&#xD;Android (12285214, based on r522817b) clang version 18.0.2 (https://android.googlesource.com/toolchain/llvm-project d8003a456d14a3deb8054cdaa529ffbf02d9b262)&#xD;Target: x86_64-w64-windows-gnu&#xD;Thread model: posix&#xD;InstalledDir: D:/App/android/sdk/ndk/27.1.12297006/toolchains/llvm/prebuilt/windows-x86_64/bin 下载和编译与 NDK 中版本相近的 LLVM，具体可以参考这篇文章【编译 LLVM 源码，使用 Clion 调试 clang】&#xA;OLLVM 是 LLVM 的一个分支，增加了代码混淆功能（如控制流平坦化、指令替换），主要用于保护二进制代码的安全性。&#xA;关于如何移植 OLLVM 到 LLVM 可以参考下面的文章：&#xA;移植 OLLVM 到 LLVM 18，C&amp;amp;C++代码混淆</description>
    </item>
    <item>
      <title>移植 OLLVM 到 LLVM 18，C&amp;C&#43;&#43;代码混淆</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%A7%BB%E6%A4%8D-ollvm-%E5%88%B0-llvm-18cc&#43;&#43;%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</link>
      <pubDate>Mon, 23 Dec 2024 03:48:18 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%A7%BB%E6%A4%8D-ollvm-%E5%88%B0-llvm-18cc&#43;&#43;%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;OLLVM 简介 OLLVM (Obfuscator-LLVM) 是一个基于 LLVM 的代码混淆工具。&#xA;LLVM 是一个广泛使用的编译器框架，OLLVM 在其基础上提供了多种混淆技术，旨在增加程序逆向分析和反编译的难度，从而提高程序的安全性。&#xA;OLLVM 通过在编译过程中对中间表示（IR）和目标代码应用多种混淆技术，生成更加复杂和难以理解的二进制代码。&#xA;OLLVM 项目地址：https://github.com/obfuscator-llvm/obfuscator&#xA;下载源码 目前最新版本的是分支名为 llvm-4.0，基于 LLVM 团队发布的版本 4.0.1&#xA;最新版本的 LLVM 可以看这里：https://github.com/llvm/llvm-project/releases&#xA;下载 OLLVM 的 llvm-4.0 分支源码到本地&#xA;git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git 构建 OLLVM&#xA;mkdir build&#xD;cd build&#xD;cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/&#xD;make -j7 OLLVM 项目介绍 obfuscator/&#xD;│&#xD;├── include/llvm/Transforms/Obfuscation # 公共头文件目录&#xD;│ ├── BogusControlFlow.h # 虚假控制流头文件&#xD;│ ├── Flattening.h # 控制流平坦化头文件&#xD;│ ├── Split.h # 基本块拆分头文件&#xD;│ ├── Substitution.</description>
    </item>
    <item>
      <title>移植 OLLVM 到 LLVM18，修复控制流平坦化报错</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%A7%BB%E6%A4%8D-ollvm-%E5%88%B0-llvm18%E4%BF%AE%E5%A4%8D%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96%E6%8A%A5%E9%94%99/</link>
      <pubDate>Sat, 21 Dec 2024 23:02:07 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%A7%BB%E6%A4%8D-ollvm-%E5%88%B0-llvm18%E4%BF%AE%E5%A4%8D%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96%E6%8A%A5%E9%94%99/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 把 OLLVM 移植到 LLVM18 后，发现 -fla（控制流平坦化）并不能正常使用。&#xA;关于移植过程可以参考这篇文章 【移植 OLLVM 到 LLVM 18，C&amp;amp;C++代码混淆】&#xA;测试代码 fla.c&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xD;int main(int argc, char** argv) {&#xD;int a = atoi(argv[1]);&#xD;if(a == 0)&#xD;return 1;&#xD;else&#xD;return 10;&#xD;return 0;&#xD;} 使用 clang 编译并启用 Control Flow Flattening（控制流平坦化）报错如下：&#xA;D:\Projects\llvm-project\build&amp;gt;clang -mllvm -fla fla.c -o fla.exe&#xD;[OLLVM] run.PipelineStartEPCallback&#xD;PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.</description>
    </item>
    <item>
      <title>编译 LLVM 源码，使用 Clion 调试 clang</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%BC%96%E8%AF%91-llvm-%E6%BA%90%E7%A0%81%E4%BD%BF%E7%94%A8-clion-%E8%B0%83%E8%AF%95-clang/</link>
      <pubDate>Tue, 10 Dec 2024 22:44:36 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%BC%96%E8%AF%91-llvm-%E6%BA%90%E7%A0%81%E4%BD%BF%E7%94%A8-clion-%E8%B0%83%E8%AF%95-clang/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;1. LLVM 简介 LLVM 是一个开源的编译器基础架构，最初由 Chris Lattner 于 2000 年在伊利诺伊大学开发，后来成为一个广泛应用于编译器和程序分析的项目。&#xA;LLVM 的核心组件：&#xA;LLVM Core Libraries：提供用于编译器开发的核心工具集，包括代码生成、优化、目标机器描述等。&#xA;Clang：一个基于 LLVM 的 C、C++、Objective-C 编译器前端。&#xA;LLVM IR（Intermediate Representation）：一种类似汇编的中间表示语言，是 LLVM 的核心抽象。代码在编译过程中先被转换为 LLVM IR，随后进行各种优化，再生成目标机器码。&#xA;LLVM Optimizer：对 LLVM IR 进行各种优化，如循环优化、内联展开等，以提升性能。&#xA;LLVM Code Generator：将优化后的 LLVM IR 转换为特定平台的机器码。&#xA;Linker：LLVM 也包含了一些链接器工具（如 LLD），用于将编译好的目标文件链接成可执行文件或库。&#xA;LLVM 的优势：&#xA;模块化设计：可用于多种语言的编译器开发（如 Rust、Swift）。&#xA;跨平台支持：支持多种处理器架构（如 x86、ARM、RISC-V）。&#xA;高度优化：提供丰富的优化技术，帮助生成更高效的机器码。&#xA;动态编译支持：适用于 JIT（即时编译），如 WebAssembly 和 Swift 的 REPL 环境。&#xA;LLVM 官网：https://llvm.org/&#xA;Getting Started with LLVM Core Libraries（中文版）&#xA;2. 下载 LLVM 在 Android NDK 中，LLVM/Clang 是默认的编译器。自 Android NDK r18 开始，Google 弃用了 GCC，全面转向使用 LLVM/Clang 作为 NDK 的编译工具链。</description>
    </item>
    <item>
      <title>使用 opt 优化 LLVM IR，定制 clang 实现函数名加密</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-opt-%E4%BC%98%E5%8C%96-llvm-ir%E5%AE%9A%E5%88%B6-clang-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%90%8D%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Thu, 28 Nov 2024 00:55:08 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-opt-%E4%BC%98%E5%8C%96-llvm-ir%E5%AE%9A%E5%88%B6-clang-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%90%8D%E5%8A%A0%E5%AF%86/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;1. LLVM IR LLVM IR（Intermediate Representation） 是 LLVM 编译框架中的一种中间表示形式，它是一种面向低级的中间代码，是 LLVM 架构的核心部分。LLVM IR 既可以用作 LLVM 编译器的输入，也可以用作输出，供其他编译器或工具链使用。&#xA;LLVM IR 的两种存储形式：&#xA;LLVM IR 语言（文本形式，扩展名 .ll）：可读的 LLVM IR 代码。&#xA;LLVM 位码（Bitcode，扩展名 .bc）：二进制形式的 LLVM IR，主要用于高效存储和传输。&#xA;LLVM IR 是平台无关的，可以跨不同的硬件架构进行移植。&#xA;LLVM IR 语言参考手册：https://llvm.org/docs/LangRef.html&#xA;1.1 将 C 文件转换为 LLVM IR 生成文本形式的 LLVM IR（.ll 文件）&#xA;clang -S -emit-llvm hello.c -o hello.ll 以 hello.ll 为例，生成的内容大概如下&#xA;; Function Attrs: noinline nounwind optnone uwtable&#xD;; 这行注释了函数的属性&#xD;; - noinline: 该函数不会被内联（inline）。&#xD;; - nounwind: 该函数不会引发异常（不会 unwind stack）。&#xD;; - optnone: 编译器不会对此函数进行任何优化。&#xD;; - uwtable: 该函数有一个可用的异常处理表（unwind table）。&#xD;define dso_local i32 @main() #0 {&#xD;; define: 定义一个函数。&#xD;; dso_local: 该函数在本地动态库中可见（仅限于当前编译单元）。&#xD;; i32: 返回类型为 32 位整数。&#xD;; @main: 函数名为 &amp;#39;main&amp;#39;。&#xD;; #0: 函数使用属性组 0 中定义的属性（即上面注释的那一行）。&#xD;entry:&#xD;; entry: 函数的入口基本块（Basic Block）的标签。&#xD;%retval = alloca i32, align 4&#xD;; alloca: 在栈上分配内存。这里分配了一个 32 位整数（i32）。&#xD;; align 4: 分配的内存对齐到 4 字节边界。&#xD;; %retval: 变量的名称（SSA 变量），用于存储 main 函数的返回值。&#xD;store i32 0, ptr %retval, align 4&#xD;; store: 将一个值存储到内存地址中。&#xD;; i32 0: 要存储的值是 32 位整数 0（即 main 函数的返回值）。&#xD;; ptr %retval: 存储的位置是之前分配的栈变量 %retval。&#xD;; align 4: 存储操作按 4 字节对齐。&#xD;%call = call i32 (ptr, .</description>
    </item>
    <item>
      <title>Android下的系统调用 (syscall)，内联汇编syscall</title>
      <link>https://cyrus-studio.github.io/blog/posts/android%E4%B8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96syscall/</link>
      <pubDate>Sun, 10 Nov 2024 06:30:32 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android%E4%B8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96syscall/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;什么是系统调用 (syscall) 系统调用是操作系统提供给应用程序的一组接口，允许用户空间程序与内核进行交互。&#xA;在 Android（基于 Linux 内核）中，系统调用由 软中断 实现，通常通过 svc 指令（在 ARM 架构中）触发。系统调用会将 CPU 从用户模式切换到内核模式，使得程序可以执行更高权限的操作。&#xA;Android 使用的 C 库是 Bionic，它是为移动设备优化的轻量级 C 库。对应的模块为 libc.so。&#xA;Bionic 提供了对系统调用的封装。大多数标准库函数（如 printf、malloc、pthread_create）都通过 Bionic 实现，底层调用了相应的系统调用。&#xA;在 NDK 目录中可以找到相关的系统调用号定义头文件。例如&#xA;&amp;lt;NDK_PATH&amp;gt;\27.1.12297006\toolchains\llvm\prebuilt\windows-x86_64\sysroot\usr\include\asm-generic\unistd.h 搜索 bionic 模块 可以找到不同CPU架构下的 syscall 实现 在 http://androidxref.com/9.0.0_r3/xref/bionic/libc/arch-arm/syscalls/ 可以找到 Android 中所有系统调用的汇编代码文件 syscall 在 Android 上的应用场景 系统工具和调试：如 strace、lsof 等工具，通过 syscall 获取系统状态。&#xA;安全与反调试：某些安全检测和反调试技术会直接使用 syscall 绕过标准的 libc 函数，以防止被 hook。&#xA;嵌入式开发：在一些嵌入式系统中，开发者需要直接控制硬件，这时通常会使用 syscall。&#xA;如何在 Android 中使用 syscall 假设我们希望通过 syscall 直接读取文件内容，编写 native 方法代码如下</description>
    </item>
    <item>
      <title>Android 下内联汇编，Android Studio 汇编开发</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-%E4%B8%8B%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96android-studio-%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91/</link>
      <pubDate>Sat, 09 Nov 2024 04:23:34 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-%E4%B8%8B%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96android-studio-%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;内联汇编 Android 内联汇编非常适用于 ARM 架构的性能优化和底层操作，通常用于加密、解密、特定指令优化等领域。&#xA;1. 基础语法 内联汇编在 C/C++ 代码中通过 asm 或 asm 关键字进行声明，格式如下&#xA;asm (&amp;#34;汇编指令&amp;#34; : 输出操作数 : 输入操作数 : 破坏描述符); 详细说明：&#xA;汇编指令：这是我们想要执行的汇编代码，通常是 ARM 或 ARM64 指令。&#xA;输出操作数：指定汇编代码的输出结果如何映射到 C++ 变量。&#xA;输入操作数：指定传递给汇编代码的输入。&#xA;破坏描述符：用于告诉编译器哪些寄存器或内存位置将被汇编代码修改，以避免编译器优化引起的问题。&#xA;2. 占位符 占位符用于在汇编指令中插入 C++ 变量，格式为 %0、%1 等，对应输出和输入操作数的顺序。&#xA;例如&#xA;int x = 10, y = 20, result;&#xD;asm(&amp;#34;add %0, %1, %2&amp;#34; : &amp;#34;=r&amp;#34;(result) : &amp;#34;r&amp;#34;(x), &amp;#34;r&amp;#34;(y)); 上面的代码将 x 和 y 相加并将结果存入 result。&#xA;3. 输出操作数和输入操作数 =r 表示输出操作数是一个通用寄存器类型。</description>
    </item>
    <item>
      <title>详解ARM汇编条件标志</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E8%AF%A6%E8%A7%A3arm%E6%B1%87%E7%BC%96%E6%9D%A1%E4%BB%B6%E6%A0%87%E5%BF%97/</link>
      <pubDate>Tue, 05 Nov 2024 21:06:33 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E8%AF%A6%E8%A7%A3arm%E6%B1%87%E7%BC%96%E6%9D%A1%E4%BB%B6%E6%A0%87%E5%BF%97/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;条件标志 在 ARM 指令集中，条件标志是控制指令执行的一种机制，它们用于实现条件分支、比较和其他逻辑操作。&#xA;我们平时使用 IDA 调试程序时，在 general registers 窗口中看到的条件标志 ARM 处理器通常使用四个主要的条件标志，它们的状态影响指令的执行。这些条件标志包括：&#xA;1. N (Negative): 负标志，用于指示最后一次操作的结果是否为负值。若结果为负，则 N 被置为 1；否则为 0。&#xA;2. Z (Zero): 零标志，用于指示最后一次操作的结果是否为零。如果结果为零，则 Z 被置为 1；否则为 0。&#xA;3. C (Carry): 进位标志，用于指示加法操作是否产生了进位或减法操作是否没有借位。对于加法，若产生进位，则 C 被置为 1；对于减法，若没有借位，则 C 被置为 1。&#xA;4. V (Overflow): 溢出标志，用于指示最后一次算术操作是否发生了溢出。当两个有符号数相加或相减时，如果结果的符号与操作数的符号不一致，表示发生了溢出，V 被置为 1。&#xA;在 ARM 指令中，条件执行可以通过附加条件码实现，例如：&#xA;EQ (Equal): 当 Z = 1 时执行（相等）。&#xA;NE (Not Equal): 当 Z = 0 时执行（不相等）。&#xA;GT (Greater Than): 当 Z = 0 且 N = V 时执行（大于）。</description>
    </item>
    <item>
      <title>ARM64汇编寻址、汇编指令、指令编码方式</title>
      <link>https://cyrus-studio.github.io/blog/posts/arm64%E6%B1%87%E7%BC%96%E5%AF%BB%E5%9D%80%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 05 Nov 2024 12:42:37 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/arm64%E6%B1%87%E7%BC%96%E5%AF%BB%E5%9D%80%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;ARM64汇编寻址 1. 立即数寻址（Immediate Addressing） 这种方式直接将立即数作为操作数，适合小数据或常量。ARM64的立即数在指令中直接编码。&#xA;MOV X0, #10 ; 将常数10加载到寄存器X0中 2. 寄存器间接寻址（Register Indirect Addressing） 使用寄存器中的地址作为内存地址。适合基于寄存器值进行偏移的简单访问方式。&#xA;LDR X1, [X0] ; 将地址X0指向的内存内容加载到X1中 3. 偏移寻址（Offset Addressing） 在基地址寄存器的基础上添加一个偏移量来确定目标地址，偏移量可以是立即数或寄存器值。&#xA;LDR X1, [X0, #8] ; 从地址X0 + 8的位置加载数据到X1中 4. 预索引寻址（Pre-indexed Addressing） 使用基地址加上偏移量来访问内存，访问完成后，将偏移量更新到基地址寄存器中。&#xA;LDR X1, [X0, #8]! ; 从地址X0 + 8加载数据到X1中，同时更新X0为X0 + 8 5. 后索引寻址（Post-indexed Addressing） 先使用基地址来访问内存，再将偏移量加到基地址寄存器中。这样偏移的效果在读取数据后才生效。&#xA;LDR X1, [X0], #8 ; 先从X0指向的地址加载数据到X1中，随后X0增加8 6. 寄存器偏移寻址（Register Offset Addressing） 偏移量用另一个寄存器指定，便于灵活的偏移操作，特别适合对数据结构的访问。&#xA;LDR X1, [X0, X2] ; 从X0 + X2指向的内存地址加载数据到X1中 7.</description>
    </item>
    <item>
      <title>Thumb 汇编指令集，Thumb 指令编码方式，编译 Thumb 汇编代码</title>
      <link>https://cyrus-studio.github.io/blog/posts/thumb-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E9%9B%86thumb-%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E7%BC%96%E8%AF%91-thumb-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 04 Nov 2024 19:17:49 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/thumb-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E9%9B%86thumb-%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E7%BC%96%E8%AF%91-thumb-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Thumb指令集 ARM 指令集：最早在 1985 年随第一代 ARM 处理器问世。ARM 指令集一开始是 32 位固定长度的指令，用于各种计算任务。&#xA;Thumb 指令集：在 1994 年的 ARM7TDMI 处理器中首次引入。这是在 ARM 指令集基础上开发的一个 16 位指令集，旨在优化嵌入式系统中代码密度和内存效率。&#xA;寄存器 Thumb 跟 ARM 是一样的。&#xA;随着 ARM 架构的演进，后来加入了 32 位的 Thumb 指令，称为 Thumb-2 指令集。&#xA;以简单的加载立即数到寄存器为例，解释一下 16 位和 32 位的 Thumb 指令的区别&#xA;16 位 Thumb 指令&#xA;MOVS R0, #1 // 将立即数 1 加载到 R0，指令长度为 16 位 32 位 Thumb 指令&#xA;MOV.W R0, #65535 // 将较大的立即数 65535 加载到 R0，指令长度为 32 位 由于 16 位 Thumb 指令长度有限，无法直接处理大立即数，而 32 位 Thumb 指令支持更大的立即数范围。32 位指令格式可以容纳更多位的立即数、更复杂的操作码。</description>
    </item>
    <item>
      <title>adb 远程调试，手动修改 adb 调试授权信息</title>
      <link>https://cyrus-studio.github.io/blog/posts/adb-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%89%8B%E5%8A%A8%E4%BF%AE%E6%94%B9-adb-%E8%B0%83%E8%AF%95%E6%8E%88%E6%9D%83%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Sun, 03 Nov 2024 04:49:00 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/adb-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%89%8B%E5%8A%A8%E4%BF%AE%E6%94%B9-adb-%E8%B0%83%E8%AF%95%E6%8E%88%E6%9D%83%E4%BF%A1%E6%81%AF/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;adb 远程调试 手机上开发者选项中打开网络调试 或者连接 USB 执行下面命令将 ADB 设置为通过端口 5555 进行 TCP/IP 调试 adb tcpip 5555 启用 TCP/IP 模式后可以断开 USB 连接&#xA;如果网络调试开关中没有显示设备ip地址，通过下面方法获取设备的 IP 地址：&#xA;在设备上，进入设置 &amp;gt; 网络与互联网 &amp;gt; Wi-Fi，选择当前连接的网络。&#xA;找到设备的 IP 地址（通常在网络详情中）。&#xA;根据设备 ip 地址和端口号连接到设备，并在手机上确认授权调试提示&#xA;adb connect 192.168.0.101:5555&#xD;already connected to 192.168.0.101:5555 第一次授权可能会提示 unauthorized&#xA;adb devices&#xD;List of devices attached&#xD;192.168.0.101:5555 unauthorized 重启 adb，重新再连接&#xA;adb kill-server&#xD;adb connect 192.168.0.101:5555&#xD;* daemon not running; starting now at tcp:5037&#xD;* daemon started successfully&#xD;connected to 192.</description>
    </item>
    <item>
      <title>详解ARM64可执行程序的生成过程</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E8%AF%A6%E8%A7%A3arm64%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sat, 02 Nov 2024 23:01:02 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E8%AF%A6%E8%A7%A3arm64%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;ARM64可执行程序的生成过程 根据 ARM64 可执行程序生成的四个主要步骤：预处理、编译、汇编、链接，我们可以详细分解整个过程如下&#xA;1. 预处理（Preprocessing） 预处理是源代码文件在正式编译前的准备工作，由预处理器完成。其主要任务包括：&#xA;宏替换：处理 #define 定义的宏，将代码中出现的宏替换为实际值。&#xA;文件包含：处理 #include 指令，将所需的头文件内容直接插入代码中，确保所有引用的函数和变量声明都在同一文件中。&#xA;条件编译：处理 #ifdef、#ifndef 等条件编译指令，以控制代码中不同部分的编译。&#xA;预处理后的输出仍然是代码文件，但没有任何宏、条件编译等指令，通常以 .i 或 .ii 作为扩展名。&#xA;2. 编译（Compilation） 编译器（如 GCC 或 Clang）将预处理后的代码文件转换为汇编代码，产生汇编语言表示的文件。此阶段包括以下子步骤：&#xA;词法分析：将源代码转化为基本的语法单元（token），如变量名、运算符、关键字等。&#xA;语法分析：将代码组织成抽象语法树（AST），根据编程语言的语法规则生成层次结构。&#xA;语义分析：检查语法树的正确性，如类型检查、作用域检查等，确保代码符合语言语义。&#xA;中间代码生成：编译器生成与平台无关的中间代码，方便后续优化。&#xA;优化：编译器对中间代码进行优化，如消除冗余代码、进行循环优化等，以提升程序效率。&#xA;生成汇编代码：编译器将优化后的中间代码转换为特定平台（如 ARM64）的汇编代码，通常输出 .s 文件。&#xA;编译阶段的最终输出是汇编代码文件，包含了基于 ARM64 指令集的指令。&#xA;3. 汇编（Assemble） 汇编器（如 GNU Assembler，as）将汇编代码文件（.s 文件）转换为机器代码，生成二进制的目标文件（.o 文件）。目标文件包含了二进制的机器指令，但符号引用还未解析，因此目标文件本身并非独立的可执行文件。&#xA;汇编阶段的主要工作包括：&#xA;指令翻译：将汇编语言指令转换为 ARM64 指令集对应的二进制机器指令。&#xA;符号表生成：记录所有函数和变量的符号地址，以便链接阶段使用。&#xA;机器码生成：生成目标文件（.o），将每条指令翻译成可执行的机器码。&#xA;目标文件是 ARM64 可执行程序生成过程中不可或缺的中间文件。&#xA;4. 链接（Linking） 链接器（如 GNU Linker，ld）将一个或多个目标文件链接在一起，并解决外部依赖，生成最终的可执行文件。链接的过程分为静态链接和动态链接两种：&#xA;静态链接：将程序所需的库代码直接嵌入到可执行文件中，生成一个完全自包含的文件。&#xA;动态链接：生成的可执行文件依赖外部共享库（如 .so 文件），在程序运行时加载这些共享库。&#xA;链接阶段的关键步骤包括：&#xA;符号解析：将不同目标文件中的符号（如函数和变量）解析为对应的内存地址，解决跨文件调用。&#xA;重定位：调整目标文件中指令和数据的地址，使得所有模块可以在一个统一的地址空间中正常运行。&#xA;生成可执行文件：链接器根据 ELF（Executable and Linkable Format）等格式生成最终的可执行文件，包含程序代码段、数据段、以及其他加载器所需的元信息。</description>
    </item>
    <item>
      <title>Windows下创建FTP服务器，实现文件共享</title>
      <link>https://cyrus-studio.github.io/blog/posts/windows%E4%B8%8B%E5%88%9B%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</link>
      <pubDate>Mon, 28 Oct 2024 22:21:39 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/windows%E4%B8%8B%E5%88%9B%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;创建FTP服务器 使用 Windows+R 打开的【运行】窗口中直接执行 optionalfeatures 打开 Windows 功能对话框。或者直接搜索【启用或关闭 Windows 功能】。 在【启用和关闭 Windows 功能】中选中【FTP服务】【IIS管理控制台】 应用更改完成后，重启电脑。&#xA;执行 ipconfig 命令查看当前电脑的ip，比如这里ip地址为 192.168.0.112&#xA;无线局域网适配器 WLAN:&#xD;连接特定的 DNS 后缀 . . . . . . . :&#xD;本地链接 IPv6 地址. . . . . . . . : fe80::74b9:ae56:5d90:79ff%6&#xD;IPv4 地址 . . . . . . . . . . . . : 192.168.0.112&#xD;子网掩码 . . . . . . . . .</description>
    </item>
    <item>
      <title>编译自定义Linux内核，使WSL支持访问Windows下USB设备</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%BC%96%E8%AF%91%E8%87%AA%E5%AE%9A%E4%B9%89linux%E5%86%85%E6%A0%B8%E4%BD%BFwsl%E6%94%AF%E6%8C%81%E8%AE%BF%E9%97%AEwindows%E4%B8%8Busb%E8%AE%BE%E5%A4%87/</link>
      <pubDate>Mon, 28 Oct 2024 15:07:37 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%BC%96%E8%AF%91%E8%87%AA%E5%AE%9A%E4%B9%89linux%E5%86%85%E6%A0%B8%E4%BD%BFwsl%E6%94%AF%E6%8C%81%E8%AE%BF%E9%97%AEwindows%E4%B8%8Busb%E8%AE%BE%E5%A4%87/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;WSL 本身并不支持连接 USB 设备，因此你需要安装开源 usbipd-win 项目。&#xA;usbip 可以让你在网络上共享和使用 USB 设备。它由两个主要组件组成：&#xA;usbipd (USB/IP daemon)：服务端，负责共享连接到主机的 USB 设备。&#xA;usbip (USB/IP client)：客户端，允许其他计算机访问共享的 USB 设备。&#xA;1. 安装USBIPD-WIN USBIPD-WIN 是一个在 Windows 上实现 USB/IP 协议的工具。首先，你需要在 Windows 上安装这个工具。&#xA;下载并安装 usbipd-win，可以从GitHub页面获取最新版本的安装包。&#xA;或者执行下面命令安装&#xA;winget install usbipd 2. 列出所有可以共享的USB设备 usbipd list 3. 共享设备 在附加 USB 设备之前，必须使用命令 usbipd bind 来共享设备，从而允许它附加到 WSL（ 需要管理员权限）。&#xA;usbipd bind --busid 2-6 这里的 2-6 是 USB 设备对应的 BUSID&#xA;4. 将USB设备连接到WSL 使用 usbipd attach 命令将指定的USB设备附加到WSL实例中。&#xA;usbipd attach --wsl --busid 2-6 打开 Ubuntu（或首选的 WSL 命令行），使用以下命令列出附加的 USB 设备</description>
    </item>
    <item>
      <title>使用 jnitrace 分析 native 方法调用过程</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-jnitrace-%E5%88%86%E6%9E%90-native-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 28 Oct 2024 15:07:33 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-jnitrace-%E5%88%86%E6%9E%90-native-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;jnitrace jnitrace 可以动态跟踪 Java 层通过 JNI 接口调用 native 层（C/C++）代码的过程。它会记录并显示每一个 JNI 函数的调用，包括方法签名、参数、返回值等详细信息。&#xA;项目地址：https://github.com/chame1eon/jnitrace&#xA;安装 jnitrace jnitrace 的使用依赖于 Frida。在使用 jnitrace 之前，需要确保 Frida 和 Python 环境已安装。可以参考下面两篇文章：&#xA;使用 Frida Hook Android App&#xA;使用Miniconda管理Python环境&#xA;通过下面的命令安装 jnitrace&#xA;pip install jnitrace 解决 frida.NotSupportedError 运行 jnitrace 报错如下&#xA;jnitrace -l libnative-lib.so com.cyrus.exammple&#xD;Traceback (most recent call last):&#xD;File &amp;#34;D:\App\Miniconda3\envs\anti-app\lib\runpy.py&amp;#34;, line 194, in _run_module_as_main&#xD;return _run_code(code, main_globals, None,&#xD;File &amp;#34;D:\App\Miniconda3\envs\anti-app\lib\runpy.py&amp;#34;, line 87, in _run_code&#xD;exec(code, run_globals)&#xD;File &amp;#34;D:\App\Miniconda3\envs\anti-app\Scripts\jnitrace.exe\__main__.py&amp;#34;, line 7, in \&amp;lt;module&amp;gt;&#xD;File &amp;#34;D:\App\Miniconda3\envs\anti-app\lib\site-packages\jnitrace\jnitrace.</description>
    </item>
    <item>
      <title>使用 IDA Tracing 动态跟踪 JNI 方法执行过程</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-ida-tracing-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA-jni-%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Fri, 25 Oct 2024 23:27:31 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-ida-tracing-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA-jni-%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;定位JNI方法内存地址 首先先找到 JNI 方法在内存中的地址，具体可以参考这篇文章【使用 Frida 定位 JNI 方法内存地址】&#xA;比如，这里需要找到 lte.NCall 的 IL 方法的内存地址&#xA;methodName-&amp;gt; public static native byte lte.NCall.IB(java.lang.Object[])&#xD;Func.offset== libGameVMP.so 0xDFA8&#xD;Func.getArtMethod-&amp;gt;native_addr: 0X7750F94FA8&#xD;methodName-&amp;gt; public static native char lte.NCall.IC(java.lang.Object[])&#xD;Func.offset== libGameVMP.so 0xDFA8&#xD;Func.getArtMethod-&amp;gt;native_addr: 0X7750F94FA8&#xD;methodName-&amp;gt; public static native double lte.NCall.ID(java.lang.Object[])&#xD;Func.offset== libGameVMP.so 0xE028&#xD;Func.getArtMethod-&amp;gt;native_addr: 0X7750F95028&#xD;methodName-&amp;gt; public static native float lte.NCall.IF(java.lang.Object[])&#xD;Func.offset== libGameVMP.so 0xDFE8&#xD;Func.getArtMethod-&amp;gt;native_addr: 0X7750F94FE8&#xD;methodName-&amp;gt; public static native int lte.NCall.II(java.lang.Object[])&#xD;Func.offset== libGameVMP.so 0xDFA8&#xD;Func.getArtMethod-&amp;gt;native_addr: 0X7750F94FA8&#xD;methodName-&amp;gt; public static native long lte.</description>
    </item>
    <item>
      <title>Android 下通过触发 SIGTRAP 信号实现反调试</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-%E4%B8%8B%E9%80%9A%E8%BF%87%E8%A7%A6%E5%8F%91-sigtrap-%E4%BF%A1%E5%8F%B7%E5%AE%9E%E7%8E%B0%E5%8F%8D%E8%B0%83%E8%AF%95/</link>
      <pubDate>Fri, 18 Oct 2024 22:55:01 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-%E4%B8%8B%E9%80%9A%E8%BF%87%E8%A7%A6%E5%8F%91-sigtrap-%E4%BF%A1%E5%8F%B7%E5%AE%9E%E7%8E%B0%E5%8F%8D%E8%B0%83%E8%AF%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;详细的 Linux 信号列表 Linux 信号是一种用于进程间通信（IPC）和异常处理的机制。以下是详细的 Linux 信号列表，包含信号名称、默认行为及用途&#xA;信号编号 信号名称 默认行为 说明 1 SIGHUP 终止进程 终止控制终端或配置文件发生变化时发出。 2 SIGINT 终止进程 来自用户输入（通常是 Ctrl+C）。 3 SIGQUIT 终止进程并生成core文件 来自用户输入（通常是 Ctrl+\）。 4 SIGILL 终止进程并生成core文件 非法指令执行。 5 SIGTRAP 终止进程并生成core文件 调试陷阱。 6 SIGABRT 终止进程并生成core文件 调用 abort 函数时发出。 7 SIGBUS 终止进程并生成core文件 总线错误（内存访问不对齐）。 8 SIGFPE 终止进程并生成core文件 浮点运算错误。 9 SIGKILL 终止进程 强制终止进程，无法被捕获或忽略。 10 SIGUSR1 终止进程 用户自定义信号 1。 11 SIGSEGV 终止进程并生成core文件 无效的内存访问。 12 SIGUSR2 终止进程 用户自定义信号 2。 13 SIGPIPE 终止进程 向没有读取端的管道写入数据时发出。 14 SIGALRM 终止进程 由 alarm 函数发出的定时器信号。 15 SIGTERM 终止进程 请求终止进程，可以被捕获和忽略。 16 SIGSTKFLT 终止进程 协处理器栈错误。 17 SIGCHLD 忽略 子进程停止或终止时发出。 18 SIGCONT 继续执行 让停止的进程继续运行。 19 SIGSTOP 停止进程 停止进程，无法被捕获或忽略。 20 SIGTSTP 停止进程 来自用户输入的停止信号（通常是 Ctrl+Z）。 21 SIGTTIN 停止进程 后台进程尝试从终端读取输入时发出。 22 SIGTTOU 停止进程 后台进程尝试向终端写入输出时发出。 23 SIGURG 忽略 套接字有紧急数据到达时发出。 24 SIGXCPU 终止进程 超出 CPU 时间限制。 25 SIGXFSZ 终止进程 超出文件大小限制。 26 SIGVTALRM 终止进程 虚拟时钟信号，由 27 SIGPROF 终止进程 定时器到期，由 28 SIGWINCH 忽略 终端窗口大小改变时发出。 29 SIGIO 忽略 I/O 事件发生时发出。 30 SIGPWR 终止进程 电源故障时发出。 31 SIGSYS 终止进程并生成core文件 非法的系统调用。 此外，Linux 还支持实时信号（Real-Time Signals），编号从 32 开始，通常是用于用户自定义的信号，应用程序可根据需要使用这些信号。</description>
    </item>
    <item>
      <title>unidbg console debugger 调试技巧</title>
      <link>https://cyrus-studio.github.io/blog/posts/unidbg-console-debugger-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sun, 13 Oct 2024 19:46:25 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/unidbg-console-debugger-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;打开debug日志 编辑 unidbg-android/src/test/resources/log4j.properties 把 log4j.logger.com.github.unidbg.AbstractEmulator 改为 DEBUG 当运行报错时会自动断点，可以看到具体报错的位置、寄存器、机器码等等信息。&#xA;[03:20:11 438] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:364) - emulate RX@0x121daa74[libc.so]0x1aa74 started sp=unidbg@0xe4fff700&#xD;[03:20:11 457] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:402) - emulate RX@0x121daa74[libc.so]0x1aa74 finished sp=unidbg@0xe4fff700, offset=18ms&#xD;[03:20:11 458] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:364) - emulate RX@0x121daa98[libc.so]0x1aa98 started sp=unidbg@0xe4fff700&#xD;[03:20:11 458] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:402) - emulate RX@0x121daa98[libc.so]0x1aa98 finished sp=unidbg@0xe4fff700, offset=0ms&#xD;[03:20:11 458] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:364) - emulate RX@0x121daaac[libc.so]0x1aaac started sp=unidbg@0xe4fff700&#xD;[03:20:11 459] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:402) - emulate RX@0x121daaac[libc.so]0x1aaac finished sp=unidbg@0xe4fff700, offset=0ms&#xD;[03:20:11 459] DEBUG [com.</description>
    </item>
    <item>
      <title>IDA静态分析中伪代码显示优化</title>
      <link>https://cyrus-studio.github.io/blog/posts/ida%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E4%B8%AD%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%98%BE%E7%A4%BA%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 07 Oct 2024 03:27:58 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/ida%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E4%B8%AD%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%98%BE%E7%A4%BA%E4%BC%98%E5%8C%96/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;1. 导入一个头文件 jni.h jni.h文件下载地址：https://github.com/CYRUS-STUDIO/blog/blob/main/assets/files/jni.h&#xA;2.还原jni函数名 点“OK”之后，当前页面好像更容易理解些，就是调用了一些jni方法 3.但是这样还不够直观，还有最后一步，如下图： 4.最后变成这样，是不是更直观呢 参考：使用IDA进行动态调试与过反调试（上）（三）</description>
    </item>
    <item>
      <title>常见的 256 条 Dalvik 字节码指令</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%B8%B8%E8%A7%81%E7%9A%84-256-%E6%9D%A1-dalvik-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Sat, 05 Oct 2024 03:10:33 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%B8%B8%E8%A7%81%E7%9A%84-256-%E6%9D%A1-dalvik-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Dalvik 字节码指令是 Android 虚拟机的指令集，广泛用于处理 .dex 文件中的代码。下面列出一些常用的 Dalvik 指令，但 Dalvik 指令集有很多操作码，这里仅列出 256 个常用指令及其功能简述。为简明起见，指令按类别分类。&#xA;1. 常量加载 const vA, #+B - 加载常量 B 到寄存器 vA const/4 vA, #+B - 加载 4 位常量 B 到寄存器 vA const/16 vA, #+BBBB - 加载 16 位常量 B 到寄存器 vA const/high16 vA, #+BBBB0000 - 加载高 16 位常量 const-wide vA, #+BBBBBBBBBBBBBBBB - 加载 64 位常量 const-wide/16 vA, #+BBBB - 加载 16 位宽常量 const-wide/high16 vA, #+BBBB000000000000 - 加载高 16 位宽常量 2.</description>
    </item>
    <item>
      <title>使用IDA Pro动态调试Android APP</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8ida-pro%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95android-app/</link>
      <pubDate>Mon, 30 Sep 2024 15:27:58 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8ida-pro%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95android-app/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;关于 android_server android_server 是 IDA Pro 在 Android 设备上运行的一个调试服务器。&#xA;通过在 Android 设备上运行android_server，IDA Pro 可以远程调试 Android 应用程序，并实现断点设置、内存查看、寄存器检查等功能。&#xA;IDA Pro 通过 adb（Android Debug Bridge）将调试命令发送给 android_server，然后 android_server 在 Android 设备上执行这些命令，并将结果返回给 IDA Pro。&#xA;调试环境准备 把 IDA安装目录/dbgsrv 下的 android_server64 push 到设备 /data/local/tmp 路径下&#xA;adb push &amp;#34;D:\App\IDA_Pro\IDA_Pro_7.7\dbgsrv\android_server64&amp;#34; /data/local/tmp/as 进入 adb shell 启动 androd server&#xA;# 获取 root 权限&#xD;su&#xD;# 给 android server 增加执行权限&#xD;chmod +x /data/local/tmp/as&#xD;# 通过指定端口启动 android_server，假设你要使用端口 12345&#xD;/data/local/tmp/as -p 12345 关于获取手机 root 权限和开启全局调试可以参考下面两篇文章：</description>
    </item>
    <item>
      <title>使用readelf分析so文件</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8readelf%E5%88%86%E6%9E%90so%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sun, 29 Sep 2024 20:31:26 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8readelf%E5%88%86%E6%9E%90so%E6%96%87%E4%BB%B6/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;readelf readelf 是一个用于读取和显示 ELF（Executable and Linkable Format）文件信息的工具。虽然 readelf 工具本身是为 Unix-like 操作系统设计的，但你可以在 Windows 上通过 WSL 使用它。&#xA;WSL 允许你在 Windows 上运行 Linux 发行版，并且可以在其中使用 readelf 工具。&#xA;安装 WSL 打开 PowerShell 以管理员身份运行，并执行以下命令启用 WSL 并安装 Ubuntu 系统&#xA;wsl --install -d Ubuntu 然后设置用户账户和密码。 通过 wsl 命令进入 Ubuntu 系统。&#xA;在 wsl 中 /mnt/d 对应的就是 windows 下的 D 盘，其他同理。&#xA;使用 readelf 调用 readelf -a 一次性查看文件中的所有信息，包括文件头、程序头、节头、符号表、动态节等。&#xA;readelf -a libGameVMP.so&#xD;ELF Header:&#xD;Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00&#xD;Class: ELF64&#xD;Data: 2&amp;#39;s complement, little endian&#xD;Version: 1 (current)&#xD;OS/ABI: UNIX - System V&#xD;ABI Version: 0&#xD;Type: DYN (Shared object file)&#xD;Machine: AArch64&#xD;Version: 0x1&#xD;Entry point address: 0x2650&#xD;Start of program headers: 64 (bytes into file)&#xD;Start of section headers: 130160 (bytes into file)&#xD;Flags: 0x0&#xD;Size of this header: 64 (bytes)&#xD;Size of program headers: 56 (bytes)&#xD;Number of program headers: 7&#xD;Size of section headers: 64 (bytes)&#xD;Number of section headers: 7&#xD;Section header string table index: 1&#xD;Section Headers:&#xD;[Nr] Name Type Address Offset&#xD;Size EntSize Flags Link Info Align&#xD;[ 0] NULL 0000000000000000 00000000&#xD;0000000000000000 0000000000000000 0 0 0&#xD;[ 1] .</description>
    </item>
    <item>
      <title>基于Python与K-Means的自动化视频分类方法</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8Epython%E4%B8%8Ek-means%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 21 Sep 2024 01:43:21 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8Epython%E4%B8%8Ek-means%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;实现过程 1. 特征提取：使用预训练的 InceptionV3 模型，从视频的若干帧中提取高维的视觉特征。将每个视频的所有帧特征取平均值，生成一个固定长度的特征向量来表示该视频。&#xA;2. 聚类：通过 K-Means 的聚类结果，每个视频被分配了一个簇标签，代表该视频与哪些视频在特征上最相似。&#xA;3. 分类整理：最后根据簇标签，将视频移动到相应的分类文件夹中，每个文件夹对应一个簇。&#xA;InceptionV3 模型 InceptionV3 是一种用于图像分类和特征提取的深度学习模型，它是Inception 系列模型的第三个版本，由 Google 在 2015 年提出。&#xA;它最初是作为图像分类任务的一个模型，能够将图像分类到 1000 个类别中（如狗、猫、汽车等）。通过去除模型的最后几层（分类部分），可以将 InceptionV3 用作特征提取器。&#xA;簇 簇是聚类算法的核心概念，表示数据中相似的子集，目的是将无标签的数据点分组。&#xA;K-Means K-Means 是一种常用的无监督聚类算法，它的目标是将数据点分成 K 个簇（Cluster），使得每个簇内的数据点尽可能接近同一个中心（即簇的质心）。&#xA;算法的核心思想是通过迭代的方式找到 K 个最优的簇质心，并根据这些质心将数据进行分组。&#xA;源码 1. 安装依赖库 pip install moviepy scikit-learn tensorflow opencv-python 2. 实现代码 import os&#xD;import numpy as np&#xD;import cv2&#xD;from moviepy.editor import VideoFileClip&#xD;from sklearn.cluster import KMeans&#xD;from tensorflow.keras.applications import InceptionV3&#xD;from tensorflow.keras.applications.inception_v3 import preprocess_input&#xD;from tensorflow.</description>
    </item>
    <item>
      <title>Android下反调试与反反调试</title>
      <link>https://cyrus-studio.github.io/blog/posts/android%E4%B8%8B%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/</link>
      <pubDate>Thu, 19 Sep 2024 06:44:08 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android%E4%B8%8B%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;反调试检测 反调试检测的几种方式。&#xA;1. TrackerId 首先，通过 IDA Pro 的调试器附加到当前 app 进程 关于IDA Pro调试android app的详细教程可以参考这篇文章【使用IDA Pro动态调试Android APP】&#xA;使用 top 命令查看进程状态&#xA;top | grep com.cyrus.example&#xD;17305 u0_a137 10 -10 4.8G 104M 42M t 0.0 1.8 0:02.02 com.cyrus.example 在输出中，S 表示进程状态，17305 是 PID。&#xA;通过head /proc/[pid]/status 可以查看详细的进程状态。&#xA;head -n 6 /proc/17305/status&#xD;Name: m.cyrus.example&#xD;State: S (sleeping)&#xD;Tgid: 17305&#xD;Pid: 17305&#xD;PPid: 728&#xD;TracerPid: 16208 TracerPid: 16208 说明当前的进程正在被进程 16208 调试或跟踪，否则没有被调试值应该为0。&#xA;2. stat 这时我们断点调试 app 再通过 head /proc/[pid]/status 可以查看详细的进程状态，包括是否被调试等信息。</description>
    </item>
    <item>
      <title>LineageOS连接网络提示IP配置失败</title>
      <link>https://cyrus-studio.github.io/blog/posts/lineageos%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C%E6%8F%90%E7%A4%BAip%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Wed, 18 Sep 2024 15:35:46 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/lineageos%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C%E6%8F%90%E7%A4%BAip%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/</guid>
      <description> 版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;IP配置失败 连接所有网络都提示IP配置失败，通过配置静态IP也连不上网络，感觉就是WIFI模块不能用了。&#xA;使用 Magisk root 后就这样了，LineageOS 17.1（wayne），重新刷回刷机包的 boot.img 后就没问题了。&#xA;但是如果需要用到 root 权限怎么办？&#xA;以 Root 身份进入 ADB Shell 首先，进入设置中【开发者选项】，开启【Root 身份的调试】 接着执行下面的命令获取 root 权限&#xA;# 启用 adb root 身份&#xD;adb root&#xD;restarting adbd as root&#xD;# 以 root 身份进入&#xD;adb shell&#xD;# 验证 Root 权限&#xD;whoami&#xD;root # 返回结果为 root，说明你已经成功以 root 身份进入 ADB shell。 </description>
    </item>
    <item>
      <title>解决LineageOS提示网络受限问题</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E8%A7%A3%E5%86%B3lineageos%E6%8F%90%E7%A4%BA%E7%BD%91%E7%BB%9C%E5%8F%97%E9%99%90%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 16 Sep 2024 21:34:05 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E8%A7%A3%E5%86%B3lineageos%E6%8F%90%E7%A4%BA%E7%BD%91%E7%BB%9C%E5%8F%97%E9%99%90%E9%97%AE%E9%A2%98/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;问题原因 由于 LineageOS 源码里默认是使用 google captive连接验证服务，所以国内会一直提示网络受限，但是实际上是可以访问网络的。&#xA;要解决这个问题可以通过把 captive_portal_https_url 改为国内的就好了，比如用MIUI的。&#xA;更换 captive 连接验证服务器 1. 通过 adb 修改 adb shell settings put global captive_portal_https_url https://connect.rom.miui.com/generate_204&#xD;adb shell settings put global captive_portal_http_url http://connect.rom.miui.com/generate_204 2. 修改源码 编辑 packages/modules/NetworkStack/res/values/config.xml&#xA;&amp;lt;!-- HTTP URL for network validation, to use for detecting captive portals. --&amp;gt;&#xD;&amp;lt;string name=&amp;#34;default_captive_portal_http_url&amp;#34; translatable=&amp;#34;false&amp;#34;&amp;gt;http://connectivitycheck.gstatic.com/generate_204&amp;lt;/string&amp;gt;&#xD;&amp;lt;!-- HTTPS URL for network validation, to use for confirming internet connectivity. --&amp;gt;&#xD;&amp;lt;string name=&amp;#34;default_captive_portal_https_url&amp;#34; translatable=&amp;#34;false&amp;#34;&amp;gt;https://www.google.com/generate_204&amp;lt;/string&amp;gt;&#xD;&amp;lt;!-- List of fallback URLs to use for detecting captive portals.</description>
    </item>
    <item>
      <title>使用 release key 对 LineageOS 进行编译和签名</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-release-key-%E5%AF%B9-lineageos-%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91%E5%92%8C%E7%AD%BE%E5%90%8D/</link>
      <pubDate>Mon, 16 Sep 2024 21:05:17 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-release-key-%E5%AF%B9-lineageos-%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91%E5%92%8C%E7%AD%BE%E5%90%8D/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;为什么需要使用 release key test-key 是一个公开的、众所周知的开发测试密钥，广泛用于测试阶段。这意味着任何人都可以获取这个密钥，并用它签署自己修改的 APK 或系统文件。&#xA;使用 test-key 签署的系统镜像通常无法通过 Google 的 CTS（兼容性测试套件）认证，Google Play 商店、Google 服务框架等应用可能无法正常运行，某些第三方应用（例如银行应用或数字版权管理应用）也可能拒绝在设备上运行。&#xA;OTA 更新包必须使用 Release Key 来签名。签名的更新包经过验证，只有具有相同 Release Key 的设备才能接收和安装更新。&#xA;生成 release key 执行 nano make_keys.sh 创建脚本，内容如下&#xA;subject=&amp;#39;/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=linchaolong.dev@gmail.com&amp;#39;&#xD;# 创建 keys 目录（如果不存在）&#xD;mkdir -p keys&#xD;for cert in bluetooth cyngn-app media networkstack nfc platform releasekey sdk_sandbox shared testcert testkey verity; do \&#xD;./development/tools/make_key keys/$cert &amp;#34;$subject&amp;#34;; \&#xD;done 通过脚本创建 keys 目录并使用 make_key 命令生成你自己的密钥。&#xA;运行脚本生成密钥文件。</description>
    </item>
    <item>
      <title>Android源码导入Android Studio</title>
      <link>https://cyrus-studio.github.io/blog/posts/android%E6%BA%90%E7%A0%81%E5%AF%BC%E5%85%A5android-studio/</link>
      <pubDate>Sun, 15 Sep 2024 13:27:26 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android%E6%BA%90%E7%A0%81%E5%AF%BC%E5%85%A5android-studio/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 需要先把 Android 源码编译一遍 然后执行下面指令就可以导入android源码了&#xA;关于 Android 源码编译可以参考这篇文章【LineageOS源码下载和编译（Xiaomi Mi 6X，wayne）】。&#xA;生成 android.ipr 文件 1. 进入到下面的目录&#xA;cd ./development/tools/idegen 2. 使用 mm 命令对当前目录 make，构建 idegen 模块&#xA;mm 执行完成后会在 out 目录生成一个 idegen.jar 文件&#xA;3. 回到 android 源码根目录，执行 idegen.sh 脚本（需要管理员权限）&#xA;# 回到 android 源码根目录&#xD;croot&#xD;# 执行 idegen.sh 脚本&#xD;sudo ./development/tools/idegen/idegen.sh 4. 执行完成后会生成一个 android.ipr 文件，用 android studio 打开这个 android.ipr 文件就可以完成 android 源码的导入了 运行 idegen.sh 脚本时遇到的问题 在运行 development/tools/idegen/idegen.sh 脚本时遇到的问题&#xA;1. 文件系统循环 find: File system loop detected 错误表示在使用 find 命令时遇到了符号链接循环。这通常不会导致脚本失败，但确实会产生一些额外的警告信息。</description>
    </item>
    <item>
      <title>LineageOS刷机教程</title>
      <link>https://cyrus-studio.github.io/blog/posts/lineageos%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sun, 15 Sep 2024 01:50:08 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/lineageos%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;LineageOS 是一个基于 Android 开源项目（AOSP）的开源操作系统，主要由社区开发者维护。它起源于 CyanogenMod 项目，该项目于 2016 年关闭后，LineageOS 成为了其继任者。&#xA;主要特点：&#xA;开源：所有源代码都是开源的，任何人都可以查看、修改和分发。&#xA;无预装垃圾软件：相比一些预装大量应用的定制 ROM，LineageOS 保持了简洁和干净的系统环境。&#xA;定期更新：社区提供持续的安全补丁和新功能更新。&#xA;广泛设备支持：支持各种品牌和型号的设备，尤其是一些官方已停止支持的老旧设备。&#xA;隐私保护：LineageOS 提供了增强的隐私保护功能，如权限管理器和私密模式。&#xA;注意：在刷机之前，请确认你的设备已经解除BL锁。&#xA;LineageOS 开始刷机之前，先在 LineageOS官网 找到自己的设备型号，下载对应的刷机包&#xA;或者下载 LineageOS 源码 自己编译系统&#xA;下载 GMS套件包 （可选） 刷机环境准备 在 Linux 中配置 Android SDK Platform-Tools，可以按照以下步骤进行&#xA;1. 下载 Android SDK Platform-Tools： # cd 到存放 platform-tools 的目录&#xD;cd /mnt/case_sensitive&#xD;# 下载 platform-tools&#xD;wget https://dl.google.com/android/repository/platform-tools-latest-linux.zip&#xD;# 解压 platform-tools&#xD;unzip platform-tools-latest-linux.zip 2. 配置环境变量： 为了在任何地方都能使用 adb 和 fastboot 命令，你需要将 platform-tools 目录添加到你的 PATH 中。</description>
    </item>
    <item>
      <title>小米手机解除BL锁&amp;刷机&amp;root</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E8%A7%A3%E9%99%A4bl%E9%94%81%E5%88%B7%E6%9C%BAroot/</link>
      <pubDate>Fri, 13 Sep 2024 23:49:13 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E8%A7%A3%E9%99%A4bl%E9%94%81%E5%88%B7%E6%9C%BAroot/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;解锁BL锁 1. 下载安装 miflash_unlock：https://miuiver.com/miunlock/，登录小米账号（需要和解锁设备绑定的账号一致） 2. 连接手机，关机后按住 “音量-” + 开机键进入 fastboot 模式，根据提示解锁手机 如果连接不上设备，点击右上角设置按钮【驱动检测】，手机进入recovery模式下重新连接，等待驱动安装完成。 如果还是连不上，参考下面链接的解决办法 https://miuiver.com/usb3-fix/&#xA;3. 重启手机开发者模式中查看解锁状态 刷机 ROM下载：https://magiskcn.com/rom&#xA;1. 下载小米线刷工具：https://xiaomirom.com/download-xiaomi-flash-tool-miflash/&#xA;2. 下载设备开发版线刷包，并解压线刷包 3. 打开miflash&#xA;4. 连接手机，关机，按住 &amp;ldquo;开机&amp;rdquo; + &amp;ldquo;音量-&amp;rdquo; 进入fastboot模式&#xA;5. 选择线刷包解压目录开始刷机 等待刷机成功 6. 刷机成功后，重新解除BL锁&#xA;7. 打开手机管家——应用管理——权限——ROOT权限——开启ROOT权限 结果发现root工具一直下载失败&#xA;使用Magisk进行root 下载 Magisk：https://github.com/topjohnwu/Magisk/releases&#xA;1. 安装 Magisk&#xA;adb install Magisk-v27.0.apk 2. 解压线刷包中的 boot.img，并 push 到手机&#xA;adb push boot.img /sdcard/boot.img 3. Magisk中【安装】【下一步】【选择并修补一个文件】【选择boot.img】，把处理完后的magisk_patched 下载到电脑 Android sdk\platform-tools 目录（这里下载 Android SDK Platform Tools）&#xA;adb pull /sdcard/Download/magisk_patched-27000_RIC3F.</description>
    </item>
    <item>
      <title>编译LineageOS模拟器镜像，导出到AndroidStudio</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%BC%96%E8%AF%91lineageos%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%95%9C%E5%83%8F%E5%AF%BC%E5%87%BA%E5%88%B0androidstudio/</link>
      <pubDate>Sun, 01 Sep 2024 12:39:32 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%BC%96%E8%AF%91lineageos%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%95%9C%E5%83%8F%E5%AF%BC%E5%87%BA%E5%88%B0androidstudio/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;源码下载 LineageOS官网：https://lineageos.org/ LineageOS源码 github 地址：https://github.com/LineageOS/android LineageOS源码国内镜像地址：https://mirrors.tuna.tsinghua.edu.cn/help/lineageOS/&#xA;源码大概需要150GB的硬盘空间，编译完成差不多300G 1. 配置git git config --global user.email &amp;#34;you@example.com&amp;#34;&#xD;git config --global user.name &amp;#34;Your Name&amp;#34; 2. 安装 repo mkdir ~/bin&#xD;PATH=~/bin:$PATH&#xD;curl https://storage.googleapis.com/git-repo-downloads/repo &amp;gt; ~/bin/repo&#xD;chmod a+x ~/bin/repo 3. 安装 Git LFS sudo apt install git-lfs&#xD;git lfs install 4. 设置REPO_URL 找到 repo 所在路径&#xA;which repo 编辑 repo&#xA;nano /home/cyrus/bin/repo 可以看到repo会优先取环境变量中的REPO_URL，否则默认使用googlesource&#xA;Ctrl +X 退出nano&#xA;通过下面的命令设置 REPO_URL 环境变量，设置为清华大学镜像源，解决国内访问不了 googlesource 问题&#xA;export REPO_URL=https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/ 5. 下载源码 创建目录</description>
    </item>
    <item>
      <title>MagiskBoot编译&amp;解包&amp;打包boot.img</title>
      <link>https://cyrus-studio.github.io/blog/posts/magiskboot%E7%BC%96%E8%AF%91%E8%A7%A3%E5%8C%85%E6%89%93%E5%8C%85boot.img/</link>
      <pubDate>Thu, 29 Aug 2024 04:25:23 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/magiskboot%E7%BC%96%E8%AF%91%E8%A7%A3%E5%8C%85%E6%89%93%E5%8C%85boot.img/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;编译环境准备 1. Windows下启用开发者模式，因为需要 symbolic link 支持 2. 安装 python3.8+，并配置PATH环境变量&#xA;# 查看python版本信息&#xD;py --version&#xD;# 查看所有已安装的 Python 解释器路径&#xD;py -0p 3. git 启用 symbolic links&#xA;# 启用 symbolic links&#xD;git config --global core.symlinks true&#xD;# 查看 git 配置&#xD;git config --global --list 4. 安装 Android Studio ，设置环境变量 ANDROID_HOME 为 Android SDK 文件夹的路径。该路径可以在 Android Studio 的设置中找到。&#xA;5. 下载 Magisk 源码&#xA;# 下载 Magisk 源码&#xD;git clone --recurse-submodules https://github.com/topjohnwu/Magisk.git&#xD;# 如果子模块克隆失败，可以手动克隆这些子模块。进入对应的子模块路径，然后执行以下命令&#xD;git submodule update --init --recursive 6.</description>
    </item>
    <item>
      <title>Linux下代理设置</title>
      <link>https://cyrus-studio.github.io/blog/posts/linux%E4%B8%8B%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Thu, 29 Aug 2024 04:25:16 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/linux%E4%B8%8B%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;1. 下载安装clash-verge 下载 clash-verge https://github.com/clash-verge-rev/clash-verge-rev/releases&#xA;我这边用的是 ubuntu22，下载 clash-verge_1.7.5_amd64.deb&#xA;安装 clash-verge&#xA;# 安装相关依赖&#xD;sudo apt update&#xD;sudo apt install -f&#xD;sudo apt install libayatana-appindicator3-1 libwebkit2gtk-4.0-37 libgtk-3-0&#xD;# 安装clash-verge&#xD;sudo dpkg -i clash-verge_1.7.5_amd64.deb&#xD;# 卸载clash-verge&#xD;sudo dpkg -r clash-verge&#xD;# 启动 Clash Verge（nohup 命令可以让进程在后台运行，即使关闭终端也不会影响进程运行。）&#xD;# nohup 会创建一个 nohup.out 文件来记录输出日志。&#xD;nohup clash-verge &amp;amp; 2. 解决显示乱码问题 安装一些常见的字体包&#xA;sudo apt update&#xD;sudo apt install fonts-noto-cjk fonts-noto fonts-noto-core fonts-noto-ui-core fonts-wqy-zenhei 3. 导入订阅地址，开启代理 设置 关闭 IPV6 设置 勾选 系统代理 我这里科学上网使用的是魔戒，注册地址：https://mojie.</description>
    </item>
    <item>
      <title>荣耀Magicbook x14 扩容1TB固态</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E8%8D%A3%E8%80%80magicbook-x14-%E6%89%A9%E5%AE%B91tb%E5%9B%BA%E6%80%81/</link>
      <pubDate>Sun, 18 Aug 2024 03:06:59 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E8%8D%A3%E8%80%80magicbook-x14-%E6%89%A9%E5%AE%B91tb%E5%9B%BA%E6%80%81/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;固态硬盘规格 在官网查看加装固态硬盘的接口规格 https://www.honor.com/cn/laptops/honor-magicbook-x14-2023/ https://club.honor.com/cn/thread-28473794-1-1.html&#xA;或者在荣耀手机上的【荣耀商城app】里联系在线客服 选购固态硬盘 三星的性能不错，但是发热控制得不好，不适合用在轻薄本&#xA;凯侠的发热和性能都很平衡&#xA;笔记本自带的是铠侠KBG50ZNV1T02&#xA;综合看下来，凯侠SE10是不错的选择，但是是2280尺寸的&#xA;扩展固态的插槽规格是M2 2242&#xA;最后选出两款合适的：&#xA;西部数据SN740，性能不错，温控还可以，1T价格499。&#xA;凯侠BG5，性能中规中矩，温控很不错，1T价格359。&#xA;最后选择了凯侠G5 还有拆机工具 拆机加装过程 首先用吸盘吸住底盘的一角，拉出一条缝后，用撬棒插进去慢慢撬开 底盘拆开后，可以看到固态硬盘加装插口就在图中红圈位置 接着就是扭开加装接口那颗螺丝，就可以把固态硬盘插进去了 但买到的螺丝刀实在太辣鸡了，扭一下就损坏了。。。 最终还是跑去荣耀服务点把固态硬盘装进去了 接着开机，打开【设置】【系统】【存储】【磁盘和卷】 点击“初始化”，因为我们是扩容，选择GPT就行。 接下来点击“创建卷”。 为新硬盘取个分区名字，点击“格式化”。 再打开此电脑就能看到新磁盘了 用CrystalDiskInfo打开看看 用CrystalDiskMark测试一下读写 硬盘检测相关工具 CrystalDiskInfo中文版(硬盘检测工具) v9.3.2 https://www.423down.com/5432.html&#xA;AS SSD Benchmark 2.0.7316 汉化版单文件 https://www.423down.com/6751.html&#xA;硬盘检测工具CrystalDiskMark v8.0.5中文版 https://www.423down.com/10418.html&#xA;重新分配磁盘空间 由于C盘空间不太够用，需要重新分配一下磁盘空间&#xA;下载【傲梅分区助手】，使用码是1122&#xA;在D盘上右键，点击【分配空闲空间】 分配20GB给C盘 左上角点击【提交】 点击【执行】 点击【确定】 等待创建Windows PE后重启分区 重新分区中 分区完成后重启，可以看到C盘已经扩容了20GB 参考： 荣耀magicbook x16 2023扩容2T固态成功笔记 价格大跳水！顶级固态硬盘终于敢买了！铠侠SE10 1T上手体验 海力士BC711/BC901 西数SN740 铠侠BG4/BG5/BG6 美光2550/2400A 群联P0221 建兴CL4 M2 2230 NVME写入测试 加装固态硬盘主机扩容分步教程，手把手教你，进来学！ 想不格式化硬盘重新分区？4个方法轻松解决！</description>
    </item>
    <item>
      <title>小米5c解除BL锁&amp;刷机&amp;root</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%B0%8F%E7%B1%B35c%E8%A7%A3%E9%99%A4bl%E9%94%81%E5%88%B7%E6%9C%BAroot/</link>
      <pubDate>Sun, 18 Aug 2024 01:54:50 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%B0%8F%E7%B1%B35c%E8%A7%A3%E9%99%A4bl%E9%94%81%E5%88%B7%E6%9C%BAroot/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;解锁BL锁 1. 下载安装 miflash_unlock：https://miuiver.com/miunlock/，登录小米账号（需要和解锁设备绑定的账号一致） 2. 连接手机，关机后按住 “音量-” + 开机键进入 fastboot 模式，根据提示解锁手机 3. 重启手机开发者模式中查看解锁状态 刷机 ROM下载：https://magiskcn.com/rom&#xA;1. 下载小米线刷工具：https://xiaomirom.com/download-xiaomi-flash-tool-miflash/&#xA;2. 下载小米5c开发版线刷包，并解压线刷包 3. 打开miflash&#xA;4. 连接手机，关机，按住 &amp;ldquo;开机&amp;rdquo; + &amp;ldquo;音量-&amp;rdquo; 进入fastboot模式&#xA;5. 选择线刷包解压目录开始刷机 等待刷机成功 6. 刷机成功后，重新解除BL锁&#xA;7. 打开手机管家——应用管理——权限——ROOT权限——开启ROOT权限 结果发现root工具一直下载失败&#xA;使用Magisk进行root 下载 Magisk：https://github.com/topjohnwu/Magisk/releases&#xA;1. 安装 Magisk&#xA;adb install Magisk-v27.0.apk 2. 解压线刷包中的 boot.img，并 push 到手机&#xA;adb push boot.img /sdcard/boot.img 3. Magisk中【安装】【下一步】【选择并修补一个文件】【选择boot.img】，把处理完后的magisk_patched 下载到电脑 Android sdk\platform-tools 目录（这里下载 Android SDK Platform Tools）&#xA;adb pull /sdcard/Download/magisk_patched-27000_RIC3F.img D:\App\android\sdk\platform-tools 4. 使用 adb 命令将设备重启到 fastboot 模式</description>
    </item>
    <item>
      <title>修改android系统ro.debuggable使全局可调试</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BF%AE%E6%94%B9android%E7%B3%BB%E7%BB%9Fro.debuggable%E4%BD%BF%E5%85%A8%E5%B1%80%E5%8F%AF%E8%B0%83%E8%AF%95/</link>
      <pubDate>Fri, 16 Aug 2024 00:04:11 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BF%AE%E6%94%B9android%E7%B3%BB%E7%BB%9Fro.debuggable%E4%BD%BF%E5%85%A8%E5%B1%80%E5%8F%AF%E8%B0%83%E8%AF%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;修改 android 系统 中的 ro.debuggable 属性使设备上所有 app 可调试。&#xA;下载MagiskHidePropsConf：https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf/tags&#xA;把下载下来的MagiskHidePropsConf推送到手机sdcard上&#xA;adb push &amp;#34;D:\app逆向\MagiskHidePropsConf-v6.1.2.zip&amp;#34; /sdcard/ 安装MagiskHidePropsConf，打开Magick【模块】【本地安装】【选择MagiskHidePropsConf-v6.1.2.zi p】&#xA;重启手机，进入 adb shell&#xA;输入props&#xA;meri:/ # props&#xD;Loading... Please wait.&#xD;MagiskHide Props Config v6.1.2&#xD;by Didgeridoohan @ XDA Developers&#xD;=====================================&#xD;Updating fingerprints list&#xD;=====================================&#xD;Checking list version.&#xD;! File not downloaded!&#xD;Checking for module update.&#xD;! File not downloaded!&#xD;MagiskHide Props Config v6.1.2&#xD;by Didgeridoohan @ XDA Developers&#xD;=====================================&#xD;Select an option below.</description>
    </item>
    <item>
      <title>有道云docx转换markdown，导入hugo发布到github page，多平台发布适配</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%9C%89%E9%81%93%E4%BA%91docx%E8%BD%AC%E6%8D%A2markdown%E5%AF%BC%E5%85%A5hugo%E5%8F%91%E5%B8%83%E5%88%B0github-page%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%8F%91%E5%B8%83%E9%80%82%E9%85%8D/</link>
      <pubDate>Sun, 11 Aug 2024 06:09:27 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%9C%89%E9%81%93%E4%BA%91docx%E8%BD%AC%E6%8D%A2markdown%E5%AF%BC%E5%85%A5hugo%E5%8F%91%E5%B8%83%E5%88%B0github-page%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%8F%91%E5%B8%83%E9%80%82%E9%85%8D/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;有道云导出docx&#xA;有道云笔记右上角更多按钮选择【导出为Word】，可以导出docx文档 docx转换markdown&#xA;尝试了几个docx转markdown的python库后，最终选择了python-mammoth，轻量，效率高，可自定义转换满足特定需求。&#xA;python-mammoth&#xA;python-mammoth 是一个用于将 Microsoft Word (DOCX) 文档转换为 HTML 或 Markdown 的 Python 库。&#xA;github地址：https://github.com/mwilliamson/python-mammoth&#xA;安装 python-mammoth&#xA;pip install mammoth 自定义代码块样式&#xA;通过自定义 transform 来实现自定义的代码块样式来支持有道云docx的代码块&#xA;def ynote_docx_markdown_transform(document):&#xD;...&#xD;pass&#xD;result = convert_to_markdown(docx_file, transform_document=ynote_docx_markdown_transform) 通过在自定义 transform 断点调试可以看到 document 都是由一个一个 Paragraph 组成的，代码块的 Bookmark 的 name 都是相同的，由此代码块其中一个特征就是相同且相邻的 Bookmark name。 但是有的代码块只是单独的一段 这时可以通过自定义 代码/bash 特征判断该 Paragraph 中的 Text 是不是一段 代码/bash。&#xA;def is_possible_code_or_bash(text):&#xD;# 常见的代码关键字&#xD;code_keywords = [&#xD;r&amp;#39;\bif\b&amp;#39;, r&amp;#39;\bfor\b&amp;#39;, r&amp;#39;\bwhile\b&amp;#39;, r&amp;#39;\bdef\b&amp;#39;, r&amp;#39;\bclass\b&amp;#39;, r&amp;#39;\breturn\b&amp;#39;, r&amp;#39;\bimport\b&amp;#39;,&#xD;r&amp;#39;\bint\b&amp;#39;, r&amp;#39;\bfloat\b&amp;#39;, r&amp;#39;\bmain\b&amp;#39;, r&amp;#39;\binclude\b&amp;#39;, r&amp;#39;#include&amp;#39;, r&amp;#39;\becho\b&amp;#39;, r&amp;#39;\bcd\b&amp;#39;,&#xD;r&amp;#39;\bgrep\b&amp;#39;, r&amp;#39;\bexit\b&amp;#39;, r&amp;#39;\belse\b&amp;#39;, r&amp;#39;\belif\b&amp;#39;, r&amp;#39;#!</description>
    </item>
    <item>
      <title>0成本通过Hugo和GitHub Pages搭建博客</title>
      <link>https://cyrus-studio.github.io/blog/posts/0%E6%88%90%E6%9C%AC%E9%80%9A%E8%BF%87hugo%E5%92%8Cgithub-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 11 Aug 2024 06:09:10 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/0%E6%88%90%E6%9C%AC%E9%80%9A%E8%BF%87hugo%E5%92%8Cgithub-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;使用 Chocolatey 安装 Hugo&#xA;Chocolatey 是一个 Windows 软件包管理器，使用 PowerShell 和 NuGet 作为基础。它可以自动化软件的安装、升级和卸载过程。&#xA;安装 Chocolatey（如果还没有安装）&#xA;Chocolatey 允许你通过设置环境变量来更改默认安装路径。在安装 Chocolatey 之前，你需要设置 ChocolateyInstall 环境变量来指定新的安装路径。&#xA;打开 PowerShell（以管理员身份运行），并执行以下命令指定自定义安装路径：&#xA;1. [System.Environment]::SetEnvironmentVariable(&amp;#39;ChocolateyInstall&amp;#39;, &amp;#39;D:\App\chocolatey&amp;#39;, [System.EnvironmentVariableTarget]::Machine) 如果不设置默认安装路径为：C:\ProgramData\chocolatey 设置完 ChocolateyInstall 环境变量后，重新打开一下会话，执行下面的命令检查一下是否设置成功&#xA;Get-Item Env:ChocolateyInstall 打开 PowerShell（以管理员身份运行），执行以下命令安装 Chocolatey：&#xA;1. Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&amp;#39;https://community.chocolatey.org/install.ps1&amp;#39;)) 检查是否安装成功&#xA;choco -h 安装 Hugo&#xA;在 PowerShell 中运行以下命令安装 Hugo： 安装软件包：&#xA;choco install hugo -confirm 升级软件包：&#xA;choco upgrade hugo 卸载软件包：</description>
    </item>
    <item>
      <title>About</title>
      <link>https://cyrus-studio.github.io/blog/about/</link>
      <pubDate>Sat, 10 Aug 2024 12:00:00 +0000</pubDate>
      <guid>https://cyrus-studio.github.io/blog/about/</guid>
      <description>欢迎访问我的博客！在这里分享我的android、python相关知识、经验和项目。&#xA;博客地址: https://cyrus-studio.github.io/blog/ GitHub: https://github.com/CYRUS-STUDIO Email: linchaolong.dev@gmail.com </description>
    </item>
  </channel>
</rss>
