<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on CYRUS STUDIO</title>
    <link>https://cyrus-studio.github.io/blog/posts/</link>
    <description>Recent content in Posts on CYRUS STUDIO</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 10 Sep 2025 19:46:34 +0800</lastBuildDate>
    <atom:link href="https://cyrus-studio.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一文搞懂 Frida Stalker：对抗 OLLVM 的算法还原利器</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-frida-stalker%E5%AF%B9%E6%8A%97-ollvm-%E7%9A%84%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E5%88%A9%E5%99%A8/</link>
      <pubDate>Wed, 10 Sep 2025 19:46:34 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-frida-stalker%E5%AF%B9%E6%8A%97-ollvm-%E7%9A%84%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F%E5%88%A9%E5%99%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 在移动应用的安全加固中，OLLVM（Obfuscator-LLVM） 是一种常见的代码混淆与保护手段。它通过控制流平坦化、虚假控制流、指令替换等方式，使逆向分析者很难直接还原出原始算法逻辑。&#xA;然而，通过 Frida 提供的 Stalker 模块去动态分析让我们有机会对 OLLVM 的“黑盒逻辑”进行还原。&#xA;通过 Stalker 的指令级追踪能力，我们不仅能捕获 函数调用 、记录 调用参数 ，还可以打印 调用堆栈 ，最终逐步揭开 OLLVM 加固算法的真实运行流程。&#xA;比如，分析某个 so 中偏移为 0x23AD0 的加密函数。使用 IDA 反汇编 so，可以看到 so 中该函数做了混淆&#xA;使用了控制流平坦化混淆&#xA;Frida Stalker Frida Stalker 是 Frida 提供的一个强大的指令级追踪引擎，它能够在目标进程运行时，动态捕获每一条指令的执行情况。与传统的函数级 hook 不同，Stalker 可以深入到 原生汇编层面 ，追踪寄存器变化、内存访问、函数调用关系等底层细节。&#xA;相关链接：&#xA;Stalker 介绍：https://frida.re/docs/stalker/&#xA;api 文档：https://frida.re/docs/javascript-api/#stalker&#xA;目前 Stalker 对于 arm64 支持比较好，但是 arm32 并不是很完善。&#xA;onCallSummary（函数调用摘要) onCallSummary 是 Frida Stalker 提供的一个回调方法，用于在 函数调用层面 对收集到的执行数据进行归纳和统计。&#xA;它会将某一段追踪区间内的 调用信息进行汇总 ，例如：&#xA;哪些函数被调用了</description>
    </item>
    <item>
      <title>Frida 实战：Android JNI 数组 (jobjectArray) 操作全流程解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/frida-%E5%AE%9E%E6%88%98android-jni-%E6%95%B0%E7%BB%84-jobjectarray-%E6%93%8D%E4%BD%9C%E5%85%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 10 Sep 2025 17:47:12 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/frida-%E5%AE%9E%E6%88%98android-jni-%E6%95%B0%E7%BB%84-jobjectarray-%E6%93%8D%E4%BD%9C%E5%85%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 在 Android 的 Native 层，Java 中的 Object[] 类型参数会以 jobjectArray 的形式传递到 C/C++ 代码中。&#xA;与 JS 数组不同，你不能直接对 jobjectArray 进行索引访问或直接操作其元素。要获取或修改其中的内容，必须借助 JNI 提供的接口，例如获取数组长度、读取单个元素或创建新的数组等操作。&#xA;env.js 常用的 JNI 函数在 frida 的 env.js 中都已经封装好了&#xA;https://github.com/frida/frida-java-bridge/blob/main/lib/env.js&#xA;通过下面代码获取 JNIEnv 引用，就可以调用相关的 JNI 函数&#xA;let env = Java.vm.tryGetEnv() 文档：https://frida.re/docs/javascript-api/&#xA;获取数组长度 let arrLen = env.getArrayLength(objArray)&#xD;console.log(&amp;#39;array length is: &amp;#39; + arrLen); 元素类型判断 通过 getObjectClassName 可以获取到对象的类名进而判断该元素的类型。&#xA;// 获取对象的类名&#xD;let className = env.getObjectClassName(objArray)&#xD;console.log(&amp;#39;className: &amp;#39; + className);&#xD;// 判断是否 jobjectArray&#xD;if (className === &amp;#39;[Ljava.</description>
    </item>
    <item>
      <title>深入解析 AES 加密算法：原理、变体与 LibTomCrypt 在 Android 中的实战应用</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-aes-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%98%E4%BD%93%E4%B8%8E-libtomcrypt-%E5%9C%A8-android-%E4%B8%AD%E7%9A%84%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</link>
      <pubDate>Wed, 10 Sep 2025 17:16:31 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-aes-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%98%E4%BD%93%E4%B8%8E-libtomcrypt-%E5%9C%A8-android-%E4%B8%AD%E7%9A%84%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 AES（Advanced Encryption Standard，高级加密标准） 是一种 对称加密算法，用于加密和解密数据。AES 由 美国国家标准与技术研究院（NIST） 在 2001 年正式发布，取代了 DES 和 3DES，目前被广泛应用于 网络安全、金融、通信 等领域。&#xA;支持 128（16字节）、192（24字节）、256（32字节） 位密钥。&#xA;特性 描述 加密方式 对称加密（加密和解密使用相同的密钥） 分组长度 128 位（16 字节） 密钥长度 128 位、192 位、256 位（分别对应 10、12、14 轮加密） 安全性 目前无已知有效攻击，比 3DES 更安全 运算模式 支持 ECB、CBC、CFB、OFB、CTR 等模式 相关文章：一文搞懂常用加解密算法：编码、哈希、对称&amp;amp;非对称加密与压缩全解析&#xA;LibTomCrypt LibTomCrypt 是一个开源的轻量级加密库，提供了多种加密算法和密码学相关功能。它是用 C 语言编写的，专注于嵌入式系统和资源受限的设备，非常适合在 Android 等平台上使用。&#xA;特点:&#xA;算法支持丰富：包括对称加密（AES、DES 等）、非对称加密（RSA、ECC 等）、哈希算法（SHA-256、MD5 等）&#xA;轻量级，代码简单。&#xA;支持多种加密模式：ECB、CBC、CFB、OFB 等。&#xA;适用场景: 如果你需要一个开源、可自定义的库。&#xA;集成 LibTomCrypt 到 Android 工程 在 Android Studio 中集成 LibTomCrypt 并调用 JNI，可以按以下步骤操作：</description>
    </item>
    <item>
      <title>用 Frida 控制 Android 线程：kill 命令、挂起与恢复全解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%94%A8-frida-%E6%8E%A7%E5%88%B6-android-%E7%BA%BF%E7%A8%8Bkill-%E5%91%BD%E4%BB%A4%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%81%A2%E5%A4%8D%E5%85%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 10 Sep 2025 17:12:24 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%94%A8-frida-%E6%8E%A7%E5%88%B6-android-%E7%BA%BF%E7%A8%8Bkill-%E5%91%BD%E4%BB%A4%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%81%A2%E5%A4%8D%E5%85%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Android 线程相关命令 1. 获取 PID adb shell pidof com.shizhuang.duapp 2. 查看线程信息 方法一：进入 /proc//task 进入 adb shell 执行下面命令&#xA;cd /proc/$(pidof com.shizhuang.duapp)/task&#xD;ls 这个目录中每一个子目录的名字就是该 App 的一个线程的 TID（Thread ID）。&#xA;你还可以进一步查看每个线程的状态：&#xA;cat /proc/$(pidof com.shizhuang.duapp)/task/&amp;lt;tid&amp;gt;/status 例如：&#xA;cat /proc/$(pidof com.shizhuang.duapp)/task/22432/status 方法二：使用 top 或 htop 查看线程 使用 top 查看线程信息&#xA;top -H -p $(pidof com.shizhuang.duapp) -H 表示以线程方式查看&#xA;-p 指定 PID&#xA;或者使用 htop 查看线程信息&#xA;htop -p $(pidof com.shizhuang.duapp) 3. 通过 kill 命令 停止 / 挂起 / 恢复线程 kill 是 Linux 系统中用来向进程发送信号的命令，最常用于终止进程。虽然它名字叫 “kill”，但它可以发送多种信号，不只是“终止”。</description>
    </item>
    <item>
      <title>利用 Linux 信号机制（SIGTRAP）实现 Android 下的反调试</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%88%A9%E7%94%A8-linux-%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6sigtrap%E5%AE%9E%E7%8E%B0-android-%E4%B8%8B%E7%9A%84%E5%8F%8D%E8%B0%83%E8%AF%95/</link>
      <pubDate>Sun, 07 Sep 2025 01:33:43 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%88%A9%E7%94%A8-linux-%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6sigtrap%E5%AE%9E%E7%8E%B0-android-%E4%B8%8B%E7%9A%84%E5%8F%8D%E8%B0%83%E8%AF%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;利用 SIGTRAP 检测调试器 在 Linux 的进程管理中，信号（Signal） 是调试器与被调试进程沟通的核心机制。断点、单步执行、进程暂停与恢复等操作，背后都依赖于特定信号的传递。&#xA;其中，SIGTRAP （陷阱信号）尤为特殊。通常它由调试器在调试过程中触发，例如执行断点指令或单步运行时都会引发 SIGTRAP。&#xA;如果一个程序主动触发 SIGTRAP，并设置了对应的信号处理函数，就能实现一种“自检”：&#xA;若信号处理函数被成功调用，说明 SIGTRAP 没有被调试器截获，此时可以推断程序处于非调试状态 ；&#xA;若信号处理函数未被调用，反而被调试器捕获并消费，则意味着程序正被调试。&#xA;由此，利用 SIGTRAP 信号进行反调试检测 ，就成为 Android 应用中一种更隐蔽、更底层的安全防护手段。&#xA;常见 Linux 信号列表（基于 signal.h） 编号 名称 说明 1 SIGHUP 挂起信号，通常在控制终端关闭时发送给进程 2 SIGINT 中断信号，通常由 Ctrl+C 触发 3 SIGQUIT 退出信号，通常由 Ctrl+\ 触发，并生成 core dump 4 SIGILL 非法指令（非法 CPU 指令执行） 5 SIGTRAP 陷阱信号，主要用于调试（断点、单步） 6 SIGABRT 异常终止，通常由 abort() 触发 7 SIGBUS 总线错误（非法内存访问，例如未对齐访问） 8 SIGFPE 浮点异常（除零、溢出等算术错误） 9 SIGKILL 强制终止信号，无法被捕获或忽略 11 SIGSEGV 无效内存访问（段错误） 13 SIGPIPE 向无读端的管道写数据时触发 14 SIGALRM 定时器超时，由 alarm() 触发 15 SIGTERM 终止信号，可被捕获和处理 17 SIGCHLD 子进程状态发生变化时通知父进程 18 SIGCONT 继续执行（与 SIGSTOP 配合使用） 19 SIGSTOP 停止进程，无法被捕获或忽略 20 SIGTSTP 终端暂停信号，通常由 Ctrl+Z 触发 21 SIGTTIN 后台进程尝试从终端读输入时触发 22 SIGTTOU 后台进程尝试往终端写输出时触发 23 SIGURG socket 上的紧急数据到达 24 SIGXCPU 超过 CPU 时间限制 25 SIGXFSZ 文件大小超过限制 26 SIGVTALRM 虚拟时钟超时 27 SIGPROF profiling 定时器超时 28 SIGWINCH 窗口大小发生变化（终端调整大小） 29 SIGIO / SIGPOLL 异步 I/O 事件 30 SIGPWR 电源故障 31 SIGSYS 非法系统调用 此外，Linux 还支持 实时信号（Real-Time Signals） ，编号从 32 开始 ，具体上限依赖于系统实现（通常是 SIGRTMIN 到 SIGRTMAX），通常是用于用户自定义的信号，应用程序可根据需要使用这些信号。</description>
    </item>
    <item>
      <title>Android 反调试攻防实战：多重检测手段解析与内核级绕过方案</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E5%A4%9A%E9%87%8D%E6%A3%80%E6%B5%8B%E6%89%8B%E6%AE%B5%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BB%95%E8%BF%87%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sun, 07 Sep 2025 00:04:03 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E5%A4%9A%E9%87%8D%E6%A3%80%E6%B5%8B%E6%89%8B%E6%AE%B5%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BB%95%E8%BF%87%E6%96%B9%E6%A1%88/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;常见的反调试手段 在 Android 安全对抗中，反调试 几乎是 App 的标配。开发者往往会在关键逻辑中加入各种检测手段，只要发现进程被调试，就立即崩溃或退出，从而大幅增加逆向人员分析的难度。&#xA;常见的反调试手段包括：&#xA;TracerPid 检测通过读取 /proc/self/status，如果 TracerPid 不为 0，就说明当前进程正被调试器（如 gdb、lldb、IDA Pro）附加。这是最常见的调试检测方式之一。&#xA;stat 检测通过 /proc/self/stat 可以获取进程的运行状态，如果发现状态异常（如被调试中），就会触发保护逻辑。&#xA;wchan 检测读取 /proc/self/wchan，检查线程当前在内核中的等待状态。如果检测到线程因调试而阻塞，就会触发异常处理。&#xA;1. TrackerId 首先，通过 IDA Pro 的调试器附加到当前 app 进程&#xA;相关文章：静态分析根本不够！IDA Pro 动态调试 Android 应用的完整实战&#xA;使用 top 命令查看进程状态&#xA;top | grep com.cyrus.example&#xD;17305 u0_a137 10 -10 4.8G 104M 42M t 0.0 1.8 0:02.02 com.cyrus.example 在输出中，S 表示进程状态，17305 是 PID。&#xA;通过head /proc/[pid]/status 可以查看详细的进程状态。&#xA;head -n 6 /proc/17305/status&#xD;Name: m.cyrus.example&#xD;State: S (sleeping)&#xD;Tgid: 17305&#xD;Pid: 17305&#xD;PPid: 728&#xD;TracerPid: 16208 TracerPid: 16208 说明当前的进程正在被进程 16208 调试或跟踪，否则没有被调试值应该为0。</description>
    </item>
    <item>
      <title>如何防止 so 文件被轻松逆向？精准控制符号导出 &#43; JNI 动态注册</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-so-%E6%96%87%E4%BB%B6%E8%A2%AB%E8%BD%BB%E6%9D%BE%E9%80%86%E5%90%91%E7%B2%BE%E5%87%86%E6%8E%A7%E5%88%B6%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA-&#43;-jni-%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/</link>
      <pubDate>Sat, 06 Sep 2025 23:03:17 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-so-%E6%96%87%E4%BB%B6%E8%A2%AB%E8%BD%BB%E6%9D%BE%E9%80%86%E5%90%91%E7%B2%BE%E5%87%86%E6%8E%A7%E5%88%B6%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA-&#43;-jni-%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 在使用 Android NDK 编译 so 文件 时，默认情况下，所有 public C/C++ 函数都会被导出 。这意味着无论函数是否真正需要对外使用，它们的符号表都会出现在 so 文件中。只要把 so 丢进 IDA、GHIDRA 等逆向工具 ，攻击者就能轻松看到完整的函数名列表，进而快速定位核心逻辑。&#xA;实际上，除了必须导出的 JNI 函数 外，其余大多数 C/C++ 函数根本不需要对外暴露。即便不导出，这些函数在 编译器/链接器内部依然可以正常调用 ，运行时也不会受到影响。换句话说，大量符号的默认导出既没有必要，还无形中增加了被逆向的风险。&#xA;必须导出的 JNI 函数：&#xA;函数名 是否必须导出 说明 JNI_OnLoad ✅ 是（总是） 系统通过 dlsym() 查找，初始化用 Java_&amp;hellip; ✅ 是（如果用静态注册） Java 层方法通过名称匹配 JNI_OnUnload ❌ 否（可选） 卸载时调用，不导出也不会出错 JNI_OnLoad_LibName（非标准） ❌ 否（特殊系统扩展） Android 未使用 JNI_GetCreatedJavaVMs、JNI_CreateJavaVM ❌ 否 仅在 native 启动 JVM 时使用（一般用不到） 因此，为了提升安全性，我们需要通过精细化控制导出符号，只保留最小必要的导出集 。这就是 linker version script 发挥作用的地方：它能让我们像“白名单”一样，只暴露需要的 JNI 接口，隐藏其他实现函数，从而显著提升逆向门槛。</description>
    </item>
    <item>
      <title>Linux 下配置 Clash 代理详细教程（解决乱码、自动脚本、直连配置）</title>
      <link>https://cyrus-studio.github.io/blog/posts/linux-%E4%B8%8B%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC%E7%9B%B4%E8%BF%9E%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Sep 2025 18:07:42 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/linux-%E4%B8%8B%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC%E7%9B%B4%E8%BF%9E%E9%85%8D%E7%BD%AE/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;1. 下载安装clash-verge 下载 clash-verge&#xA;https://github.com/clash-verge-rev/clash-verge-rev/releases&#xA;我这边用的是 ubuntu22，下载 clash-verge_1.7.5_amd64.deb&#xA;安装 clash-verge&#xA;# 安装相关依赖&#xD;sudo apt update&#xD;sudo apt install -f&#xD;sudo apt install libayatana-appindicator3-1 libwebkit2gtk-4.0-37 libgtk-3-0&#xD;# 安装clash-verge&#xD;sudo dpkg -i clash-verge_1.7.5_amd64.deb&#xD;# 卸载clash-verge&#xD;sudo dpkg -r clash-verge&#xD;# 启动 Clash Verge（nohup 命令可以让进程在后台运行，即使关闭终端也不会影响进程运行。）&#xD;# nohup 会创建一个 nohup.out 文件来记录输出日志。&#xD;nohup clash-verge &amp;amp; 2. 解决显示乱码问题 安装一些常见的字体包&#xA;sudo apt update&#xD;sudo apt install fonts-noto-cjk fonts-noto fonts-noto-core fonts-noto-ui-core fonts-wqy-zenhei 3. 导入订阅地址，开启代理 设置 关闭 IPV6 设置 勾选 系统代理</description>
    </item>
    <item>
      <title>C&amp;C&#43;&#43; 代码安全再升级：用 OLLVM 给 so 加上字符串加密保护</title>
      <link>https://cyrus-studio.github.io/blog/posts/cc&#43;&#43;-%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E5%86%8D%E5%8D%87%E7%BA%A7%E7%94%A8-ollvm-%E7%BB%99-so-%E5%8A%A0%E4%B8%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4/</link>
      <pubDate>Sun, 31 Aug 2025 05:18:27 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/cc&#43;&#43;-%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E5%86%8D%E5%8D%87%E7%BA%A7%E7%94%A8-ollvm-%E7%BB%99-so-%E5%8A%A0%E4%B8%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 在 Android 应用的 Native so 中，C/C++ 字符串是最容易泄露的弱点 。只要用 IDA、Ghidra 等逆向工具打开 so，明文字符串往往一览无余，核心逻辑、协议关键字、敏感信息都可能直接暴露。&#xA;这意味着，即使你对函数做了混淆，对控制流做了平坦化，只要字符串没保护，就等于把应用的秘密写在了明面上 。&#xA;解决办法：对字符串加密 。而基于 LLVM 的 OLLVM ，恰好提供了一个可扩展的平台，我们可以在编译过程中自动收集、加密、替换字符串，让 so 中不再出现明文常量。&#xA;本文将带你一步步实现：在 OLLVM 中增加一个 字符串加密 Pass ，并演示如何移植到 Android NDK 工程中实战应用。&#xA;字符串加密原理 OLLVM 字符串加密的原理 很简单：它在 编译阶段 对所有字符串常量做一次「改写」，程序运行时把密文恢复成明文。具体过程是：&#xA;收集 IR 中的字符串常量（例如 const char* str = &amp;ldquo;hello&amp;rdquo;;）；&#xA;在编译时使用自定义算法对字符串加密（常见做法是异或、移位或更复杂的算法）；&#xA;自动生成一个解密函数，在程序运行时把密文恢复成明文；&#xA;替换原本对字符串的引用，让代码使用解密后的结果。&#xA;这样一来，最终生成的 so 文件里就不再存放任何明文字符串，逆向工具看到的都是类似 &amp;amp;unk_* 的引用，只有在程序真正运行时，才会在内存里还原出可用的字符串 。这大大提升了逆向分析的难度。&#xA;LLVM IR 中的字符串 编写 C代码 sobf.c 如下：&#xA;#include &amp;lt;stdio.h&amp;gt;&#xD;int main() {&#xD;// 定义字符串常量&#xD;const char *greeting = &amp;#34;Hello, World!</description>
    </item>
    <item>
      <title>别让 so 裸奔！移植 OLLVM 到 NDK 并集成到 Android Studio</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%88%AB%E8%AE%A9-so-%E8%A3%B8%E5%A5%94%E7%A7%BB%E6%A4%8D-ollvm-%E5%88%B0-ndk-%E5%B9%B6%E9%9B%86%E6%88%90%E5%88%B0-android-studio/</link>
      <pubDate>Sun, 31 Aug 2025 04:01:37 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%88%AB%E8%AE%A9-so-%E8%A3%B8%E5%A5%94%E7%A7%BB%E6%A4%8D-ollvm-%E5%88%B0-ndk-%E5%B9%B6%E9%9B%86%E6%88%90%E5%88%B0-android-studio/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 在 Android 应用安全中，Native 层 so 库往往是最容易被逆向分析的目标 。无论是游戏的核心逻辑，还是 App 的关键算法，一旦 so 被反编译，核心代码就可能暴露无遗。&#xA;传统的 Java 层混淆工具（如 ProGuard、R8）对 C/C++ 代码无能为力，因此 NDK 层代码的保护 成了安全加固中的难点。解决思路：在编译阶段对 so 进行混淆处理 ，让逆向难度大幅提升。&#xA;LLVM 生态中有一个安全扩展 —— OLLVM (Obfuscator-LLVM) ，它在编译流程里插入了混淆 Pass，能对 C/C++ 代码做 控制流平坦化、虚假控制流、指令替换 等处理，从而显著增加逆向门槛。&#xA;本文将带你实战：如何将 OLLVM 移植到 LLVM/NDK，并在 Android Studio 工程中使用它，为 Native 代码加上一层混淆保护。&#xA;OLLVM、LLVM 与 Android NDK LLVM 是一个高度模块化的编译器框架，它能够将 C/C++ 等高级语言源码编译为中间表示（LLVM IR），再经过优化、生成目标机器码。它不仅仅是一个编译器，更是一个“编译基础设施”。&#xA;在 Android 平台上，自 NDK r18 开始，Google 就全面弃用了 GCC，转而采用 LLVM/Clang 作为官方工具链。也就是说，所有的 C/C++ 代码编译、优化、生成 so 库的过程，底层都是由 LLVM 驱动完成的。</description>
    </item>
    <item>
      <title>OLLVM 移植 LLVM18 踩坑：一步步调试修复控制流平坦化</title>
      <link>https://cyrus-studio.github.io/blog/posts/ollvm-%E7%A7%BB%E6%A4%8D-llvm18-%E8%B8%A9%E5%9D%91%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%B0%83%E8%AF%95%E4%BF%AE%E5%A4%8D%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/</link>
      <pubDate>Sun, 31 Aug 2025 03:14:05 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/ollvm-%E7%A7%BB%E6%A4%8D-llvm18-%E8%B8%A9%E5%9D%91%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%B0%83%E8%AF%95%E4%BF%AE%E5%A4%8D%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 把 OLLVM 移植到 LLVM18 后，发现 -fla（控制流平坦化）不能正常使用。&#xA;关于移植过程参考这篇文章：OLLVM 移植 LLVM 18 实战，轻松实现 C&amp;amp;C++ 代码混淆&#xA;测试代码 fla.c&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xD;int main(int argc, char** argv) {&#xD;int a = atoi(argv[1]);&#xD;if(a == 0)&#xD;return 1;&#xD;else&#xD;return 10;&#xD;return 0;&#xD;} 使用 clang 编译并启用 Control Flow Flattening（控制流平坦化）报错如下：&#xA;D:\Projects\llvm-project\build&amp;gt;clang -mllvm -fla fla.c -o fla.exe&#xD;[OLLVM] run.PipelineStartEPCallback&#xD;PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.</description>
    </item>
    <item>
      <title>OLLVM 移植 LLVM 18 实战，轻松实现 C&amp;C&#43;&#43; 代码混淆</title>
      <link>https://cyrus-studio.github.io/blog/posts/ollvm-%E7%A7%BB%E6%A4%8D-llvm-18-%E5%AE%9E%E6%88%98%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0-cc&#43;&#43;-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</link>
      <pubDate>Sun, 31 Aug 2025 02:21:25 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/ollvm-%E7%A7%BB%E6%A4%8D-llvm-18-%E5%AE%9E%E6%88%98%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0-cc&#43;&#43;-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;OLLVM 简介 OLLVM（Obfuscator-LLVM）是基于 LLVM 编译器框架 的一个开源扩展项目，主要用于程序代码混淆与保护。&#xA;OLLVM 基于 LLVM 的 Pass 插件机制 ，在优化环节增加 代码混淆功能 ，从而增加二进制程序的逆向难度。&#xA;常见的混淆手段包括：&#xA;控制流平坦化（Control Flow Flattening）：打乱程序的控制流结构，使其执行路径不再直观。&#xA;指令替换（Instruction Substitution）：将简单指令替换为等价的复杂指令序列。&#xA;伪控制流（Bogus Control Flow）：引入大量无用的分支或跳转，干扰逆向分析。&#xA;字符串加密：防止敏感字符串在二进制中被直接提取。&#xA;OLLVM 源码下载 OLLVM 项目地址：https://github.com/obfuscator-llvm/obfuscator&#xA;目前最新版本的是分支名为 llvm-4.0，基于 LLVM 团队发布的版本 4.0.1&#xA;下载 OLLVM 的 llvm-4.0 分支源码到本地&#xA;git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git 构建 OLLVM&#xA;mkdir build&#xD;cd build&#xD;cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/&#xD;make -j7 OLLVM 项目介绍 obfuscator/&#xD;│&#xD;├── include/llvm/Transforms/Obfuscation # 公共头文件目录&#xD;│ ├── BogusControlFlow.h # 虚假控制流头文件&#xD;│ ├── Flattening.</description>
    </item>
    <item>
      <title>LLVM 不止能编译！自定义 Pass &#43; 定制 clang 实现函数名加密</title>
      <link>https://cyrus-studio.github.io/blog/posts/llvm-%E4%B8%8D%E6%AD%A2%E8%83%BD%E7%BC%96%E8%AF%91%E8%87%AA%E5%AE%9A%E4%B9%89-pass-&#43;-%E5%AE%9A%E5%88%B6-clang-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%90%8D%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Sun, 31 Aug 2025 02:21:24 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/llvm-%E4%B8%8D%E6%AD%A2%E8%83%BD%E7%BC%96%E8%AF%91%E8%87%AA%E5%AE%9A%E4%B9%89-pass-&#43;-%E5%AE%9A%E5%88%B6-clang-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%90%8D%E5%8A%A0%E5%AF%86/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 LLVM 是一个编译器框架 ，用来把 C/C++ 源码编译成目标文件，似乎和日常的 GCC、Clang 没什么两样。事实上，LLVM 的能力远不止于此。&#xA;相关文章：LLVM 全面解析：NDK 为什么离不开它？如何亲手编译调试 clang&#xA;凭借它灵活的 中间表示（LLVM IR） 和强大的 Pass 插件机制 ，我们不仅能优化代码，还能在编译阶段对程序进行“改造”——比如 函数名加密、混淆、代码保护 ，让逆向工程变得更加困难。&#xA;本文带你从零开始，体验一次完整的 LLVM 定制之旅：&#xA;学习如何生成和操作 LLVM IR&#xA;使用 opt 和 CLion 调试 LLVM Pass&#xA;编写自定义 Pass，实现 函数名加密保护&#xA;最终定制 clang，让它自动加载我们的加密插件&#xA;1. LLVM IR 介绍 LLVM IR（Intermediate Representation，中间表示）是 LLVM 编译框架的核心。它是一种 介于高级语言（如 C/C++）与底层机器码之间的中间语言 ，既能表达高级语言的语义，又足够接近机器指令，便于优化和生成目标代码。&#xA;LLVM IR 的两种存储形式：&#xA;文本格式（.ll）：人类可读，方便分析和调试。&#xA;二进制格式（.bc）：Bitcode 文件，适合存储和传输。&#xA;LLVM IR 与具体 CPU 架构解耦，可以跨平台复用优化逻辑。&#xA;一个简单示例 （C 代码 → LLVM IR）：</description>
    </item>
    <item>
      <title>LLVM 全面解析：NDK 为什么离不开它？如何亲手编译调试 clang</title>
      <link>https://cyrus-studio.github.io/blog/posts/llvm-%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90ndk-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E4%B8%8D%E5%BC%80%E5%AE%83%E5%A6%82%E4%BD%95%E4%BA%B2%E6%89%8B%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95-clang/</link>
      <pubDate>Sun, 31 Aug 2025 02:21:24 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/llvm-%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90ndk-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E4%B8%8D%E5%BC%80%E5%AE%83%E5%A6%82%E4%BD%95%E4%BA%B2%E6%89%8B%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95-clang/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;1. LLVM 简介 LLVM（Low Level Virtual Machine）最初是一个编译器研究项目，如今已发展成一个模块化、可重用的编译器框架。&#xA;它包含前端（Frontend）、中间表示（IR, Intermediate Representation）、优化器（Optimizer）和后端（Backend, Code Generator）等组件。&#xA;开发者可以使用 LLVM 将高级语言源代码（如 C/C++、Rust、Swift 等）转换成中间表示，再经过优化和代码生成，最终编译为机器码。与传统编译器不同，LLVM 的设计高度模块化，方便扩展、优化和跨平台支持。&#xA;相关链接：&#xA;LLVM 官网：https://llvm.org/&#xA;Getting Started with LLVM Core Libraries（中文版）&#xA;LLVM Release 版本下载地址：https://github.com/llvm/llvm-project/releases&#xA;2. LLVM 与 Android NDK 的关系 在 Android NDK 中，我们通常用 C/C++ 编写性能敏感的模块，最终需要编译为运行在 ARM、ARM64、x86 等架构上的本地机器码。这个过程的核心就是 LLVM/Clang。&#xA;整个编译大致可以分为以下几个阶段：&#xA;C/C++ 源码 ↓ (Clang 前端) LLVM IR ↓ (LLVM 优化器) 优化后的 IR ↓ (LLVM 后端 CodeGen) 汇编 / 机器码 ↓ (链接器 lld) .</description>
    </item>
    <item>
      <title>静态分析神器 &#43; 动态调试利器：IDA Pro × Frida 混合调试实战</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%A5%9E%E5%99%A8-&#43;-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%88%A9%E5%99%A8ida-pro--frida-%E6%B7%B7%E5%90%88%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98/</link>
      <pubDate>Sat, 30 Aug 2025 14:45:24 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%A5%9E%E5%99%A8-&#43;-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%88%A9%E5%99%A8ida-pro--frida-%E6%B7%B7%E5%90%88%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 IDA Pro 作为静态分析神器，能快速反编译 so 库，展示清晰的函数结构和反汇编代码，但它对运行时行为却一无所知；而 Frida 能在设备上动态 Hook 任意函数，实时观察寄存器、参数、返回值。&#xA;把 Frida 直接集成进 IDA Pro！这样我们就能在 IDA 里调用 Frida API ，实时获取目标 App 中 so 的基址、动态执行状态，甚至一键启动 Trace。&#xA;1. 确认 IDA Pro 内置的 Python 版本 IDA Pro 自带 Python 解释器，不一定跟你系统 Python 一致。&#xA;在 IDA Python 控制台 （快捷键 Shift+F2）里输入：&#xA;import sys&#xD;print(sys.version)&#xD;print(sys.executable) 输出类似：&#xA;3.8.10 (tags/v3.8.10:3d8993a, May 3 2021, 11:48:03) [MSC v.1928 64 bit (AMD64)]&#xD;D:\App\IDA_Pro\IDA_Pro_7.7\ida64.exe 这里有两个关键信息：&#xA;IDA Pro 7.7 自带的是 Python 3.</description>
    </item>
    <item>
      <title>攻防 FART 脱壳：实现 AJM 壳级别的对抗功能 &#43; 绕过全解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%94%BB%E9%98%B2-fart-%E8%84%B1%E5%A3%B3%E5%AE%9E%E7%8E%B0-ajm-%E5%A3%B3%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AF%B9%E6%8A%97%E5%8A%9F%E8%83%BD-&#43;-%E7%BB%95%E8%BF%87%E5%85%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 30 Aug 2025 14:24:37 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%94%BB%E9%98%B2-fart-%E8%84%B1%E5%A3%B3%E5%AE%9E%E7%8E%B0-ajm-%E5%A3%B3%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AF%B9%E6%8A%97%E5%8A%9F%E8%83%BD-&#43;-%E7%BB%95%E8%BF%87%E5%85%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;实现类似 AJM 壳的 FART 对抗功能 某视频 app 的壳在启动的时候会检测 FART 特征，日志输出如下：&#xA;2025-05-29 02:16:25.612 2557-2557 ActivityThread cn.cntv E go into handleBindApplication&#xD;2025-05-29 02:16:25.630 2557-2557 cn.cntv cn.cntv I The ClassLoaderContext is a special shared library.&#xD;2025-05-29 02:16:25.807 1512-17245 ActivityManager system_process I Process cn.cntv (pid 2557) has died: fore TOP 2025-05-29 02:16:25.875 1512-1588 ActivityManager system_process I Start proc 2628:cn.cntv/u0a140 for top-activity {cn.cntv/com.cctv.mcctv.ui.activity.SplashActivity}&#xD;2025-05-29 02:16:25.932 2628-2628 ActivityThread cn.cntv E go into handleBindApplication&#xD;2025-05-29 02:16:25.</description>
    </item>
    <item>
      <title>静态分析根本不够！IDA Pro 动态调试 Android 应用的完整实战</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%A0%B9%E6%9C%AC%E4%B8%8D%E5%A4%9Fida-pro-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-android-%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AE%9E%E6%88%98/</link>
      <pubDate>Wed, 20 Aug 2025 17:09:14 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%A0%B9%E6%9C%AC%E4%B8%8D%E5%A4%9Fida-pro-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-android-%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AE%9E%E6%88%98/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;一、前言 在进行 Android 应用逆向分析时，很多时候仅靠静态分析（例如反编译 Java 代码或反汇编 so 库）是远远不够的。开发者常常会使用混淆、加壳、动态加载等技术，使得代码逻辑在静态视角下难以完整还原。此时，动态调试就显得尤为重要。&#xA;通过动态调试，我们可以在应用运行过程中实时观察其行为，例如：&#xA;精确跟踪函数调用过程&#xA;监控寄存器与内存的变化&#xA;分析加密/解密算法的输入与输出&#xA;定位并绕过反调试逻辑&#xA;IDA Pro 作为最常用的逆向分析工具之一，不仅提供强大的静态反编译能力，还支持配合 android_server 在 Android 设备上实现远程动态调试。这样，我们既能利用 IDA 的反编译界面理解代码结构，又能在实际执行过程中验证推测的逻辑，从而大大提升分析效率。&#xA;二、调试环境准备 必备工具：IDA Pro、adb、android_server&#xA;测试设备要求（已 root 的 Android 手机 / 模拟器）&#xA;手机 root 和 开启全局调试 参考：&#xA;小米刷机全攻略：解锁BL、刷机、Root 一步到位&#xA;Magisk 修改 ro.debuggable 开启 Android 系统全局调试模式&#xA;三、android_server 简介 android_server 是 IDA Pro 在 Android 设备上运行的远程调试服务端程序。&#xA;通过在设备上启动 android_server，IDA Pro 可以与 Android 应用建立调试会话，实现如下功能：&#xA;设置与管理断点&#xA;查看与修改内存&#xA;检查与操作寄存器&#xA;IDA Pro 与 android_server 之间的通信通常依赖 ADB（Android Debug Bridge） 。IDA Pro 将调试命令通过 ADB 转发至 android_server，后者在设备本地执行相应操作，并将结果回传给 IDA Pro，从而实现完整的远程调试流程。</description>
    </item>
    <item>
      <title>一文搞懂如何使用 Frida Hook Android App</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-frida-hook-android-app/</link>
      <pubDate>Wed, 20 Aug 2025 03:01:20 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-frida-hook-android-app/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Frida Frida 通过注入自定义 JavaScript 代码，可以 Hook 函数、修改参数、监控函数调用和拦截返回值，适用于逆向工程、调试和安全分析等场景。&#xA;使用 Frida 前需要先下载和安装包括：&#xA;Frida 是核心库，提供 API 和功能。&#xA;Frida-Tool 是命令行工具，通常与 Frida 版本相对应。&#xA;Frida-Server 是运行在 Android 设备上的服务器端组件，允许 Frida 客户端与设备进行通信。&#xA;环境准备 1. 安装 frida 和 frida-tools pip install frida-tools 2. frida server 获取设备CPU架构&#xA;adb shell getprop ro.product.cpu.abi 下载与设备对应架构的 frida-server：https://github.com/frida/frida/releases&#xA;把 frida-server 推送到设备 /data/local/tmp 目录下&#xA;adb push &amp;#34;D:\Python\anti-app\frida-server\frida-server-14.0.0-android-arm64&amp;#34; /data/local/tmp/fs 启动 frida-server&#xA;# 启用超级管理员&#xD;adb root&#xD;# 进入命令行&#xD;adb shell # 添加可执行权限&#xD;chmod +x /data/local/tmp/fs&#xD;# 启动frida-server&#xD;/data/local/tmp/fs 3.</description>
    </item>
    <item>
      <title>别再手工写 Hook 了！Python &#43; Frida 一网打尽 SO 层动态注册 JNI 调用</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%88%AB%E5%86%8D%E6%89%8B%E5%B7%A5%E5%86%99-hook-%E4%BA%86python-&#43;-frida-%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD-so-%E5%B1%82%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C-jni-%E8%B0%83%E7%94%A8/</link>
      <pubDate>Sat, 16 Aug 2025 18:04:56 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%88%AB%E5%86%8D%E6%89%8B%E5%B7%A5%E5%86%99-hook-%E4%BA%86python-&#43;-frida-%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD-so-%E5%B1%82%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C-jni-%E8%B0%83%E7%94%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 很多 Android 应用会把核心逻辑都写在 SO 层，并通过 RegisterNatives 动态注册 JNI 方法，把 Java 层的 native 方法和真实的 C/C++ 函数地址在运行时绑定。&#xA;通过这样 隐藏真实函数名和地址 ，增加逆向难度。&#xA;虽然我们可以 Hook RegisterNatives 拿到所有 JNI 绑定信息，但是：&#xA;函数数量巨大：可能有上百上千个 JNI 方法。&#xA;调用路径未知：不知道哪些函数会被实际调用。&#xA;手动 Hook 成本高：一个个写 Frida Hook 既耗时又容易漏掉。&#xA;如何一次性 Hook 所有动态注册函数 ，并且自动解析参数、记录调用日志？&#xA;目标 用一份 Python 脚本 + Frida 实现：&#xA;Hook RegisterNatives 导出 JNI 绑定信息到 register_natives.txt&#xA;自动解析 register_natives.txt 文件，提取所有 JNI 绑定信息。&#xA;自动生成完整的 Frida Hook 脚本，一次性 Hook 所有动态注册函数 。&#xA;支持自动类型识别、参数打印，并将日志直接保存到文件。&#xA;只需要一次运行，就能一网打尽 SO 层所有动态注册的 JNI 调用。</description>
    </item>
    <item>
      <title>如何实现 Android App 的抓包防护？又该如何绕过？一文看懂攻防博弈</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-android-app-%E7%9A%84%E6%8A%93%E5%8C%85%E9%98%B2%E6%8A%A4%E5%8F%88%E8%AF%A5%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E6%94%BB%E9%98%B2%E5%8D%9A%E5%BC%88/</link>
      <pubDate>Fri, 15 Aug 2025 15:50:56 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-android-app-%E7%9A%84%E6%8A%93%E5%8C%85%E9%98%B2%E6%8A%A4%E5%8F%88%E8%AF%A5%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E6%94%BB%E9%98%B2%E5%8D%9A%E5%BC%88/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Android 下常见反抓包方案 常见反抓包手段：&#xA;No Proxy（禁用代理）&#xA;启用 HTTPS + SSL Pinning&#xA;使用 DNS-over-HTTPS / DoT（隐藏 DNS 请求）&#xA;检查系统代理（Java 层检查 System.getProperty(&amp;ldquo;http.proxyHost&amp;rdquo;)）&#xA;检测 VPN 或 adb 代理&#xA;使用 native 层自己实现网络请求（绕过 Java 层）&#xA;证书双向校验&#xA;No Proxy（无代理模式） 所谓 “无代理模式” 实际上是通过主动避免走系统代理，从而规避传统的中间人抓包。&#xA;设置 OkHttp 不使用系统代理，直接访问服务器：&#xA;val client = OkHttpClient.Builder()&#xD;.proxy(Proxy.NO_PROXY) // 禁用系统代理&#xD;.build() 设置 NO_PROXY 后，Charles 并没有抓取到 httpbin.org 相关请求&#xA;App 中请求 httpbin.org 正常&#xA;通过 VPN 绕过 No Proxy 如果使用 VPN 或全局代理，NO_PROXY 也无法绕过抓包。比如，通过第三方代理应用 Drony 强制 APP 走代理。</description>
    </item>
    <item>
      <title>深入内核交互：用 strace 看清 Android 每一个系统调用</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E5%86%85%E6%A0%B8%E4%BA%A4%E4%BA%92%E7%94%A8-strace-%E7%9C%8B%E6%B8%85-android-%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Tue, 12 Aug 2025 23:55:08 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E5%86%85%E6%A0%B8%E4%BA%A4%E4%BA%92%E7%94%A8-strace-%E7%9C%8B%E6%B8%85-android-%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;strace 介绍 strace 是 Linux 下用于跟踪一个程序在运行时所发生的 系统调用（system calls） 和 信号（signals） 的调试工具。&#xA;它可以快速了解程序与内核之间的交互，是定位程序异常、分析行为、逆向工程等场景中的利器。&#xA;相关链接：&#xA;strace 官网：https://strace.io/&#xA;strace 开源地址：https://github.com/strace/strace&#xA;Android 使用 strace：https://source.android.com/docs/core/tests/debug/strace?hl=zh-cn&#xA;Android 下使用 strace 在 Android 下使用 strace 的方式与 Linux 类似，但会受到 系统版本、SELinux、权限限制、是否 root 等因素的影响。&#xA;在 Android 设备上启用 strace 跟踪能力：&#xA;启用 root 权限&#xA;停用 SELinux&#xA;重新启动 ART 以移除 seccomp 过滤器，否则此过滤器会阻止 strace 运行&#xA;让 ADB 服务以 root 权限运行，这是使用 strace 的前提。&#xA;adb root 关闭 SELinux 强制模式，变为宽松模式（permissive）：&#xA;adb shell setenforce 0 默认是 enforcing，会拦截一些 ptrace 和文件访问行为。</description>
    </item>
    <item>
      <title>一文搞懂 SO 脱壳全流程：识别加壳、Frida Dump、原理深入解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-so-%E8%84%B1%E5%A3%B3%E5%85%A8%E6%B5%81%E7%A8%8B%E8%AF%86%E5%88%AB%E5%8A%A0%E5%A3%B3frida-dump%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 12 Aug 2025 00:44:56 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-so-%E8%84%B1%E5%A3%B3%E5%85%A8%E6%B5%81%E7%A8%8B%E8%AF%86%E5%88%AB%E5%8A%A0%E5%A3%B3frida-dump%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;如何快速判断 SO 是否加壳 使用 IDA 打开 so 提示无法正确识别 ELF 文件结构。&#xA;section 定义无效或不符合预期格式。&#xA;有很多红色的汇编代码块，表示错误或者未能正常解析的地址/数据&#xA;这通常就是 so 可能被“混淆”、“裁剪”或“加壳”了。&#xA;Frida Dump 脱壳实战 frida_dump 是基于 frida 的 so 和 dex 的脱壳工具。&#xA;开源地址：https://github.com/lasting-yang/frida_dump&#xA;关于 Frida 的使用参考：一文搞懂如何使用 Frida Hook Android App&#xA;先把 frida_dump 源码 clone 到本地。&#xA;如果使用的是远程链接，把 dump_so.py 中的&#xA;device: frida.core.Device = frida.get_usb_device() 改成&#xA;device = frida.get_device_manager().add_remote_device(&amp;#34;127.0.0.1:1234&amp;#34;) 比如目标 so 是 libGameVMP.so，通过下面命令执行 dump_so.py&#xA;python dump_so.py libGameVMP.so 输出如下：&#xA;(anti-app) PS D:\Python\anti-app\frida_dump&amp;gt; python dump_so.py libGameVMP.so&#xD;{&amp;#39;name&amp;#39;: &amp;#39;libGameVMP.so&amp;#39;, &amp;#39;base&amp;#39;: &amp;#39;0x7bd7b81000&amp;#39;, &amp;#39;size&amp;#39;: 462848, &amp;#39;path&amp;#39;: &amp;#39;/data/app/com.</description>
    </item>
    <item>
      <title>用 Dex2C 把 Java 变 Native：Android 代码加固全攻略</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%94%A8-dex2c-%E6%8A%8A-java-%E5%8F%98-nativeandroid-%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%9B%BA%E5%85%A8%E6%94%BB%E7%95%A5/</link>
      <pubDate>Tue, 12 Aug 2025 00:25:39 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%94%A8-dex2c-%E6%8A%8A-java-%E5%8F%98-nativeandroid-%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%9B%BA%E5%85%A8%E6%94%BB%E7%95%A5/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Dex2C 介绍 Dex2C 是一个将 Android 应用中的 DEX 字节码（Java 层代码）转换为语义等效的 C 代码的工具。&#xA;经过 Dex2C 处理后，Java 方法就变成 Native 层的方法了，从而实现源码隐藏保护。&#xA;java 代码：&#xA;object AESUtils {&#xD;// 将普通字符串转换为 IvParameterSpec&#xD;private fun stringToIV(iv: String): IvParameterSpec {&#xD;// 通过 UTF-8 编码将字符串转为字节数组，确保其长度为 16 字节&#xD;val ivBytes = iv.toByteArray(Charsets.UTF_8)&#xD;val ivArray = ByteArray(16)&#xD;System.arraycopy(ivBytes, 0, ivArray, 0, Math.min(ivBytes.size, 16))&#xD;return IvParameterSpec(ivArray)&#xD;}&#xD;} 转换后的 C/C++ 代码：&#xA;#include &amp;#34;Dex2C.h&amp;#34;&#xD;/* LAESUtils;-&amp;gt;stringToIV(Ljava/lang/String;)Ljavax/crypto/spec/IvParameterSpec; */&#xD;extern &amp;#34;C&amp;#34; JNIEXPORT jobject&#xD;JNICALL Java_AESUtils_stringToIV__Ljava_lang_String_2(JNIEnv *env, jobject thiz, jstring p4) {&#xD;jobject v0 = NULL;&#xD;jobject v1 = NULL;&#xD;jobject v2 = NULL;&#xD;jobject v3 = NULL;&#xD;jint v4;&#xD;jobject v5 = NULL;&#xD;jint v6;&#xD;jint v7;&#xD;jclass cls0 = NULL, cls1 = NULL, cls2 = NULL, cls3 = NULL, cls4 = NULL, cls5 = NULL, cls6 = NULL;&#xD;jfieldID fld0 = NULL;&#xD;jmethodID mth0 = NULL, mth1 = NULL, mth2 = NULL, mth3 = NULL, mth4 = NULL;&#xD;v0 = (jobject)&#xD;env-&amp;gt;NewLocalRef(thiz);&#xD;v1 = (jobject)&#xD;env-&amp;gt;NewLocalRef(p4);&#xD;L0:&#xD;LOGD(&amp;#34;0:sget-object \x76\x30\x2c\x20\x4c\x6b\x6f\x74\x6c\x69\x6e\x2f\x74\x65\x78\x74\x2f\x43\x68\x61\x72\x73\x65\x74\x73\x3b\x2d\x3e\x55\x54\x46\x5f\x38\x20\x4c\x6a\x61\x76\x61\x2f\x6e\x69\x6f\x2f\x63\x68\x61\x72\x73\x65\x74\x2f\x43\x68\x61\x72\x73\x65\x74\x3b&amp;#34;);&#xD;{&#xD;#define EX_HANDLE EX_UnwindBlock&#xD;if (v2) {&#xD;LOGD(&amp;#34;env-&amp;gt;DeleteLocalRef(%p):v2&amp;#34;, v2);&#xD;env-&amp;gt;DeleteLocalRef(v2);&#xD;}&#xD;jclass &amp;amp;clz = cls0;&#xD;jfieldID &amp;amp;fld = fld0;&#xD;D2C_RESOLVE_STATIC_FIELD(clz, fld, &amp;#34;kotlin/text/Charsets&amp;#34;, &amp;#34;UTF_8&amp;#34;, &amp;#34;Ljava/nio/charset/Charset;&amp;#34;);&#xD;v2 = (jobject)&#xD;env-&amp;gt;GetStaticObjectField(clz, fld);&#xD;D2C_CHECK_PENDING_EX;&#xD;#undef EX_HANDLE&#xD;}&#xD;LOGD(&amp;#34;4:invoke-virtual \x76\x34\x2c\x20\x76\x30\x2c\x20\x4c\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\x53\x74\x72\x69\x6e\x67\x3b\x2d\x3e\x67\x65\x74\x42\x79\x74\x65\x73\x28\x4c\x6a\x61\x76\x61\x2f\x6e\x69\x6f\x2f\x63\x68\x61\x72\x73\x65\x74\x2f\x43\x68\x61\x72\x73\x65\x74\x3b\x29\x5b\x42&amp;#34;);&#xD;{&#xD;#define EX_HANDLE EX_UnwindBlock&#xD;D2C_NOT_NULL(v1);&#xD;jclass &amp;amp;clz = cls1;&#xD;jmethodID &amp;amp;mid = mth0;&#xD;D2C_RESOLVE_METHOD(clz, mid, &amp;#34;java/lang/String&amp;#34;, &amp;#34;getBytes&amp;#34;, &amp;#34;(Ljava/nio/charset/Charset;)[B&amp;#34;);&#xD;jvalue args[] = {{.</description>
    </item>
    <item>
      <title>FART 脱壳某大厂 App &#43; CodeItem 修复 dex &#43; 反编译还原源码</title>
      <link>https://cyrus-studio.github.io/blog/posts/fart-%E8%84%B1%E5%A3%B3%E6%9F%90%E5%A4%A7%E5%8E%82-app-&#43;-codeitem-%E4%BF%AE%E5%A4%8D-dex-&#43;-%E5%8F%8D%E7%BC%96%E8%AF%91%E8%BF%98%E5%8E%9F%E6%BA%90%E7%A0%81/</link>
      <pubDate>Tue, 12 Aug 2025 00:15:18 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/fart-%E8%84%B1%E5%A3%B3%E6%9F%90%E5%A4%A7%E5%8E%82-app-&#43;-codeitem-%E4%BF%AE%E5%A4%8D-dex-&#43;-%E5%8F%8D%E7%BC%96%E8%AF%91%E8%BF%98%E5%8E%9F%E6%BA%90%E7%A0%81/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;FART 脱壳 fartthread 方法在 app 启动的时候（ActivityThread）开启 fart 线程，休眠 60 秒，等待 app 启动完成后自动开始遍历 ClassLoader 的 类列表，发起主动调用。&#xA;FART 脱壳结束得到的文件列表（分 Execute 与 主动调用两类）：&#xA;Execute 脱壳点得到的 dex (*_dex_file_execute.dex）和 dex 中的所有类列表（ txt 文件）&#xA;主动调用时 dump 得到的 dex (*_dex_file.dex）和此时 dex 中的所有类列表，以及该 dex 中所有函数的 CodeItem（ bin 文件）&#xA;wayne:/data/data/com.cyrus.example/cyrus # ls&#xD;1321896_class_list.txt 1437648_dex_file_execute.dex 1488168_class_list_execute.txt 1605504_ins_4714.bin&#xD;1321896_class_list_execute.txt 1437648_ins_4714.bin 1488168_dex_file.dex 198768_class_list.txt&#xD;1321896_dex_file.dex 1448488_class_list.txt 1488168_dex_file_execute.dex 198768_class_list_execute.txt&#xD;1321896_dex_file_execute.dex 1448488_class_list_execute.txt 1488168_ins_4714.bin 198768_dex_file.dex&#xD;1321896_ins_4714.bin 1448488_dex_file.dex 1496608_class_list.txt 198768_dex_file_execute.dex&#xD;1351008_class_list.txt 1448488_dex_file_execute.dex 1496608_class_list_execute.txt 198768_ins_4714.bin&#xD;1351008_class_list_execute.txt 1448488_ins_4714.</description>
    </item>
    <item>
      <title>FART 脱壳不再全量！用一份配置文件精准控制节奏与范围</title>
      <link>https://cyrus-studio.github.io/blog/posts/fart-%E8%84%B1%E5%A3%B3%E4%B8%8D%E5%86%8D%E5%85%A8%E9%87%8F%E7%94%A8%E4%B8%80%E4%BB%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B2%BE%E5%87%86%E6%8E%A7%E5%88%B6%E8%8A%82%E5%A5%8F%E4%B8%8E%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Mon, 11 Aug 2025 21:04:48 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/fart-%E8%84%B1%E5%A3%B3%E4%B8%8D%E5%86%8D%E5%85%A8%E9%87%8F%E7%94%A8%E4%B8%80%E4%BB%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B2%BE%E5%87%86%E6%8E%A7%E5%88%B6%E8%8A%82%E5%A5%8F%E4%B8%8E%E8%8C%83%E5%9B%B4/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 FART 在默认模式下会对所有 App 执行全量脱壳：&#xA;每次 App 启动都会自动触发脱壳&#xA;对 App 内所有类进行主动调用&#xA;这种“全覆盖”方式虽然简单粗暴，但效率低、启动时间长，且无法跳过针对 FART 的对抗类，甚至会被无意义的垃圾类拖慢进程。&#xA;如果能通过一份简单的配置文件 ，就能精准控制 FART 的脱壳过程——包括是否启用脱壳、延迟启动时间、指定需要主动调用的类、排除特定类规则等。不仅能显著提升脱壳效率，还能有效规避对抗类带来的干扰，让 FART 更加灵活、可控。&#xA;FART 相关文章：&#xA;干掉抽取壳！FART 自动化脱壳框架与 Execute 脱壳点解析&#xA;FART 主动调用组件深度解析：破解 ART 下函数抽取壳的终极武器&#xA;一步步带你移植 FART 到 Android 10，实现自动化脱壳&#xA;FART 自动化脱壳框架优化实战：Bug 修复与代码改进记录&#xA;Frida + FART 联手：解锁更强大的 Android 脱壳新姿势&#xA;一、配置驱动的精准脱壳方案 1. 配置文件的设计思路与格式（包含排除规则与白名单机制） 例如，配置项如下：&#xA;# 是否开启脱壳功能（true 开启，false 关闭）&#xD;dump=true&#xD;# 启动后延迟多少毫秒再进行脱壳（单位：毫秒），避免应用初始化未完成&#xD;sleep=60000&#xD;# 明确指定哪些类名或包路径需要主动调用以触发加载（支持通配符 *）&#xD;# 示例：ff.l0.* 表示 ff.l0 包下所有类&#xD;force=ff.l0.*&#xD;# 忽略哪些类或包路径（支持通配符 *）&#xD;# 通常用于排除系统类、常见库类、FART对抗类等&#xD;ignore=androidx.</description>
    </item>
    <item>
      <title>FART 自动化脱壳框架优化实战：Bug 修复与代码改进记录</title>
      <link>https://cyrus-studio.github.io/blog/posts/fart-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98bug-%E4%BF%AE%E5%A4%8D%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 11 Aug 2025 20:37:27 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/fart-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98bug-%E4%BF%AE%E5%A4%8D%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B%E8%AE%B0%E5%BD%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;open() 判断不严谨导致 dex 重复 dump 源码：https://github.com/CYRUS-STUDIO/FART/blob/master/fart10/art/runtime/art_method.cc&#xA;比如：&#xA;int dexfilefp = open(dex_path.c_str(), O_RDONLY);&#xD;if (dexfilefp &amp;gt; 0) {&#xD;close(dexfilefp);&#xD;} 这个判断条件其实是不严谨的，导致 if 中 的 close(dexfilefp); 一直没有执行，dex 会重复 dump。&#xA;open() 的返回值语义是：&#xA;成功时：返回一个非负整数（即 &amp;gt;= 0），它是打开的文件描述符。&#xA;失败时：返回 -1&#xA;正确的判断方式应该是：&#xA;if (fp &amp;gt;= 0) {&#xD;// 成功打开&#xD;} else {&#xD;// 打开失败，打印错误信息&#xD;LOG(ERROR) &amp;lt;&amp;lt; &amp;#34;open dex file failed&amp;#34;;&#xD;} 减少不必要的 I/O，提高 dump 成功率。&#xA;dump 目录创建失败（mkdir failed errno: 13） FART 中通过 mkdir 函数在 sdcard 上创建 dump 文件存放目录，但是这样必须 app 拥有存储卡读写权限。不然 mkdir 会执行失败。</description>
    </item>
    <item>
      <title>Frida &#43; FART 联手：解锁更强大的 Android 脱壳新姿势</title>
      <link>https://cyrus-studio.github.io/blog/posts/frida-&#43;-fart-%E8%81%94%E6%89%8B%E8%A7%A3%E9%94%81%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84-android-%E8%84%B1%E5%A3%B3%E6%96%B0%E5%A7%BF%E5%8A%BF/</link>
      <pubDate>Mon, 11 Aug 2025 20:37:27 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/frida-&#43;-fart-%E8%81%94%E6%89%8B%E8%A7%A3%E9%94%81%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84-android-%E8%84%B1%E5%A3%B3%E6%96%B0%E5%A7%BF%E5%8A%BF/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Frida + FART 联手能带来什么提升？ 增强 FART 的脱壳能力：解决对抗 FART 的壳、动态加载的 dex 的 dump 和修复；&#xA;控制 FART 主动调用的范围，让 FART 更精细化，比如按需进行类甚至是函数的修复。&#xA;非双亲委派关系下动态加载的 dex 脱壳问题 由于动态加载的 dex 没有取改变 android 中 ClassLoader 双亲委派关系，所以动态加载的 dex 没有自动脱壳。&#xA;相关文章：&#xA;深入理解 Android ClassLoader 与双亲委派机制&#xA;深入剖析 Android 加壳应用运行流程与生命周期劫持方案&#xA;在 android studio 中创建一个 plugin module 其中包含一个 FartTest 类源码如下：&#xA;package com.cyrus.example.plugin&#xD;import android.util.Log&#xD;class FartTest {&#xD;fun test(): String {&#xD;Log.d(&amp;#34;FartTest&amp;#34;, &amp;#34;call FartTest test().&amp;#34;)&#xD;return &amp;#34;String from FartTest.&amp;#34;&#xD;}&#xD;} 把 plugin-debug.</description>
    </item>
    <item>
      <title>一步步带你移植 FART 到 Android 10，实现自动化脱壳</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%B8%A6%E4%BD%A0%E7%A7%BB%E6%A4%8D-fart-%E5%88%B0-android-10%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3/</link>
      <pubDate>Mon, 11 Aug 2025 18:54:30 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%B8%A6%E4%BD%A0%E7%A7%BB%E6%A4%8D-fart-%E5%88%B0-android-10%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;FART 源码 FART 是一种基于主动调用的自动化脱壳方案，能够在 ART 虚拟机的执行流程中精准捕获并还原被抽空的函数，实现对被加固的 dex 文件整体 dump。&#xA;FART 相关链接：&#xA;干掉抽取壳！FART 自动化脱壳框架与 Execute 脱壳点解析&#xA;FART 主动调用组件深度解析：破解 ART 下函数抽取壳的终极武器&#xA;FART 开源地址：https://github.com/hanbinglengyue/FART&#xA;目前 FART 是基于 Android 6.0 实现，源码文件结构如下：&#xA;这里以把 FART 源码移植到 LineageOS 17.1（Android 10）为例。&#xA;LineageOS 源码的下载、编译、签名参考：&#xA;解决90%踩坑问题！LineageOS 源码下载与编译保姆级教程&#xA;教你签自己的系统！LineageOS Release Key 签名刷机教程&#xA;移植 FART 到 Android 10 对比 android 6.0 中的源码和 FART 的源码找到修改的地方并移植到 Android 10 源码中&#xA;interpreter.cc 路径：art/runtime/interpreter/interpreter.cc&#xA;Android 6.0 源码：https://cs.android.com/android/platform/superproject/+/android-6.0.0_r1:art/runtime/interpreter/interpreter.cc&#xA;namespace art 中增加 dumpDexFileByExecute 函数声明&#xA;//add&#xD;extern &amp;#34;C&amp;#34; void dumpDexFileByExecute(ArtMethod* artmethod); 在 Execute 函数头部增加 dumpDexFileByExecute 调用</description>
    </item>
    <item>
      <title>干掉抽取壳！FART 自动化脱壳框架与 Execute 脱壳点解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%B9%B2%E6%8E%89%E6%8A%BD%E5%8F%96%E5%A3%B3fart-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3%E6%A1%86%E6%9E%B6%E4%B8%8E-execute-%E8%84%B1%E5%A3%B3%E7%82%B9%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 11 Aug 2025 03:58:22 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%B9%B2%E6%8E%89%E6%8A%BD%E5%8F%96%E5%A3%B3fart-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%B1%E5%A3%B3%E6%A1%86%E6%9E%B6%E4%B8%8E-execute-%E8%84%B1%E5%A3%B3%E7%82%B9%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;FART 简介 在 Android ART 环境中，市面上一些加固方案会通过“函数抽取壳”将应用的核心逻辑剥离，运行时再动态加载执行，从而增加逆向分析的难度。&#xA;FART 是一种基于主动调用的自动化脱壳方案，能够在 ART 虚拟机的执行流程中精准捕获并还原这些被抽空的函数，实现对被加固的 dex 文件整体 dump。&#xA;项目地址：https://github.com/hanbinglengyue/FART&#xA;函数抽取壳的实现原理：打造基于 ART 的 Android 函数抽取壳：原理剖析与完整源码实战&#xA;FART 框架 FART 框架的 3 大组件：&#xA;脱壳组件：将内存中的 Dex 数据完整 dump 出来&#xA;主动调用组件：构造主动调用链，完成对函数粒度的主动调用并完成 CodeItem 的 dump&#xA;修复组件：利用脱壳组件得到的 dex 和主动调用 dump 下来的函数体，完成函数粒度的修复&#xA;FART 中的脱壳点 其中 FART 脱壳组件 选择 Execute 作为脱壳点，它是 Interpreter 模式执行所有 Java 方法的统一入口，能够稳定截获和提取所有解释执行的真实方法，从而达到通用脱壳的目的。&#xA;ART 下函数在运行时可能是解释执行（Interpreter 模式）或编译执行（Quick 模式）。&#xA;为何选择 Execute 作为脱壳点？这就需要先搞懂 dex2oat 编译与 ART 函数调用流程。&#xA;dex2oat 编译流程 dex2oat 编译流程入口函数：&#xA;int main(int argc, char** argv) {&#xD;int result = static_cast&amp;lt;int&amp;gt;(art::Dex2oat(argc, argv));&#xD;// Everything was done, do an explicit exit here to avoid running Runtime destructors that take&#xD;// time (bug 10645725) unless we&amp;#39;re a debug or instrumented build or running on a memory tool.</description>
    </item>
    <item>
      <title>FART 主动调用组件深度解析：破解 ART 下函数抽取壳的终极武器</title>
      <link>https://cyrus-studio.github.io/blog/posts/fart-%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E7%A0%B4%E8%A7%A3-art-%E4%B8%8B%E5%87%BD%E6%95%B0%E6%8A%BD%E5%8F%96%E5%A3%B3%E7%9A%84%E7%BB%88%E6%9E%81%E6%AD%A6%E5%99%A8/</link>
      <pubDate>Mon, 11 Aug 2025 03:50:29 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/fart-%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E7%A0%B4%E8%A7%A3-art-%E4%B8%8B%E5%87%BD%E6%95%B0%E6%8A%BD%E5%8F%96%E5%A3%B3%E7%9A%84%E7%BB%88%E6%9E%81%E6%AD%A6%E5%99%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;FART 的主动调用组件 在 Android 逆向与脱壳领域，早期的自动化脱壳方案（如 DexHunter、FUPK3）主要运行在 Dalvik 环境，并将脱壳粒度细化到函数级别，这一突破首次对抗了函数抽取壳的加固策略。然而，随着 ART 运行时逐渐取代 Dalvik，这些方案在新环境下已无法直接应用。&#xA;另一方面，现有的主流脱壳方法多停留在 DexFile 整体粒度 ，而 APK 加固的防护粒度却已经下沉到 单个函数级别 ，造成了脱壳与加固之间的“不对等”对抗局面，无法应对函数粒度的加固保护。&#xA;FART 的主动调用组件 正是在这一背景下诞生的核心模块，为解决函数抽取壳在 ART 下的修复问题提供了可行且高效的方案。&#xA;主动调用相关概念 1. 被动调用 指 app 正常运行过程中发生的调用，该过程只对 dex 中部分的类完成了加载，同时也只是对 dex 中的部分函数完成了调用。&#xA;2. 主动调用 通过构造虚拟调用，从而达到欺骗 “壳” ，让壳误以为 app 在执行正常的函数调用流程从而达成对 dex 中所有类函数的虚拟调用。&#xA;3. 为何需要主动调用？ 被动调用也可以用来完成函数粒度的修复。如当前通过正常运行 app ，待 app 将 dex 中的类正常加载并完成相关的函数的正常调用后再进行 dex 的 dump 的脱壳方法。&#xA;被动调用脱壳的缺点： 存在修复函数不全的问题。由于测试用例无法覆盖 dex 中所有的函数，导致代码覆盖率低，只能对 app 运行过程中调用过的函数的修复。&#xA;主动调用的优点： 能够覆盖 dex 中所有的函数，从而完成更彻底的函数粒度的修复。同时，函数的修复准确度同主动调用链的构造深度有关。&#xA;FART 中要解决的三个问题 如何构造主动调用链并让每一个函数都到达主动调用过程，但是又不影响 app 的正常运行？</description>
    </item>
    <item>
      <title>深入解析 dex2oat：vdex、cdex、dex 格式转换全流程实战</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-dex2oatvdexcdexdex-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%85%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E6%88%98/</link>
      <pubDate>Mon, 11 Aug 2025 03:12:08 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-dex2oatvdexcdexdex-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%85%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E6%88%98/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;dex2oat dex2oat 是 Android 系统中的一个核心工具，负责将应用中的 .dex（Dalvik Executable）字节码编译为本地机器代码（native code），以提高运行效率。它的全称是 DEX to OAT（Optimized Android Transport）。&#xA;dex2oat 的作用 在 Android 系统中，Java/Kotlin 编写的应用在编译时会被转换为 .dex 文件。为了提高性能，Android 会将 .dex 文件进一步编译为 .oat 文件（或 .odex/.vdex 文件），以便设备可以直接执行本地代码而不是解释执行 .dex 字节码。&#xA;工作原理（简要流程） 输入：一个或多个 .dex 文件（通常来自 APK 中的 classes.dex）。&#xA;输出：生成 .oat（Optimized Android Executable）、.vdex（Verified DEX）和 .art（Android Runtime）文件。&#xA;过程：&#xA;验证并优化 .dex。&#xA;使用 AOT（Ahead-Of-Time）方式将 .dex 转为本地机器码。&#xA;生成平台相关的可执行文件，用于加快应用启动速度。&#xA;编译模式：&#xA;AOT（Ahead-Of-Time）：安装或开机前就编译好，提高运行速度。&#xA;JIT（Just-In-Time）：运行时动态编译，节省空间但牺牲性能。&#xA;Hybrid（混合）：Android 7.0+ 默认模式，结合 AOT 与 JIT。&#xA;执行时机 第一次开机：系统会对预装的应用使用 dex2oat 编译。&#xA;App 安装时：根据编译策略（speed, quicken, interpret-only 等）选择是否编译。</description>
    </item>
    <item>
      <title>基于 Python &#43; K-Means 的自动化视频分类实战</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8E-python-&#43;-k-means-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/</link>
      <pubDate>Mon, 11 Aug 2025 00:50:47 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8E-python-&#43;-k-means-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB%E5%AE%9E%E6%88%98/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;实现过程 特征提取：使用预训练的 InceptionV3 模型，从视频的若干帧中提取高维的视觉特征。将每个视频的所有帧特征取平均值，生成一个固定长度的特征向量来表示该视频。&#xA;聚类：通过 K-Means 的聚类结果，每个视频被分配了一个簇标签，代表该视频与哪些视频在特征上最相似。&#xA;分类整理：最后根据簇标签，将视频移动到相应的分类文件夹中，每个文件夹对应一个簇。&#xA;InceptionV3 模型 InceptionV3 是一种用于图像分类和特征提取的深度学习模型，它是Inception 系列模型的第三个版本，由 Google 在 2015 年提出。&#xA;它最初是作为图像分类任务的一个模型，能够将图像分类到 1000 个类别中（如狗、猫、汽车等）。通过去除模型的最后几层（分类部分），可以将 InceptionV3 用作特征提取器。&#xA;簇 簇是聚类算法的核心概念，表示数据中相似的子集，目的是将无标签的数据点分组。&#xA;K-Means K-Means 是一种常用的无监督聚类算法，它的目标是将数据点分成 K 个簇（Cluster），使得每个簇内的数据点尽可能接近同一个中心（即簇的质心）。&#xA;算法的核心思想是通过迭代的方式找到 K 个最优的簇质心，并根据这些质心将数据进行分组。&#xA;源码 1. 安装依赖库 pip install moviepy scikit-learn tensorflow opencv-python 2. 实现代码 import os&#xD;import numpy as np&#xD;import cv2&#xD;from moviepy.editor import VideoFileClip&#xD;from sklearn.cluster import KMeans&#xD;from tensorflow.keras.applications import InceptionV3&#xD;from tensorflow.keras.applications.inception_v3 import preprocess_input&#xD;from tensorflow.</description>
    </item>
    <item>
      <title>Miniconda 全攻略：优雅管理你的 Python 环境</title>
      <link>https://cyrus-studio.github.io/blog/posts/miniconda-%E5%85%A8%E6%94%BB%E7%95%A5%E4%BC%98%E9%9B%85%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84-python-%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Mon, 11 Aug 2025 00:33:05 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/miniconda-%E5%85%A8%E6%94%BB%E7%95%A5%E4%BC%98%E9%9B%85%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84-python-%E7%8E%AF%E5%A2%83/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Miniconda 介绍 Miniconda 是 Conda 的简化版本，只包含 Conda 包管理器和 Python 的最小安装包，提供了一种轻量级的环境管理和包管理工具。相比于 Anaconda，Miniconda 更小巧灵活，适合那些不需要 Anaconda 提供的完整生态的用户。&#xA;通过 Miniconda，开发者可以更高效地管理和定制自己的开发环境，避免不必要的依赖和资源浪费。&#xA;下载安装 Miniconda：https://docs.anaconda.com/miniconda/&#xA;把 Miniconda3 和 Miniconda3\Scripts 路径添加到 Path 系统环境变量&#xA;完成安装后，打开终端或命令提示符，输入&#xA;conda --version&#xD;python --version 如果显示版本号，说明安装成功。&#xA;创建环境 创建一个新的虚拟环境，指定特定版本的 Python&#xA;conda create -n anti-app python=3.12.6 列出当前可用的 Python 版本&#xA;conda search python 克隆环境 现有环境复制到新的环境&#xA;conda create --name new_env --clone old_env 删除环境 conda remove --name old_env --all 列出所有环境 conda env list 激活环境 conda activate env_name 停用当前环境 conda deactivate 导出当前环境 conda env export &amp;gt; environment.</description>
    </item>
    <item>
      <title>使用 readelf 分析 so 文件：ELF 结构解析全攻略</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-readelf-%E5%88%86%E6%9E%90-so-%E6%96%87%E4%BB%B6elf-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%E5%85%A8%E6%94%BB%E7%95%A5/</link>
      <pubDate>Sat, 09 Aug 2025 02:42:33 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-readelf-%E5%88%86%E6%9E%90-so-%E6%96%87%E4%BB%B6elf-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%E5%85%A8%E6%94%BB%E7%95%A5/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;readelf 介绍 readelf 是 GNU Binutils 提供的一个命令行工具，专门用于读取 ELF（Executable and Linkable Format）文件的结构信息。&#xA;readelf 文档：https://man7.org/linux/man-pages/man1/readelf.1.html&#xA;GNU Binutils GNU Binutils（GNU Binary Utilities）是一套由 GNU 项目维护的二进制文件处理工具集，主要用于编译、链接、反汇编、调试等场景。&#xA;它是 GCC（GNU Compiler Collection）的重要配套组件之一，处理从编译生成的目标文件到最终可执行文件的各个阶段。&#xA;主要工具：&#xA;工具 作用 as GNU 汇编器（GNU Assembler），把 .s 汇编代码编译成 .o 目标文件 ld GNU 链接器（GNU Linker），把多个 .o 文件和库打包成可执行文件或共享库 ar 归档工具（创建/修改 .a 静态库） nm 显示符号表（Symbol Table） objdump 显示目标文件内容（反汇编、节表、符号、重定位等） objcopy 复制并转换目标文件格式（可用于提取或删除节） readelf 专门查看 ELF 文件结构（文件头、节表、符号等） strip 删除二进制文件中的符号信息（瘦身/混淆） strings 搜索二进制文件中的可打印字符串 size 显示目标文件中各段的大小（text/data/bss） ranlib 为 .a 静态库生成索引（方便快速链接） Windows 下使用 readelf 虽然 readelf 工具本身是为 Unix-like 操作系统设计的，在 Windows 上通过 WSL 使用它。WSL 允许你在 Windows 上运行 Linux 发行版，并且可以在其中使用 readelf 工具。</description>
    </item>
    <item>
      <title>Frida Native 层 Hook 技巧：JNI 函数调用、字符串解析、so 加载</title>
      <link>https://cyrus-studio.github.io/blog/posts/frida-native-%E5%B1%82-hook-%E6%8A%80%E5%B7%A7jni-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90so-%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Mon, 04 Aug 2025 18:03:18 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/frida-native-%E5%B1%82-hook-%E6%8A%80%E5%B7%A7jni-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90so-%E5%8A%A0%E8%BD%BD/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;RegisterNatives RegisterNatives 是 JNI（Java Native Interface）的一部分，用于在 Java 类和本地 C/C++ 代码之间注册本地方法。其原型如下：&#xA;jint RegisterNatives(JNIEnv* env, jclass clazz, const JNINativeMethod* methods, jint method_count); 参数说明：&#xA;env：JNIEnv 指针。&#xA;clazz：Java 类的 jclass 句柄。&#xA;methods：指向 JNINativeMethod 结构体数组的指针。&#xA;method_count：要注册的方法数量。&#xA;其中，methods 结构体的定义如下：&#xA;typedef struct {&#xD;const char* name; // 方法名称（指向字符串）&#xD;const char* signature; // 方法签名（指向字符串）&#xD;void* fnPtr; // 方法的本地实现（指向本地函数）&#xD;} JNINativeMethod; 可以看到，每个 JNINativeMethod 结构体由 三个指针 组成：&#xA;name（方法名指针）&#xA;signature（方法签名指针）&#xA;fnPtr（本地方法指针）&#xA;一般会有两个 RegisterNatives 函数，CheckJNI 版本只有在调试选项打开时才会调用，我们一般用 JNI 的那个就行。&#xA;[+] Found RegisterNatives symbol: _ZN3art12_GLOBAL__N_18CheckJNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi at 0x780d7757a8&#xD;[+] Found RegisterNatives symbol: _ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi at 0x780d7eed10 通过 hook RegisterNatives 实现监控 app 中动态注册的 JNI 函数。代码如下：</description>
    </item>
    <item>
      <title>ADB 远程调试全教程：弹不出授权弹窗？手动授权搞定！</title>
      <link>https://cyrus-studio.github.io/blog/posts/adb-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%85%A8%E6%95%99%E7%A8%8B%E5%BC%B9%E4%B8%8D%E5%87%BA%E6%8E%88%E6%9D%83%E5%BC%B9%E7%AA%97%E6%89%8B%E5%8A%A8%E6%8E%88%E6%9D%83%E6%90%9E%E5%AE%9A/</link>
      <pubDate>Sat, 02 Aug 2025 14:22:15 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/adb-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%85%A8%E6%95%99%E7%A8%8B%E5%BC%B9%E4%B8%8D%E5%87%BA%E6%8E%88%E6%9D%83%E5%BC%B9%E7%AA%97%E6%89%8B%E5%8A%A8%E6%8E%88%E6%9D%83%E6%90%9E%E5%AE%9A/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;adb 远程调试 手机上开发者选项中打开网络调试&#xA;或者连接 USB 执行下面命令将 ADB 设置为通过端口 5555 进行 TCP/IP 调试&#xA;adb tcpip 5555 启用 TCP/IP 模式后可以断开 USB 连接&#xA;如果网络调试开关中没有显示设备ip地址，通过下面方法获取设备的 IP 地址：&#xA;在设备上，进入设置 &amp;gt; 网络与互联网 &amp;gt; Wi-Fi，选择当前连接的网络。&#xA;找到设备的 IP 地址（通常在网络详情中）。&#xA;根据设备 ip 地址和端口号连接到设备，并在手机上确认授权调试提示&#xA;adb connect 192.168.0.101:5555&#xD;already connected to 192.168.0.101:5555 第一次授权可能会提示 unauthorized&#xA;adb devices&#xD;List of devices attached&#xD;192.168.0.101:5555 unauthorized 重启 adb，重新再连接&#xA;adb kill-server&#xD;adb connect 192.168.0.101:5555&#xD;* daemon not running; starting now at tcp:5037&#xD;* daemon started successfully&#xD;connected to 192.</description>
    </item>
    <item>
      <title>深入WSL与USB：教你如何编译 Linux 内核支持 USB 共享</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5wsl%E4%B8%8Eusb%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91-linux-%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81-usb-%E5%85%B1%E4%BA%AB/</link>
      <pubDate>Sat, 02 Aug 2025 14:06:08 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5wsl%E4%B8%8Eusb%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91-linux-%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81-usb-%E5%85%B1%E4%BA%AB/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 WSL 本身并不支持连接 USB 设备，因此你需要安装开源 usbipd-win 项目。&#xA;usbip 可以让你在网络上共享和使用 USB 设备。它由两个主要组件组成：&#xA;usbipd (USB/IP daemon)：服务端，负责共享连接到主机的 USB 设备。&#xA;usbip (USB/IP client)：客户端，允许其他计算机访问共享的 USB 设备。&#xA;1. 安装USBIPD-WIN USBIPD-WIN 是一个在 Windows 上实现 USB/IP 协议的工具。首先，你需要在 Windows 上安装这个工具。&#xA;下载并安装 usbipd-win，可以从GitHub页面获取最新版本的安装包。&#xA;或者执行下面命令安装&#xA;winget install usbipd 2. 列出所有可以共享的USB设备 usbipd list 3. 共享设备 在附加 USB 设备之前，必须使用命令 usbipd bind 来共享设备，从而允许它附加到 WSL（ 需要管理员权限）。&#xA;usbipd bind --busid 2-6 这里的 2-6 是 USB 设备对应的 BUSID&#xA;4. 将USB设备连接到WSL 使用 usbipd attach 命令将指定的USB设备附加到WSL实例中。&#xA;usbipd attach --wsl --busid 2-6 打开 Ubuntu（或首选的 WSL 命令行），使用以下命令列出附加的 USB 设备</description>
    </item>
    <item>
      <title>教你签自己的系统！LineageOS Release Key 签名刷机教程</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%95%99%E4%BD%A0%E7%AD%BE%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B3%BB%E7%BB%9Flineageos-release-key-%E7%AD%BE%E5%90%8D%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sat, 02 Aug 2025 13:47:13 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%95%99%E4%BD%A0%E7%AD%BE%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B3%BB%E7%BB%9Flineageos-release-key-%E7%AD%BE%E5%90%8D%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;为什么需要使用 release key test-key 是一个公开的、众所周知的开发测试密钥，广泛用于测试阶段。这意味着任何人都可以获取这个密钥，并用它签署自己修改的 APK 或系统文件。&#xA;使用 test-key 签署的系统镜像通常无法通过 Google 的 CTS（兼容性测试套件）认证，Google Play 商店、Google 服务框架等应用可能无法正常运行，某些第三方应用（例如银行应用或数字版权管理应用）也可能拒绝在设备上运行。&#xA;OTA 更新包必须使用 Release Key 来签名。签名的更新包经过验证，只有具有相同 Release Key 的设备才能接收和安装更新。&#xA;生成 release key 执行 nano make_keys.sh 创建脚本，内容如下&#xA;subject=&amp;#39;/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=linchaolong.dev@gmail.com&amp;#39;&#xD;# 创建 keys 目录（如果不存在）&#xD;mkdir -p keys&#xD;for cert in bluetooth cyngn-app media networkstack nfc platform releasekey sdk_sandbox shared testcert testkey verity; do \&#xD;./development/tools/make_key keys/$cert &amp;#34;$subject&amp;#34;; \&#xD;done 通过脚本创建 keys 目录并使用 make_key 命令生成你自己的密钥。&#xA;运行脚本生成密钥文件。</description>
    </item>
    <item>
      <title>刷入 LineageOS 后无法联网？一文解决IP配置失败与网络受限</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%88%B7%E5%85%A5-lineageos-%E5%90%8E%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3ip%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8F%97%E9%99%90/</link>
      <pubDate>Sat, 02 Aug 2025 13:19:24 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%88%B7%E5%85%A5-lineageos-%E5%90%8E%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3ip%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8F%97%E9%99%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;解决连接网络提示 IP 配置失败 连接所有网络都提示IP配置失败。&#xA;使用 Magisk root 后就这样了，LineageOS 17.1（wayne），重新刷回刷机包的 boot.img 后就没问题了。&#xA;但是如果需要用到 root 权限怎么办？&#xA;如何以 Root 身份进入 ADB Shell？ 首先，进入设置中【开发者选项】，开启【Root 身份的调试】&#xA;接着执行下面的命令获取 root 权限&#xA;# 启用 adb root 身份&#xD;adb root&#xD;restarting adbd as root&#xD;# 以 root 身份进入&#xD;adb shell&#xD;# 验证 Root 权限&#xD;whoami&#xD;root # 返回结果为 root，说明你已经成功以 root 身份进入 ADB shell。 解决 LineageOS 提示网络受限 问题原因 由于 LineageOS 源码里默认是使用 google captive连接验证服务，所以国内会一直提示网络受限，但是实际上是可以访问网络的。&#xA;要解决这个问题可以通过把 captive_portal_https_url 改为国内的就好了，比如用MIUI的。&#xA;更换 captive 连接验证服务器 1.</description>
    </item>
    <item>
      <title>手把手教你编译 LineageOS 模拟器镜像，并导入 Android Studio 使用！</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E8%AF%91-lineageos-%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AF%BC%E5%85%A5-android-studio-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 02 Aug 2025 12:44:21 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E8%AF%91-lineageos-%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AF%BC%E5%85%A5-android-studio-%E4%BD%BF%E7%94%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 从源码下载、环境配置到编译与导出完整模拟器镜像，逐步实现将 LineageOS 运行在 Android Studio 模拟器中。&#xA;相比官方系统镜像，自编译的 LineageOS 镜像更容易进行定制与修改，适合深入探索 Android 系统底层。&#xA;源码下载 LineageOS官网：https://lineageos.org/&#xA;LineageOS源码 github 地址：https://github.com/LineageOS/android&#xA;LineageOS源码国内镜像地址：https://mirrors.tuna.tsinghua.edu.cn/help/lineageOS/&#xA;源码大概需要150GB的硬盘空间，编译完成差不多300G&#xA;1. 配置git git config --global user.email &amp;#34;you@example.com&amp;#34;&#xD;git config --global user.name &amp;#34;Your Name&amp;#34; 2. 安装 repo mkdir ~/bin&#xD;PATH=~/bin:$PATH&#xD;curl https://storage.googleapis.com/git-repo-downloads/repo &amp;gt; ~/bin/repo&#xD;chmod a+x ~/bin/repo 3. 安装 Git LFS sudo apt install git-lfs&#xD;git lfs install 4. 设置REPO_URL 找到 repo 所在路径&#xA;which repo 编辑 repo&#xA;nano /home/cyrus/bin/repo 可以看到repo会优先取环境变量中的REPO_URL，否则默认使用googlesource</description>
    </item>
    <item>
      <title>Android 源码如何导入 Android Studio？踩坑与解决方案详解</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-%E6%BA%90%E7%A0%81%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5-android-studio%E8%B8%A9%E5%9D%91%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 02 Aug 2025 12:14:15 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-%E6%BA%90%E7%A0%81%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5-android-studio%E8%B8%A9%E5%9D%91%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 需要先把 Android 源码编译一遍，Android 源码编译参考这篇文章：解决90%踩坑问题！LineageOS 源码下载与编译保姆级教程&#xA;idegen.sh 脚本生成项目文件，一步步排除导入过程中常见的坑点，将 Android 源码集成进 Android Studio 环境中，从而实现高效阅读与调试系统代码。&#xA;生成 android.ipr 文件 进入到下面的目录 cd ./development/tools/idegen 使用 mm 命令对当前目录 make，构建 idegen 模块 mm 执行完成后会在 out 目录生成一个 idegen.jar 文件&#xA;回到 android 源码根目录，执行 idegen.sh 脚本（需要管理员权限） # 回到 android 源码根目录&#xD;croot&#xD;# 执行 idegen.sh 脚本&#xD;sudo ./development/tools/idegen/idegen.sh 执行完成后会生成一个 android.ipr 文件，用 android studio 打开这个 android.ipr 文件就可以完成 android 源码的导入了 运行 idegen.sh 脚本时遇到的问题 在运行 development/tools/idegen/idegen.sh 脚本时遇到的问题&#xA;1. 文件系统循环 find: File system loop detected 错误表示在使用 find 命令时遇到了符号链接循环。这通常不会导致脚本失败，但确实会产生一些额外的警告信息。</description>
    </item>
    <item>
      <title>逆向某短视频App搜索协议：破解加密通信，还原真实数据！</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%9F%AD%E8%A7%86%E9%A2%91app%E6%90%9C%E7%B4%A2%E5%8D%8F%E8%AE%AE%E7%A0%B4%E8%A7%A3%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E8%BF%98%E5%8E%9F%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Wed, 30 Jul 2025 21:54:18 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%9F%AD%E8%A7%86%E9%A2%91app%E6%90%9C%E7%B4%A2%E5%8D%8F%E8%AE%AE%E7%A0%B4%E8%A7%A3%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E8%BF%98%E5%8E%9F%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;搜索接口抓包分析 抓包数据如下：&#xA;Request 和 Response 的 Body 被加密无法直接查看。&#xA;请求地址：&#xA;https://***************************/aweme/v2/search/general/single/?klink_egdi=********************************************************&amp;amp;iid=****************&amp;amp;device_id=****************&amp;amp;ac=****&amp;amp;channel=*******************&amp;amp;aid=****&amp;amp;app_name=*****&amp;amp;version_code=******&amp;amp;version_name=******&amp;amp;device_platform=*******&amp;amp;os=*******&amp;amp;ssmix=*&amp;amp;device_type=*****&amp;amp;device_brand=******&amp;amp;language=**&amp;amp;os_api=**&amp;amp;os_version=**&amp;amp;manifest_version_code=******&amp;amp;resolution=*********&amp;amp;dpi=***&amp;amp;update_version_code=********&amp;amp;_rticket=*************&amp;amp;package=************************&amp;amp;first_launch_timestamp=**********&amp;amp;last_deeplink_update_version_code=*&amp;amp;cpu_support64=****&amp;amp;host_abi=*********&amp;amp;is_guest_mode=*&amp;amp;app_type=******&amp;amp;minor_status=*&amp;amp;appTheme=*****&amp;amp;is_preinstall=*&amp;amp;need_personal_recommend=*&amp;amp;is_android_pad=*&amp;amp;is_android_fold=*&amp;amp;ts=**********&amp;amp;cdid=************************************ 请求头：&#xA;:method: POST&#xD;:authority: ***************************&#xD;:scheme: https&#xD;:path: /aweme/v2/search/general/single/?klink_egdi=********************************************************&amp;amp;iid=****************&amp;amp;device_id=****************&amp;amp;ac=****&amp;amp;channel=*******************&amp;amp;aid=****&amp;amp;app_name=*****&amp;amp;version_code=******&amp;amp;version_name=******&amp;amp;device_platform=*******&amp;amp;os=*******&amp;amp;ssmix=*&amp;amp;device_type=*****&amp;amp;device_brand=******&amp;amp;language=**&amp;amp;os_api=**&amp;amp;os_version=**&amp;amp;manifest_version_code=******&amp;amp;resolution=*********&amp;amp;dpi=***&amp;amp;update_version_code=********&amp;amp;_rticket=*************&amp;amp;package=************************&amp;amp;first_launch_timestamp=**********&amp;amp;last_deeplink_update_version_code=*&amp;amp;cpu_support64=****&amp;amp;host_abi=*********&amp;amp;is_guest_mode=*&amp;amp;app_type=******&amp;amp;minor_status=*&amp;amp;appTheme=*****&amp;amp;is_preinstall=*&amp;amp;need_personal_recommend=*&amp;amp;is_android_pad=*&amp;amp;is_android_fold=*&amp;amp;ts=**********&amp;amp;cdid=************************************&#xD;content-length: ****&#xD;cookie: ****************************************************&#xD;cookie: ************************************************************&#xD;cookie: ******************&#xD;cookie: ********************&#xD;cookie: ************************************************************************************************************************************************************************&#xD;cookie: ***************************&#xD;cookie: ************************************************&#xD;x-tt-dt: ******************************************************************************************************************************************************&#xD;activity_now_client: *************&#xD;compressed-bcm-chain: ******************************************************************************************************************************************************************************************************************************************************************************&#xD;x-ss-req-ticket: *************&#xD;sdk-version: *&#xD;passport-sdk-version: *****&#xD;x-vc-bdturing-sdk-version: ********&#xD;content-type: ************************************************&#xD;x-ss-stub: ******************************&#xD;x-bd-content-encoding: ****&#xD;x-tt-store-region: *****&#xD;x-tt-store-region-src: ***&#xD;x-tt-request-tag: ********&#xD;x-ss-dp: ****&#xD;x-tt-trace-id: *******************************************************&#xD;user-agent: ********************************************************************************************************************************************************************&#xD;ttzip-version: **********&#xD;ttzip-tlb: *&#xD;accept-encoding: ************************&#xD;x-argus: ********&#xD;x-gorgon: ****************************************************&#xD;x-helios: ************************************************&#xD;x-khronos: **********&#xD;x-ladon: ********&#xD;x-medusa: ************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************&#xD;x-soter: ************************************************************************************************************************&#xD;(�/�`�=�{ curl 请求如下：</description>
    </item>
    <item>
      <title>动态篡改 so 函数返回值：一篇带你玩转 Android Hook 技术！</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%8A%A8%E6%80%81%E7%AF%A1%E6%94%B9-so-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%80%E7%AF%87%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-android-hook-%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 28 Jul 2025 04:35:41 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%8A%A8%E6%80%81%E7%AF%A1%E6%94%B9-so-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%80%E7%AF%87%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-android-hook-%E6%8A%80%E6%9C%AF/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 第三方 SDK 中的 so ，VMP壳 + OLLVM 混淆。&#xA;使用 frida 获取到目标 native 函数信息如下：&#xA;------------ [ #1 Native Method ] ------------&#xD;Method Name : public static final native boolean ****************************************.ca(android.content.Context)&#xD;ArtMethod Ptr : 0x7cc748a128&#xD;Native Addr : 0x7cb77c5834&#xD;Module Name : libhexymsb.so&#xD;Module Offset : 0x09C8&#xD;Module Base : 0x7cb7788000&#xD;Module Size : 335872 bytes&#xD;Module Path : /data/app/com.demotestapp.test-B17GBv-5lpTxH5GABufXfw==/lib/arm64/libhexymsb.so&#xD;------------------------------------------------ ca 函数在 libhexymsb.so 偏移 0x09C8 的位置。&#xA;需求：修改 so 中 ca 函数的返回值，固定为 true。</description>
    </item>
    <item>
      <title>OLLVM 混淆 &#43; VMP 壳照样破！绕过加壳 SDK 的核心检测逻辑</title>
      <link>https://cyrus-studio.github.io/blog/posts/ollvm-%E6%B7%B7%E6%B7%86-&#43;-vmp-%E5%A3%B3%E7%85%A7%E6%A0%B7%E7%A0%B4%E7%BB%95%E8%BF%87%E5%8A%A0%E5%A3%B3-sdk-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A3%80%E6%B5%8B%E9%80%BB%E8%BE%91/</link>
      <pubDate>Sun, 27 Jul 2025 16:39:39 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/ollvm-%E6%B7%B7%E6%B7%86-&#43;-vmp-%E5%A3%B3%E7%85%A7%E6%A0%B7%E7%A0%B4%E7%BB%95%E8%BF%87%E5%8A%A0%E5%A3%B3-sdk-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A3%80%E6%B5%8B%E9%80%BB%E8%BE%91/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 逆向目标是一个第三方 SDK，核心代码在 so 层，已知 so 有加壳。&#xA;调用入口是 *******************************************，会触发 libhexymsb.so 中的 token 和 time 检查方法，目标是绕过检查并成功调用 SDK。&#xA;Java 层代码逆向分析 通过 Frida hook 一下 目标类&#xA;/**&#xD;* Hook 指定类的所有方法（每个方法所有重载）&#xD;* @param {string} className - Java 类的完整名&#xD;*/&#xD;function hook_all_methods(className) {&#xD;Java.perform(function () {&#xD;var clazz = Java.use(className);&#xD;var methods = clazz.class.getDeclaredMethods(); // 反射获取所有声明的方法&#xD;var hooked = new Set(); // 用于避免重复 hook 相同方法名（因为多重载）&#xD;methods.forEach(function (m) {&#xD;var methodName = m.getName();&#xD;// 如果这个方法已经 Hook 过，就跳过&#xD;if (hooked.</description>
    </item>
    <item>
      <title>逆向 JNI 函数找不到入口？动态注册定位技巧全解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91-jni-%E5%87%BD%E6%95%B0%E6%89%BE%E4%B8%8D%E5%88%B0%E5%85%A5%E5%8F%A3%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%AE%9A%E4%BD%8D%E6%8A%80%E5%B7%A7%E5%85%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 26 Jul 2025 16:12:02 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91-jni-%E5%87%BD%E6%95%B0%E6%89%BE%E4%B8%8D%E5%88%B0%E5%85%A5%E5%8F%A3%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%AE%9A%E4%BD%8D%E6%8A%80%E5%B7%A7%E5%85%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 使用 IDA Pro 静态分析时，JNI 函数并没有出现在导出表中，根本找不到函数实现的位置。&#xA;这是因为很多 App 为了安全性和混淆目的，采用了 JNI 动态注册（RegisterNatives） 的方式，绕开了传统的静态绑定机制。&#xA;那么遇到这种情况我们该怎么办？&#xA;通过源码分析JNI 函数调用流程 ArtMethod 是 ART 虚拟机中用于表示 Java 方法的底层结构体，Java 中每个方法在运行时都会对应一个 ArtMethod 实例，用于管理其执行入口、访问标志、Dex 信息等元数据。&#xA;entry_point_from_jni_ 是 ArtMethod 结构体的一个字段，专门用于存储 Java 方法对应的 JNI 函数地址。&#xA;在编译 JNI 方法时，ArtJniCompileMethodInternal 中通过调用 EntryPointFromJniOffset 方法获取 entry_point_from_jni_ 字段的偏移，并生成一条调用该 jni 函数的机器指令插入到编译结果中。&#xA;// 9. Plant call to native code associated with method.&#xD;// 计算 ArtMethod 中 JNI 入口地址的字段偏移（即 ptr_sized_fields_.data_ 偏移）&#xD;// 根据目标指令集（如 arm64、x86）传入对应的指针大小（PointerSize::k64 或 k32）&#xD;MemberOffset jni_entrypoint_offset =&#xD;ArtMethod::EntryPointFromJniOffset(InstructionSetPointerSize(instruction_set));&#xD;// 这部分代码生成了一条机器指令，用于调用 ArtMethod::entry_point_from_jni 所指向的 native 函数：&#xD;__ Call(main_jni_conv-&amp;gt;MethodStackOffset(), // 栈中 ArtMethod* 相对偏移&#xD;jni_entrypoint_offset, // ArtMethod 内部 entry_point_from_jni 字段的偏移&#xD;mr_conv-&amp;gt;InterproceduralScratchRegister()); // 用于保存临时地址的寄存器 https://cs.</description>
    </item>
    <item>
      <title>手把手教你改造 AAR：解包、注入逻辑、重打包，一条龙玩转第三方 SDK！</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%94%B9%E9%80%A0-aar%E8%A7%A3%E5%8C%85%E6%B3%A8%E5%85%A5%E9%80%BB%E8%BE%91%E9%87%8D%E6%89%93%E5%8C%85%E4%B8%80%E6%9D%A1%E9%BE%99%E7%8E%A9%E8%BD%AC%E7%AC%AC%E4%B8%89%E6%96%B9-sdk/</link>
      <pubDate>Sat, 26 Jul 2025 01:46:43 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%94%B9%E9%80%A0-aar%E8%A7%A3%E5%8C%85%E6%B3%A8%E5%85%A5%E9%80%BB%E8%BE%91%E9%87%8D%E6%89%93%E5%8C%85%E4%B8%80%E6%9D%A1%E9%BE%99%E7%8E%A9%E8%BD%AC%E7%AC%AC%E4%B8%89%E6%96%B9-sdk/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;一、什么是 AAR 文件？ AAR 文件（Android Archive）是 Android Studio 用来打包 Android Library（库模块） 的一种压缩文件格式，扩展名是 .aar，类似于 Java 的 .jar 文件，但功能更丰富，用于复用 UI 组件、资源和代码。&#xA;AAR 文件结构（解压后）&#xA;your-lib.aar&#xD;├── AndroidManifest.xml # 库模块的清单文件&#xD;├── classes.jar # 编译后的 Java/Kotlin 类文件（字节码）&#xD;├── res/ # 资源目录（layout、drawable、values 等）&#xD;├── R.txt # 编译生成的 R 类符号文件&#xD;├── assets/ # assets 目录中的内容&#xD;├── libs/ # 依赖的 .jar 库&#xD;├── jni/ # native 库（.so 文件）&#xD;├── proguard.txt # 混淆配置文件&#xD;├── public.txt # 声明哪些资源是公开的&#xD;└── META-INF/ # 元数据（如 aar metadata、许可证等） 使用 AAR 的场景举例：</description>
    </item>
    <item>
      <title>手把手教你玩转 MagiskBoot：内核解包打包全流程</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%8E%A9%E8%BD%AC-magiskboot%E5%86%85%E6%A0%B8%E8%A7%A3%E5%8C%85%E6%89%93%E5%8C%85%E5%85%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Fri, 25 Jul 2025 04:01:52 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%8E%A9%E8%BD%AC-magiskboot%E5%86%85%E6%A0%B8%E8%A7%A3%E5%8C%85%E6%89%93%E5%8C%85%E5%85%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;MagiskBoot MagiskBoot 是 Magisk 项目的一个核心子组件，专门用于 解包、修改、重打包 Android 的 boot 镜像（boot.img）。&#xA;编译 MagiskBoot 编译环境准备 Windows下 启用开发者模式，因为需要 symbolic link 支持（编译过程中需要使用到符号链接） Symbolic Link（符号链接），也叫 软链接，是一种特殊类型的文件，它 指向另一个文件或目录，本身不保存数据，只起到“快捷通道”的作用。&#xA;类似于 Windows 中的 快捷方式（.lnk 文件），但更底层、更透明，对程序来说就像访问真实文件一样。&#xA;出于安全原因，Windows 默认不允许普通用户创建符号链接，防止恶意程序引导系统或用户操作到错误位置 。&#xA;安装 python3.8+，并配置PATH环境变量 # 查看python版本信息&#xD;py --version&#xD;# 查看所有已安装的 Python 解释器路径&#xD;py -0p git 启用 symbolic links # 启用 symbolic links&#xD;git config --global core.symlinks true&#xD;# 查看 git 配置&#xD;git config --global --list 安装 Android Studio ，设置环境变量 ANDROID_HOME 为 Android SDK 文件夹的路径。该路径可以在 Android Studio 的设置中找到。</description>
    </item>
    <item>
      <title>Magisk 修改 ro.debuggable 开启 Android 系统全局调试模式</title>
      <link>https://cyrus-studio.github.io/blog/posts/magisk-%E4%BF%AE%E6%94%B9-ro.debuggable-%E5%BC%80%E5%90%AF-android-%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 25 Jul 2025 03:30:50 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/magisk-%E4%BF%AE%E6%94%B9-ro.debuggable-%E5%BC%80%E5%90%AF-android-%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;ro.debuggable 通过修改 android 系统 中的 ro.debuggable 属性，开启系统调试通道，使设备上所有 app 可调试。&#xA;ro.debuggable 一般在系统的 build.prop 或构建配置文件中设置，比如：&#xA;ro.debuggable=1 在编译 AOSP 时，这个值通常在 build/core/main.mk 中由 user, userdebug, eng 等 build 类型决定：&#xA;build 类型 ro.debuggable user 0 userdebug 1 eng 1 如何查看当前设备的 ro.debuggable 通过 adb 命令查看：&#xA;adb shell getprop ro.debuggable 输出：&#xA;0：系统为非调试版本（普通用户设备）&#xA;1：系统为调试版本（如 LineageOS 的 userdebug 或 eng 版本）&#xA;MagiskHidePropsConf MagiskHidePropsConf 是一个基于 Magisk 模块系统的工具模块，主要功能是：修改 Android 设备的系统属性（System Properties）以“伪装”或“欺骗”应用和检测机制。&#xA;下载 MagiskHidePropsConf：https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf/tags&#xA;把下载下来的 MagiskHidePropsConf 推送到手机 sdcard 上&#xA;adb push &amp;#34;D:\app逆向\MagiskHidePropsConf-v6.</description>
    </item>
    <item>
      <title>小米刷机全攻略：解锁BL、刷机、Root 一步到位</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%B0%8F%E7%B1%B3%E5%88%B7%E6%9C%BA%E5%85%A8%E6%94%BB%E7%95%A5%E8%A7%A3%E9%94%81bl%E5%88%B7%E6%9C%BAroot-%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D/</link>
      <pubDate>Fri, 25 Jul 2025 03:09:58 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%B0%8F%E7%B1%B3%E5%88%B7%E6%9C%BA%E5%85%A8%E6%94%BB%E7%95%A5%E8%A7%A3%E9%94%81bl%E5%88%B7%E6%9C%BAroot-%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;解锁BL锁 下载安装 miflash_unlock：https://miuiver.com/miunlock/，登录小米账号（需要和解锁设备绑定的账号一致） 连接手机，关机后按住 “音量-” + 开机键进入 fastboot 模式，根据提示解锁手机 如果连接不上设备，点击右上角设置按钮【驱动检测】，手机进入recovery模式下重新连接，等待驱动安装完成。&#xA;如果还是连不上，参考下面链接的解决办法&#xA;https://miuiver.com/usb3-fix/&#xA;重启手机开发者模式中查看解锁状态 刷机 ROM下载：https://magiskcn.com/rom&#xA;下载小米线刷工具：https://xiaomirom.com/download-xiaomi-flash-tool-miflash/&#xA;下载设备开发版线刷包，并解压线刷包&#xA;打开miflash&#xA;连接手机，关机，按住 &amp;ldquo;开机&amp;rdquo; + &amp;ldquo;音量-&amp;rdquo; 进入fastboot模式&#xA;选择线刷包解压目录开始刷机&#xA;等待刷机成功&#xA;刷机成功后，重新解除BL锁&#xA;打开手机管家——应用管理——权限——ROOT权限——开启ROOT权限&#xA;结果发现root工具一直下载失败&#xA;使用Magisk进行root 下载 Magisk：https://github.com/topjohnwu/Magisk/releases&#xA;安装 Magisk adb install Magisk-v27.0.apk 解压线刷包中的 boot.img，并 push 到手机 adb push boot.img /sdcard/boot.img Magisk中【安装】【下一步】【选择并修补一个文件】【选择boot.img】，把处理完后的magisk_patched 下载到电脑 Android sdk\platform-tools 目录（这里下载 Android SDK Platform Tools） adb pull /sdcard/Download/magisk_patched-27000_RIC3F.img D:\App\android\sdk\platform-tools 使用 adb 命令将设备重启到 fastboot 模式 adb reboot bootloader 把 magisk_patched 刷新到系统 # 切换到platform-tools目录&#xD;cd D:\App\android\sdk\platform-tools&#xD;# 刷入 magisk_patched&#xD;fastboot flash boot magisk_patched-27000_RIC3F.</description>
    </item>
    <item>
      <title>解决90%踩坑问题！LineageOS 源码下载与编译保姆级教程</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E8%A7%A3%E5%86%B390%E8%B8%A9%E5%9D%91%E9%97%AE%E9%A2%98lineageos-%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%B8%8E%E7%BC%96%E8%AF%91%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 25 Jul 2025 02:56:37 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E8%A7%A3%E5%86%B390%E8%B8%A9%E5%9D%91%E9%97%AE%E9%A2%98lineageos-%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%B8%8E%E7%BC%96%E8%AF%91%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;源码下载 LineageOS官网：https://lineageos.org/&#xA;LineageOS源码 github 地址：https://github.com/LineageOS/android&#xA;LineageOS源码国内镜像地址：https://mirrors.tuna.tsinghua.edu.cn/help/lineageOS/&#xA;源码大概需要150GB的硬盘空间，编译完成差不多300G&#xA;1. 配置git git config --global user.email &amp;#34;you@example.com&amp;#34;&#xD;git config --global user.name &amp;#34;Your Name&amp;#34; 2. 安装 repo mkdir ~/bin&#xD;PATH=~/bin:$PATH&#xD;curl https://storage.googleapis.com/git-repo-downloads/repo &amp;gt; ~/bin/repo&#xD;chmod a+x ~/bin/repo 3. 安装 Git LFS sudo apt install git-lfs&#xD;git lfs install 4. 安装 Android SDK Platform-Tools 在 Linux 中配置 Android SDK Platform-Tools，可以按照以下步骤进行&#xA;4.1 下载 Android SDK Platform-Tools： # cd 到存放 platform-tools 的目录&#xD;cd /mnt/case_sensitive&#xD;# 下载 platform-tools&#xD;wget https://dl.</description>
    </item>
    <item>
      <title>教你从零刷入 LineageOS：Recovery &#43; Sideload 全流程实操指南</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%95%99%E4%BD%A0%E4%BB%8E%E9%9B%B6%E5%88%B7%E5%85%A5-lineageosrecovery-&#43;-sideload-%E5%85%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E6%93%8D%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 25 Jul 2025 02:53:13 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%95%99%E4%BD%A0%E4%BB%8E%E9%9B%B6%E5%88%B7%E5%85%A5-lineageosrecovery-&#43;-sideload-%E5%85%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E6%93%8D%E6%8C%87%E5%8D%97/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;LineageOS 简介 LineageOS 是一个基于 Android 开源项目（AOSP）的开源操作系统，主要由社区开发者维护。它起源于 CyanogenMod 项目，该项目于 2016 年关闭后，LineageOS 成为了其继任者。&#xA;主要特点：&#xA;开源：所有源代码都是开源的，任何人都可以查看、修改和分发。&#xA;无预装垃圾软件：相比一些预装大量应用的定制 ROM，LineageOS 保持了简洁和干净的系统环境。&#xA;定期更新：社区提供持续的安全补丁和新功能更新。&#xA;广泛设备支持：支持各种品牌和型号的设备，尤其是一些官方已停止支持的老旧设备。&#xA;隐私保护：LineageOS 提供了增强的隐私保护功能，如权限管理器和私密模式。&#xA;注意：在刷机之前，请确认你的设备已经解除BL锁。&#xA;下载 LineageOS 开始刷机之前，先在 LineageOS官网 找到自己的设备型号，下载对应的刷机包&#xA;或者下载 LineageOS 源码 自己编译系统&#xA;下载 GMS套件包 （可选）&#xA;刷机环境准备 在 Linux 中配置 Android SDK Platform-Tools，可以按照以下步骤进行&#xA;1. 下载 Android SDK Platform-Tools： # cd 到存放 platform-tools 的目录&#xD;cd /mnt/case_sensitive&#xD;# 下载 platform-tools&#xD;wget https://dl.google.com/android/repository/platform-tools-latest-linux.zip&#xD;# 解压 platform-tools&#xD;unzip platform-tools-latest-linux.zip 2. 配置环境变量： 为了在任何地方都能使用 adb 和 fastboot 命令，你需要将 platform-tools 目录添加到你的 PATH 中。</description>
    </item>
    <item>
      <title>搞懂 Android Hook 的两大核心：PLT Hook 与 Inline Hook 全解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%90%9E%E6%87%82-android-hook-%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%A0%B8%E5%BF%83plt-hook-%E4%B8%8E-inline-hook-%E5%85%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 25 Jul 2025 02:01:18 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%90%9E%E6%87%82-android-hook-%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%A0%B8%E5%BF%83plt-hook-%E4%B8%8E-inline-hook-%E5%85%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 在 Android Native 层开发和逆向分析中，Hook 技术是一项绕不开的核心能力。&#xA;Hook 技术是一种在应用运行时拦截或替换系统或自身函数行为的手段，常见实现包括 PLT Hook、Inline Hook。&#xA;PLT Hook 和 Inline Hook 是两种不同层次和机制的函数 Hook 技术，常用于逆向工程、安全分析、壳保护或热修复等场景。&#xA;PLT hook 和 Inline hook 有什么区别？ 特性 PLT Hook（符号级） Inline Hook（指令级） Hook 层级 链接层（.plt 或 GOT） 指令层（函数入口指令） Hook 对象 动态库导出的函数 任意函数（不一定导出） 修改内容 修改函数地址指针 修改指令流（如跳转指令） Hook 粒度 通常是库间调用 可以精确到任意函数、库内调用 稳定性 较高 稍差（依赖指令结构、架构） 跨平台兼容性 更好 架构相关（ARM32/ARM64） PLT Hook 原理（也叫 GOT Hook） ELF 中动态链接时使用 PLT（Procedure Linkage Table） 和 GOT（Global Offset Table） ；</description>
    </item>
    <item>
      <title>ADB 命令使用大全（建议收藏） Android 调试必备</title>
      <link>https://cyrus-studio.github.io/blog/posts/adb-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F-android-%E8%B0%83%E8%AF%95%E5%BF%85%E5%A4%87/</link>
      <pubDate>Fri, 25 Jul 2025 02:01:16 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/adb-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F-android-%E8%B0%83%E8%AF%95%E5%BF%85%E5%A4%87/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;基础adb命令 # 重启adb adb kill-server&#xD;# 查看已连接的设备&#xD;adb devices&#xD;# 进入命令行&#xD;adb shell&#xD;# 使用 -s 参数来指定设备&#xD;adb -s &amp;lt;设备序列号&amp;gt; shell&#xD;# 显示日志&#xD;adb logcat 获取 API Level 进入 adb shell ，执行下面命令获取当前 Android 系统的 API Level（即 SDK 版本）：&#xA;getprop ro.build.version.sdk 以下是 Android 版本与 API Level 的对应表 （截至 Android 15）：&#xA;Android 版本 API Level 代号 发布时间 Android 15 35 Vanilla Ice Cream 2024年9月 Android 14 34 Upside Down Cake 2023年10月 Android 13 33 Tiramisu 2022年8月 Android 12L 32 2022年3月 Android 12 31 Snow Cone 2021年10月 Android 11 30 Red Velvet Cake 2020年9月 Android 10 29 Q 2019年9月 Android 9 28 Pie 2018年8月 Android 8.</description>
    </item>
    <item>
      <title>一键反编译、签名、安装 APK！手把手带你玩转 ApkTool &#43; 签名工具</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E9%94%AE%E5%8F%8D%E7%BC%96%E8%AF%91%E7%AD%BE%E5%90%8D%E5%AE%89%E8%A3%85-apk%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-apktool-&#43;-%E7%AD%BE%E5%90%8D%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 25 Jul 2025 02:01:16 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E9%94%AE%E5%8F%8D%E7%BC%96%E8%AF%91%E7%AD%BE%E5%90%8D%E5%AE%89%E8%A3%85-apk%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%AC-apktool-&#43;-%E7%AD%BE%E5%90%8D%E5%B7%A5%E5%85%B7/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;ApkTool 简介 apktool 用于对 Android 应用（.apk 文件）进行 反编译 和 重打包（回编译）。它可以将 APK 中的资源文件、AndroidManifest.xml 以及 DEX 代码（转换为 smali 代码）提取出来并可编辑，便于进行逆向分析、修改资源或注入逻辑等操作。&#xA;官网：https://apktool.org/&#xA;使用 ApkTool 反编译和回编译 APK 从官网下载 apktool 的 jar 文件到本地，需要 Java 环境（JDK 8+）。&#xA;1. 反编译 APK apktool d myapp.apk&#xD;# 或指定输出目录&#xD;apktool d myapp.apk -o myapp_decoded 会得到如下结构：&#xA;myapp_decoded/&#xD;├── AndroidManifest.xml&#xD;├── smali/ &amp;lt;-- 反编译后的 Java 代码（smali）&#xD;├── res/ &amp;lt;-- 资源文件&#xD;├── assets/&#xD;└── original/ &amp;lt;-- 原始META信息 你可以：&#xA;编辑 res/layout 里的 XML 修改 UI；</description>
    </item>
    <item>
      <title>深入理解 Android 热修复机制：掌握 dexElements 注入技巧</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-android-%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%9C%BA%E5%88%B6%E6%8E%8C%E6%8F%A1-dexelements-%E6%B3%A8%E5%85%A5%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 21 Jul 2025 01:36:07 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-android-%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%9C%BA%E5%88%B6%E6%8E%8C%E6%8F%A1-dexelements-%E6%B3%A8%E5%85%A5%E6%8A%80%E5%B7%A7/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;dexElements Android 的 ClassLoader（如 PathClassLoader、DexClassLoader）内部结构如下：&#xA;BaseDexClassLoader&#xD;└── pathList : DexPathList&#xD;└── dexElements : Array&amp;lt;DexPathList.Element&amp;gt; DexPathList 是 BaseDexClassLoader 用来管理 .dex 文件、.apk 和 .jar 的内部类，负责构建和维护类加载搜索路径。&#xA;http://aospxref.com/android-10.0.0_r47/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java#51&#xA;dexElements 是 DexPathList 中用于保存所有 .dex 文件对应的元素数组，每个 Element 表示一个可用于加载类和资源的路径项，类加载时会依次查找这些元素。&#xA;http://aospxref.com/android-10.0.0_r47/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java#69&#xA;findClass 方法迭代 dexElements 数组查找类&#xA;http://aospxref.com/android-10.0.0_r47/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java&#xA;热修复原理 合并多个 dexElements 数组是插件化框架或热修复系统中的常见操作。你可以通过反射将多个 dex 元素合并成一个新的数组，然后注入回去。&#xA;这就是热修复的原理，把 新的 dex 添加到 dexElements 前面，那么 findClass 的时候就会优先使用最新的 dex 中的类&#xA;代码实现 通过反射拿到 ClassLoader 中的 dexElements 数组 fun getDexElementsFrom(classLoader: ClassLoader): Array&amp;lt;Any&amp;gt;? {&#xD;return try {&#xD;// 1.</description>
    </item>
    <item>
      <title>深入剖析 Android 加壳应用运行流程与生命周期劫持方案</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-android-%E5%8A%A0%E5%A3%B3%E5%BA%94%E7%94%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8A%AB%E6%8C%81%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 21 Jul 2025 01:25:40 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-android-%E5%8A%A0%E5%A3%B3%E5%BA%94%E7%94%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8A%AB%E6%8C%81%E6%96%B9%E6%A1%88/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;DexClassLoader DexClassLoader 可以加载任意路径下的 dex，或者 jar、apk、zip 文件（包含classes.dex）。常用于插件化、热修复以及 dex 加壳。&#xA;源码如下：&#xA;public class DexClassLoader extends BaseDexClassLoader {&#xD;public DexClassLoader(String dexPath, String optimizedDirectory,&#xD;String librarySearchPath, ClassLoader parent) {&#xD;super(dexPath, null, librarySearchPath, parent);&#xD;}&#xD;} http://aospxref.com/android-10.0.0_r47/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java&#xA;参数说明&#xA;参数 类型 说明 dexPath String 需要加载的 dex、apk、jar、zip 文件的路径，多个路径用 : 分隔。支持任意目录下的文件。 optimizedDirectory String 用于存放优化后的 dex 文件（即 .odex），在 API level 26 已弃用（Android 8.0 Oreo）。 librarySearchPath String 指定本地库（native library，.so 文件）搜索路径，多个路径用 : 分隔。 parent ClassLoader 父类加载器，用于实现类加载的委托机制。 动态加载 动态加载 = 运行时按需加载代码或资源</description>
    </item>
    <item>
      <title>深入理解 Android ClassLoader 与双亲委派机制</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-android-classloader-%E4%B8%8E%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 21 Jul 2025 00:40:30 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-android-classloader-%E4%B8%8E%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;类加载器 ClassLoader 在 JVM（Java Virtual Machine）中，类加载器（ClassLoader）负责将 .class 文件加载到内存中，并将其转换为 JVM 可以使用的 Class 对象。&#xA;JVM 中主要有以下几种类加载器（ClassLoader）：&#xA;1. 引导类加载器（Bootstrap ClassLoader） 加载内容：JDK 的核心类库（JAVA_HOME/lib 下的类，如 rt.jar、java.lang、java.util 等系统类）。&#xA;由 C/C++ 实现，是 JVM 的一部分，JVM 的启动就是通过 Bottstrap ，不是 Java 类。&#xA;没有父类加载器（即 getParent() 返回 null）。&#xA;2. 拓展类加载器（Extension ClassLoader） 加载内容：JAVA_HOME/lib/ext/ 目录或由 java.ext.dirs 指定的路径中的类。&#xA;实现类：sun.misc.Launcher$ExtClassLoader&#xA;父加载器：Bootstrap ClassLoader&#xA;3. 应用类加载器（Application ClassLoader） 加载内容：用户类路径（classpath）上的类，比如通过 -cp 或 -classpath 指定的类和 jar。&#xA;实现类：sun.misc.Launcher$AppClassLoader&#xA;父加载器：Extension ClassLoader&#xA;我们编写的大部分 Java 应用程序类就是由它加载的，ClassLoader.getSystemClassLoader 返回的就是它。&#xA;自定义类加载器 通过继承 java.lang.ClassLoader 自定义类加载器，实现自己的类加载逻辑，比如从网络、数据库、加密文件中加载类。&#xA;类加载顺序，比如：YourCustomClassLoader.findClass( classX.class)</description>
    </item>
    <item>
      <title>深入 ART Dex 加载流程，玩转 Android 通用脱壳点</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5-art-dex-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E7%8E%A9%E8%BD%AC-android-%E9%80%9A%E7%94%A8%E8%84%B1%E5%A3%B3%E7%82%B9/</link>
      <pubDate>Mon, 21 Jul 2025 00:06:23 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5-art-dex-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E7%8E%A9%E8%BD%AC-android-%E9%80%9A%E7%94%A8%E8%84%B1%E5%A3%B3%E7%82%B9/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;DEF CON DEF CON 是全球最大的计算机安全会议之一（极客的奥斯卡），自1993年6月起，每年在美国内华达州的拉斯维加斯举办。&#xA;官网：https://media.defcon.org/，DEF CON 黑客大会官方的媒体存档站点，提供历年 DEF CON 大会的公开演讲、幻灯片、视频、音频、代码示例和其他相关资源的免费下载。&#xA;在 DEF CON 25（2017 年）上，Check Point 的安全研究员 Slava Makkaveev 和 Avi Bashan 发表了题为《Unboxing Android: Everything You Wanted to Know About Android Packers》的演讲，深入探讨了 Android 应用程序中的加壳技术及其安全影响。&#xA;报告文件地址：&#xA;https://media.defcon.org/DEF%20CON%2025/DEF%20CON%2025%20presentations/DEF%20CON%2025%20-%20Slava-Makkaveev-and-Avi-Bashan-Unboxing-Android.pdf&#xA;对于国内加壳厂商也有分析&#xA;DEF 的安全研究员选择的两个脱壳点：art::OpenAndReadMagic 和 DexFile::DexFile&#xA;Unboxing Android 在 DEF CON 25 (2017) 上，Avi Bashan 和 Slava Makkaveev 提出过一种非常实用的 Android 加壳脱壳技术：&#xA;通过修改 DexFile::DexFile() 构造函数和 OpenAndReadMagic() 方法，可以在应用运行时，拦截 DEX 文件加载过程，从而拿到已经解密后的内存数据，完成脱壳。&#xA;1. DexFile::DexFile 构造函数 可以看到 DexFile::DexFile() 的构造函数参数里包含了：</description>
    </item>
    <item>
      <title>打造自己的 Jar 文件分析工具：类名匹配 &#43; 二进制搜索 &#43; 日志输出全搞定</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84-jar-%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%90%8D%E5%8C%B9%E9%85%8D-&#43;-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%90%9C%E7%B4%A2-&#43;-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E5%85%A8%E6%90%9E%E5%AE%9A/</link>
      <pubDate>Sun, 20 Jul 2025 23:11:43 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84-jar-%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%90%8D%E5%8C%B9%E9%85%8D-&#43;-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%90%9C%E7%B4%A2-&#43;-%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E5%85%A8%E6%90%9E%E5%AE%9A/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 在逆向分析、APK 解包或 Java 工程排查中，我们常常需要检查某个 .class 文件是否存在于某个 JAR 包中，或者判断某个关键字是否被硬编码在类的字节码里。&#xA;如何通过编写 Python 脚本，帮助你在 JAR 文件中快速定位类、字段，甚至二进制内容。&#xA;类路径匹配（路径前缀） JAR 文件本质是 ZIP 文件，通过 zipfile.ZipFile 解压后可遍历所有文件名（也就是 .class 路径），我们只需检查是否以某个前缀开头即可。&#xA;with zipfile.ZipFile(jar_path, &amp;#39;r&amp;#39;) as jar:&#xD;for entry in jar.namelist():&#xD;if entry.endswith(&amp;#34;.class&amp;#34;) and entry.startswith(class_prefix_path):&#xD;print(f&amp;#34;[✓] Found in: {jar_path} → {entry}&amp;#34;)&#xD;found.append((jar_path, entry)) 字节码字段查找（二进制匹配） 通过读取 .class 文件的二进制数据，可以判断是否存在某个硬编码字符串。比如我们要查找 &amp;ldquo;VERSION_NAME&amp;rdquo; 是否被写入类的常量池中，就可以用这种方式。&#xA;with zipfile.ZipFile(jar_path, &amp;#39;r&amp;#39;) as jar:&#xD;for entry in jar.namelist():&#xD;if entry.endswith(&amp;#34;.class&amp;#34;):&#xD;try:&#xD;with jar.open(entry) as class_file:&#xD;content = class_file.</description>
    </item>
    <item>
      <title>一文搞懂 Smali 与 Baksmali：Java 层逆向必备技能</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-smali-%E4%B8%8E-baksmalijava-%E5%B1%82%E9%80%86%E5%90%91%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/</link>
      <pubDate>Sun, 20 Jul 2025 18:43:51 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-smali-%E4%B8%8E-baksmalijava-%E5%B1%82%E9%80%86%E5%90%91%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;smali 与 baksmali smali 和 baksmali 是用于 Android 平台中 DEX 文件的汇编器和反汇编器，广泛应用于 Android 逆向分析与调试。&#xA;smali 和 baksmali 是一对工具，分别用于：&#xA;smali：将 smali 代码（Java汇编语言）编译成 DEX 文件。&#xA;baksmali：将 DEX 文件反汇编为 smali 代码。&#xA;开源地址：&#xA;https://github.com/JesusFreke/smali&#xA;https://github.com/google/smali&#xA;Release版本下载地址：https://github.com/baksmali/smali/releases&#xA;使用 baksmali.jar 将 .dex 文件反汇编为 .smali java -jar baksmali.jar disassemble &amp;#34;D:\Python\anti-app\app\douyin\dump_dex\base.apk.dex&amp;#34; -o smali 输入 DEX 文件路径。&#xA;-o smali：指定输出目录，保存生成的 .smali 文件。&#xA;你也可以加上 &amp;ndash;api 指定 Android API 级别：&#xA;java -jar baksmali.jar d &amp;#34;D:\Python\anti-app\app\douyin\dump_dex\base.apk.dex&amp;#34; -o smali --api 33 使用 smali.jar 将 .</description>
    </item>
    <item>
      <title>彻底搞懂 Retrofit：使用、封装与 Converter 原理</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-retrofit%E4%BD%BF%E7%94%A8%E5%B0%81%E8%A3%85%E4%B8%8E-converter-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 19 Jul 2025 00:37:35 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-retrofit%E4%BD%BF%E7%94%A8%E5%B0%81%E8%A3%85%E4%B8%8E-converter-%E5%8E%9F%E7%90%86/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Retrofit 简介 Retrofit 是 Square 公司开发的一个 类型安全的 HTTP 网络请求库，广泛应用于 Android 开发中。它极大地简化了 REST API 的调用方式，让网络请求就像调用本地接口一样简单。&#xA;基于 OkHttp 实现底层通信，提供了：&#xA;注解方式定义 API 接口&#xA;自动将 JSON/XML 响应解析为 Java/Kotlin 对象&#xA;支持多种 Converter（如 Gson、Moshi、Protobuf）&#xA;支持协程、RxJava、LiveData 等异步处理方式&#xA;与 OkHttp 关系：&#xA;Retrofit 是高级封装，负责将请求/响应转换为 Java 对象&#xA;OkHttp 是底层网络传输库，处理连接、缓存、拦截器等&#xA;Retrofit 默认使用 OkHttp，可以无缝集成 OkHttp 的功能（如添加 Token 拦截器）&#xA;开源地址：https://github.com/square/retrofit&#xA;集成 Retrofit 在 app 的 build.gradle.kts 添加如下依赖：&#xA;// Retrofit 核心库&#xD;implementation(&amp;#34;com.squareup.retrofit2:retrofit:2.9.0&amp;#34;)&#xD;// JSON 转换器（使用 Gson）&#xD;implementation(&amp;#34;com.squareup.retrofit2:converter-gson:2.9.0&amp;#34;)&#xD;// OkHttp&#xD;implementation(&amp;#34;com.squareup.okhttp3:okhttp:4.12.0&amp;#34;)&#xD;// OkHttp 日志拦截器（可选，用于调试）&#xD;implementation(&amp;#34;com.</description>
    </item>
    <item>
      <title>Unidbg Trace 实战：一步步还原 OLLVM 控制流平坦化算法</title>
      <link>https://cyrus-studio.github.io/blog/posts/unidbg-trace-%E5%AE%9E%E6%88%98%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%BF%98%E5%8E%9F-ollvm-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 12 Jul 2025 18:38:53 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/unidbg-trace-%E5%AE%9E%E6%88%98%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%BF%98%E5%8E%9F-ollvm-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%AE%97%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;目标 so 分析（OLLVM fla） 目标方法反汇编视图如下&#xA;F5 反汇编代码如下，反汇编代码中有大量的 while ( 1 )，通过修改 i 的值切换执行不同的代码块，很明显是通过 OLLVM fla 隐藏了真实的执行流。&#xA;__int64 __usercall dynamicBase64Encode@&amp;lt;X0&amp;gt;(const unsigned __int8 *a1@&amp;lt;X0&amp;gt;, unsigned __int64 a2@&amp;lt;X1&amp;gt;, __int64 a3@&amp;lt;X8&amp;gt;)&#xD;{&#xD;int v3; // w8&#xD;int v4; // w8&#xD;unsigned __int8 *v5; // x0&#xD;int v6; // w8&#xD;unsigned __int8 *v7; // x0&#xD;__int64 result; // x0&#xD;int i; // [xsp+20h] [xbp-60h]&#xD;unsigned __int64 v11; // [xsp+30h] [xbp-50h]&#xD;int v12; // [xsp+3Ch] [xbp-44h]&#xD;int v13; // [xsp+40h] [xbp-40h]&#xD;char v16[24]; // [xsp+60h] [xbp-20h] BYREF&#xD;__int64 v17; // [xsp+78h] [xbp-8h]&#xD;v17 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);&#xD;generateDynamicBase64Alphabet(a2);&#xD;sub_29574(a3);&#xD;v13 = 0;&#xD;v12 = -6;&#xD;v11 = 0LL;&#xD;do&#xD;{&#xD;if ( v11 &amp;gt;= a2 )&#xD;v3 = 491;&#xD;else&#xD;v3 = 26962;&#xD;for ( i = v3; ; i = 24464 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( 1 )&#xD;{&#xD;while ( i == 491 )&#xD;{&#xD;if ( v12 &amp;lt;= -6 )&#xD;v6 = 4827;&#xD;else&#xD;v6 = 2995;&#xD;i = v6;&#xD;}&#xD;if ( i !</description>
    </item>
    <item>
      <title>unidbg 调试技巧全指南：掌握 Console Debugger 的正确姿势</title>
      <link>https://cyrus-studio.github.io/blog/posts/unidbg-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E5%85%A8%E6%8C%87%E5%8D%97%E6%8E%8C%E6%8F%A1-console-debugger-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</link>
      <pubDate>Sat, 12 Jul 2025 18:24:38 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/unidbg-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E5%85%A8%E6%8C%87%E5%8D%97%E6%8E%8C%E6%8F%A1-console-debugger-%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;打开debug日志 编辑 unidbg-android/src/test/resources/log4j.properties 把 log4j.logger.com.github.unidbg.AbstractEmulator 改为 DEBUG&#xA;当运行报错时会自动断点，可以看到具体报错的位置、寄存器、机器码等等信息。&#xA;[03:20:11 438] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:364) - emulate RX@0x121daa74[libc.so]0x1aa74 started sp=unidbg@0xe4fff700&#xD;[03:20:11 457] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:402) - emulate RX@0x121daa74[libc.so]0x1aa74 finished sp=unidbg@0xe4fff700, offset=18ms&#xD;[03:20:11 458] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:364) - emulate RX@0x121daa98[libc.so]0x1aa98 started sp=unidbg@0xe4fff700&#xD;[03:20:11 458] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:402) - emulate RX@0x121daa98[libc.so]0x1aa98 finished sp=unidbg@0xe4fff700, offset=0ms&#xD;[03:20:11 458] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:364) - emulate RX@0x121daaac[libc.so]0x1aaac started sp=unidbg@0xe4fff700&#xD;[03:20:11 459] DEBUG [com.github.unidbg.AbstractEmulator] (AbstractEmulator:402) - emulate RX@0x121daaac[libc.so]0x1aaac finished sp=unidbg@0xe4fff700, offset=0ms&#xD;[03:20:11 459] DEBUG [com.</description>
    </item>
    <item>
      <title>unidbg 加载 so 并调用函数：dynarmic &amp; unicorn、指针传参、寄存器读取</title>
      <link>https://cyrus-studio.github.io/blog/posts/unidbg-%E5%8A%A0%E8%BD%BD-so-%E5%B9%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0dynarmic--unicorn%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%BB%E5%8F%96/</link>
      <pubDate>Sat, 12 Jul 2025 18:13:18 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/unidbg-%E5%8A%A0%E8%BD%BD-so-%E5%B9%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0dynarmic--unicorn%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%BB%E5%8F%96/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;unidbg 简介 unidbg 是一个基于 Java 的 Android 动态分析框架，专注于模拟 Android 应用中的 native 代码。以下是它的主要功能：&#xA;支持对so的加载;&#xA;支持对JNI接口函数的模拟调用;&#xA;支持常见syscalls的模拟调用;&#xA;支持ARM32和ARM64。&#xA;支持Android以及iOS&#xA;基于HookZz实现的inline hook&#xA;xHook实现的hook&#xA;iOS fishhook，substrate、whale hook等&#xA;支持gdb、IDA远程调试等高级功能。&#xA;&amp;hellip;&#xA;Unidgb 项目地址：https://github.com/zhkl0228/unidbg&#xA;unidbg 底层引擎 unidbg 的 CPU 指令模拟主要由 dynarmic 和 unicorn 驱动。&#xA;dynarmic 是专注于 ARM 架构的模拟器，虽然它和 unicorn 都提供 ARM 模拟功能，但它们的设计目标和性能特点不同。unicorn 更加通用，而 dynarmic 则更注重效率。&#xA;dynarmic 项目地址：https://github.com/yuzu-mirror/dynarmic&#xA;Unicorn 项目地址：https://github.com/unicorn-engine/unicorn&#xA;dynarmic 与 unicorn 效率对比 clone unidbg 源码到本地并导入 IDEA，在 unidbg-android/src/test/java/com/kanxue/test2&#xA;MainActivity.java 中示例代码实现了爆破 so 中 test 函数 flag 参数（已知 so 中 test 函数参数为一个字符串，该字符串长度为3且仅包含大小写字母），如果 flag 正确函数会返回 true，通过不断调用该 jni 函数测试所有字母组合直到得到正确结果。</description>
    </item>
    <item>
      <title>如何用 unidbg 模拟 JNI 与 Java 交互？完整教程 &#43; 源码实战</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E7%94%A8-unidbg-%E6%A8%A1%E6%8B%9F-jni-%E4%B8%8E-java-%E4%BA%A4%E4%BA%92%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B-&#43;-%E6%BA%90%E7%A0%81%E5%AE%9E%E6%88%98/</link>
      <pubDate>Sat, 12 Jul 2025 16:59:02 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E7%94%A8-unidbg-%E6%A8%A1%E6%8B%9F-jni-%E4%B8%8E-java-%E4%BA%A4%E4%BA%92%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B-&#43;-%E6%BA%90%E7%A0%81%E5%AE%9E%E6%88%98/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Android 示例代码 在 com.cyrus.example.unidbg.UnidbgActivity 编写一个静态变量 a 和非静态变量 b，还有 base64 方法。&#xA;代码如下：&#xA;package com.cyrus.example.unidbg&#xD;import android.os.Bundle&#xD;import androidx.appcompat.app.AppCompatActivity&#xD;import android.util.Base64&#xD;class UnidbgActivity : AppCompatActivity() {&#xD;companion object {&#xD;// 静态变量 a&#xD;var a: String? = null&#xD;}&#xD;// 非静态变量 b&#xD;var b: String? = null&#xD;override fun onCreate(savedInstanceState: Bundle?) {&#xD;super.onCreate(savedInstanceState)&#xD;setContentView(R.layout.activity_unidbg)&#xD;// 初始化静态变量 a 和 非静态变量 b&#xD;a = &amp;#34;StaticA&amp;#34;&#xD;b = &amp;#34;NonStaticB&amp;#34;&#xD;}&#xD;// Base64 方法&#xD;fun base64(content: String): String {&#xD;val combined = (a ?</description>
    </item>
    <item>
      <title>如何用 Unicorn 模拟器进行栈访问与 Patch 操作？</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E7%94%A8-unicorn-%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%A0%88%E8%AE%BF%E9%97%AE%E4%B8%8E-patch-%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sat, 12 Jul 2025 16:43:03 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E7%94%A8-unicorn-%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%A0%88%E8%AE%BF%E9%97%AE%E4%B8%8E-patch-%E6%93%8D%E4%BD%9C/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;struct.pack 方法介绍 struct.pack 是 Python 标准库 struct 模块中的一个函数，它用于将 Python 的基本数据类型（如 int、float、long）打包为字节流，以便在二进制文件、网络传输或内存操作（如 Unicorn 仿真器的 mem_write）中使用。&#xA;语法：&#xA;import struct&#xD;struct.pack(format, value) format：指定数据的格式，例如：&#xA;&amp;lt;f：表示小端（&amp;lt;）的 4 字节浮点数（float）&#xA;&amp;lt;d：表示小端的 8 字节双精度浮点数（double）&#xA;value：要转换的 Python 值。&#xA;数据类型格式&#xA;数据类型 有符号格式（小写） 无符号格式（大写） 大小（字节） byte b (char) B (uchar) 1 short h (short) H (ushort) 2 int i (int) I (uint) 4 long q (long long) Q (ulong long) 8 float f (float) 无 4 double d (double) 无 8 其他特殊类型</description>
    </item>
    <item>
      <title>使用 Unicorn 执行 JNI 函数：so 反汇编 &#43; 参数传递 &#43; 结果读取</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-unicorn-%E6%89%A7%E8%A1%8C-jni-%E5%87%BD%E6%95%B0so-%E5%8F%8D%E6%B1%87%E7%BC%96-&#43;-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-&#43;-%E7%BB%93%E6%9E%9C%E8%AF%BB%E5%8F%96/</link>
      <pubDate>Sat, 12 Jul 2025 16:33:46 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BD%BF%E7%94%A8-unicorn-%E6%89%A7%E8%A1%8C-jni-%E5%87%BD%E6%95%B0so-%E5%8F%8D%E6%B1%87%E7%BC%96-&#43;-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-&#43;-%E7%BB%93%E6%9E%9C%E8%AF%BB%E5%8F%96/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Android 示例代码 编写一个 jni 方法 add 进行简单的加法运算 ，代码如下：&#xA;#include &amp;lt;jni.h&amp;gt;&#xD;// 实现加法运算&#xD;extern &amp;#34;C&amp;#34;&#xD;JNIEXPORT jint JNICALL&#xD;Java_com_cyrus_example_unicorn_UnicornActivity_add(JNIEnv *env, jobject thiz, jint a, jint b) {&#xD;return a + b;&#xD;} 配置 CMakeLists.txt&#xA;add_library( # 设置库的名称&#xD;unicorn&#xD;# 设置库的类型&#xD;SHARED&#xD;# 设置源文件路径&#xD;unicorn.cpp)&#xD;target_link_libraries( # 将 log 库链接到目标库&#xD;unicorn&#xD;${log-lib}) 完整源码地址：https://github.com/CYRUS-STUDIO/AndroidExample&#xA;编译运行 Android 项目后在 build 目录找打 apk 并解压 libunicorn.so。&#xA;加载 so 并反汇编 通过 IDA 打开 so 文件可以看到 add 方法的开始地址为 0x0608，结束地址为 0x063C</description>
    </item>
    <item>
      <title>用 AndroidNativeEmu 实现 JNI 函数调用模拟</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%94%A8-androidnativeemu-%E5%AE%9E%E7%8E%B0-jni-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Sat, 12 Jul 2025 16:33:18 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%94%A8-androidnativeemu-%E5%AE%9E%E7%8E%B0-jni-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A8%A1%E6%8B%9F/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;AndroidNativeEmu AndroidNativeEmu 专为 Android 原生代码调试和模拟设计，特别关注 JNI 调用和 Android 环境。相比之下，Unicorn 是通用的多平台 CPU 模拟器，适用于更广泛的原生代码分析。&#xA;项目地址：https://github.com/AeonLucid/AndroidNativeEmu&#xA;支持的功能：&#xA;elf 文件解析及 so 加载&#xA;栈支持&#xA;内存管理&#xA;文件系统&#xA;JNI 支持&#xA;常见 syacall 模拟支持&#xA;&amp;hellip;&#xA;但是，暂时不支持 arm64。&#xA;系统调用 AndroidNativeEmu 系统调用的模拟实现都在 cpu/intertupt_handler.py，根据不同的 intno 调用具体的 handler&#xA;目前已经实现的系统调用可以在 syscall_hooks.py 看到&#xA;JNIEnv 对应 JNI 接口的模拟实现在 src/androidemu/java/jni_env.py，通过 write_function_table 方法模拟实现 JNI 函数表&#xA;jni 函数代码是通过 keystone 来生成的，具体代码在：src/androidemu/hooker.py&#xA;so 加载过程中，对 so 中导入符号的 Hook，具体代码在：src/androidemu/native/hooks.py&#xA;AndroidNativeEmu 默认已经实现的外部函数&#xA;native_method 装饰器 native_method 装饰器用于在 AndroidNativeEmu 中将 Python 函数标记为模拟的 JNI 原生方法，允许函数在模拟器中执行并与 Android 的原生方法交互。</description>
    </item>
    <item>
      <title>如何让 Google 收录你的 GitHub Pages 博客？一文讲透 SEO 设置全流程</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E8%AE%A9-google-%E6%94%B6%E5%BD%95%E4%BD%A0%E7%9A%84-github-pages-%E5%8D%9A%E5%AE%A2%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%8F-seo-%E8%AE%BE%E7%BD%AE%E5%85%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sat, 12 Jul 2025 15:46:20 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E8%AE%A9-google-%E6%94%B6%E5%BD%95%E4%BD%A0%E7%9A%84-github-pages-%E5%8D%9A%E5%AE%A2%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%8F-seo-%E8%AE%BE%E7%BD%AE%E5%85%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;如何确认自己的网站有没有被 google 收录 假设网址是：https://cyrus-studio.github.io/blog&#xA;搜索：site:https://cyrus-studio.github.io/blog，如果没有任何内容就是没有被收录。&#xA;提交站点到 Google Search Console 点击 “尝试使用 Google Search Console”，输入网址，点击继续&#xA;验证站点所有权，下载一个 googlexxxx.html 文件&#xA;将此文件放在你的 GitHub Pages 仓库下的根目录下，git push 重新构建网站&#xA;确认能正常访问：https://cyrus-studio.github.io/blog/google831ed0d6f75c24f0.html&#xA;点击验证按钮&#xA;验证完成&#xA;等待收录&#xA;提交 Sitemap（可选但推荐） Sitemap 能帮助 Google 更好地理解你的网站结构。&#xA;Hugo 默认生成 sitemap 于：&#xA;https://cyrus-studio.github.io/blog/sitemap.xml 在 Google Search Console 中提交这个 sitemap：&#xA;打开你的属性&#xA;点击左侧“索引 &amp;gt; Sitemap ”&#xA;输入 sitemap.xml 并提交&#xA;添加 robots.txt（确认允许爬取） 在你的仓库中添加 robots.txt 文件：&#xA;User-agent: *&#xD;Allow: /&#xD;Sitemap: https://cyrus-studio.github.io/blog/sitemap.xml 确保 Google bot 被允许访问页面。&#xA;git push</description>
    </item>
    <item>
      <title>从 DOCX 到 Markdown 多平台发布：Hugo &#43; GitHub Pages 全流程实战</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%BB%8E-docx-%E5%88%B0-markdown-%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%8F%91%E5%B8%83hugo-&#43;-github-pages-%E5%85%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E6%88%98/</link>
      <pubDate>Sat, 12 Jul 2025 15:42:33 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%BB%8E-docx-%E5%88%B0-markdown-%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%8F%91%E5%B8%83hugo-&#43;-github-pages-%E5%85%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E6%88%98/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;docx转换markdown 尝试了几个docx转markdown的python库后，最终选择了python-mammoth，轻量，效率高，可自定义转换满足特定需求。&#xA;python-mammoth python-mammoth 是一个用于将 Microsoft Word (DOCX) 文档转换为 HTML 或 Markdown 的 Python 库。&#xA;github地址：https://github.com/mwilliamson/python-mammoth&#xA;安装 python-mammoth&#xA;pip install mammoth 自定义代码块样式 通过自定义 transform 来实现自定义的代码块样式来支持有道云docx的代码块&#xA;def ynote_docx_markdown_transform(document):&#xD;...&#xD;pass&#xD;result = convert_to_markdown(docx_file, transform_document=ynote_docx_markdown_transform) 通过在自定义 transform 断点调试可以看到 document 都是由一个一个 Paragraph 组成的，代码块的 Bookmark 的 name 都是相同的，由此代码块其中一个特征就是相同且相邻的 Bookmark name。&#xA;但是有的代码块只是单独的一段&#xA;这时可以通过自定义 代码/bash 特征判断该 Paragraph 中的 Text 是不是一段 代码/bash。&#xA;def is_possible_code_or_bash(text):&#xD;# 常见的代码关键字&#xD;code_keywords = [&#xD;r&amp;#39;\bif\b&amp;#39;, r&amp;#39;\bfor\b&amp;#39;, r&amp;#39;\bwhile\b&amp;#39;, r&amp;#39;\bdef\b&amp;#39;, r&amp;#39;\bclass\b&amp;#39;, r&amp;#39;\breturn\b&amp;#39;, r&amp;#39;\bimport\b&amp;#39;,&#xD;r&amp;#39;\bint\b&amp;#39;, r&amp;#39;\bfloat\b&amp;#39;, r&amp;#39;\bmain\b&amp;#39;, r&amp;#39;\binclude\b&amp;#39;, r&amp;#39;#include&amp;#39;, r&amp;#39;\becho\b&amp;#39;, r&amp;#39;\bcd\b&amp;#39;,&#xD;r&amp;#39;\bgrep\b&amp;#39;, r&amp;#39;\bexit\b&amp;#39;, r&amp;#39;\belse\b&amp;#39;, r&amp;#39;\belif\b&amp;#39;, r&amp;#39;#!</description>
    </item>
    <item>
      <title>0 成本搭建个人技术博客：用 Hugo &#43; GitHub Pages 快速上线</title>
      <link>https://cyrus-studio.github.io/blog/posts/0-%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%94%A8-hugo-&#43;-github-pages-%E5%BF%AB%E9%80%9F%E4%B8%8A%E7%BA%BF/</link>
      <pubDate>Sat, 12 Jul 2025 15:29:30 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/0-%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%94%A8-hugo-&#43;-github-pages-%E5%BF%AB%E9%80%9F%E4%B8%8A%E7%BA%BF/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;使用 Chocolatey 安装 Hugo Chocolatey 是一个 Windows 软件包管理器，使用 PowerShell 和 NuGet 作为基础。它可以自动化软件的安装、升级和卸载过程。&#xA;安装 Chocolatey（如果还没有安装） Chocolatey 允许你通过设置环境变量来更改默认安装路径。在安装 Chocolatey 之前，你需要设置 ChocolateyInstall 环境变量来指定新的安装路径。&#xA;打开 PowerShell（以管理员身份运行），并执行以下命令指定自定义安装路径&#xA;[System.Environment]::SetEnvironmentVariable(&amp;#39;ChocolateyInstall&amp;#39;, &amp;#39;D:\App\chocolatey&amp;#39;, [System.EnvironmentVariableTarget]::Machine) 如果不设置默认安装路径为：C:\ProgramData\chocolatey&#xA;设置完 ChocolateyInstall 环境变量后，重新打开一下会话，执行下面的命令检查一下是否设置成功&#xA;Get-Item Env:ChocolateyInstall 打开 PowerShell（以管理员身份运行），执行以下命令安装 Chocolatey&#xA;Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&amp;#39;https://community.chocolatey.org/install.ps1&amp;#39;)) 检查是否安装成功&#xA;choco -h 安装 Hugo 在 PowerShell 中运行以下命令安装 Hugo&#xA;安装软件包&#xA;choco install hugo -confirm 升级软件包&#xA;choco upgrade hugo 卸载软件包&#xA;choco uninstall hugo 验证安装</description>
    </item>
    <item>
      <title>在 Hugo 博客中优雅集成 Waline：实现评论 &#43; 浏览量统计功能全指南</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%9C%A8-hugo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BC%98%E9%9B%85%E9%9B%86%E6%88%90-waline%E5%AE%9E%E7%8E%B0%E8%AF%84%E8%AE%BA-&#43;-%E6%B5%8F%E8%A7%88%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%E5%85%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sat, 12 Jul 2025 15:24:35 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%9C%A8-hugo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BC%98%E9%9B%85%E9%9B%86%E6%88%90-waline%E5%AE%9E%E7%8E%B0%E8%AF%84%E8%AE%BA-&#43;-%E6%B5%8F%E8%A7%88%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%E5%85%A8%E6%8C%87%E5%8D%97/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;关于 Waline Waline 是一个轻量级、快速且安全的评论系统，适用于静态网站。&#xA;其主要特点包括：&#xA;轻量级：前端仅约 50KB，加载速度快。&#xA;支持 Markdown：支持完整的 Markdown 语法，方便用户撰写格式化评论。&#xA;多种部署方式：支持 Vercel、Netlify、CloudBase、Docker 等多种部署方式。&#xA;多种存储后端支持：支持 LeanCloud、MongoDB、MySQL、SQLite 等多种数据库。&#xA;安全性：具备防刷频、IP 黑名单、评论内容重复检查等安全功能。&#xA;社交登录支持：支持 QQ、微信、Telegram 等社交平台登录。&#xA;通知功能：支持邮件、微信、QQ、Telegram 等通知方式。&#xA;Waline 是开源的，采用 GPL-2.0 许可证。&#xA;官网：https://waline.js.org/&#xA;开源地址：https://github.com/walinejs/waline&#xA;快速上手：https://waline.js.org/guide/get-started/&#xA;LeanCloud 设置 (数据库) 创建评论数据存储数据库。&#xA;1、登录 或 注册 LeanCloud 国际版 并进入 控制台&#xA;https://console.leancloud.app/apps&#xA;2、点击左上角 创建应用 并起一个你喜欢的名字 (请选择免费的开发版):&#xA;3、进入应用，选择左下角的 设置 &amp;gt; 应用 Key。你可以看到你的 APP ID,APP Key 和 Master Key。请记录它们，以便后续使用。&#xA;Vercel 部署 (服务端) 1、点击下面链接，跳转至 Vercel 进行 Server 端部署。&#xA;https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample&#xA;注：如果你未登录的话，Vercel 会让你注册或登录，请使用 GitHub 账户进行快捷登录。</description>
    </item>
    <item>
      <title>一文掌握 jnitrace：Frida 下分析 JNI 方法调用的利器</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%8E%8C%E6%8F%A1-jnitracefrida-%E4%B8%8B%E5%88%86%E6%9E%90-jni-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%88%A9%E5%99%A8/</link>
      <pubDate>Fri, 11 Jul 2025 13:17:44 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%8E%8C%E6%8F%A1-jnitracefrida-%E4%B8%8B%E5%88%86%E6%9E%90-jni-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%88%A9%E5%99%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;jnitrace jnitrace 可以动态跟踪 Java 层通过 JNI 接口调用 native 层（C/C++）代码的过程。它会记录并显示每一个 JNI 函数的调用，包括方法签名、参数、返回值等详细信息。&#xA;项目地址：https://github.com/chame1eon/jnitrace&#xA;安装 jnitrace jnitrace 的使用依赖于 Frida。在使用 jnitrace 之前，需要确保 Frida 和 Python 环境已安装。可以参考下面两篇文章：&#xA;一文搞懂如何使用 Frida Hook Android App&#xA;使用Miniconda管理Python环境&#xA;通过下面的命令安装 jnitrace&#xA;pip install jnitrace 解决 frida.NotSupportedError 运行 jnitrace 报错如下&#xA;jnitrace -l libnative-lib.so com.cyrus.exammple&#xD;Traceback (most recent call last):&#xD;File &amp;#34;D:\App\Miniconda3\envs\anti-app\lib\runpy.py&amp;#34;, line 194, in _run_module_as_main&#xD;return _run_code(code, main_globals, None,&#xD;File &amp;#34;D:\App\Miniconda3\envs\anti-app\lib\runpy.py&amp;#34;, line 87, in _run_code&#xD;exec(code, run_globals)&#xD;File &amp;#34;D:\App\Miniconda3\envs\anti-app\Scripts\jnitrace.exe\__main__.py&amp;#34;, line 7, in &amp;lt;module&amp;gt;&#xD;File &amp;#34;D:\App\Miniconda3\envs\anti-app\lib\site-packages\jnitrace\jnitrace.</description>
    </item>
    <item>
      <title>Frida 玩转 JNI：方法地址追踪 &#43; 指令反汇编 &#43; Patch 注入</title>
      <link>https://cyrus-studio.github.io/blog/posts/frida-%E7%8E%A9%E8%BD%AC-jni%E6%96%B9%E6%B3%95%E5%9C%B0%E5%9D%80%E8%BF%BD%E8%B8%AA-&#43;-%E6%8C%87%E4%BB%A4%E5%8F%8D%E6%B1%87%E7%BC%96-&#43;-patch-%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Fri, 11 Jul 2025 13:00:34 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/frida-%E7%8E%A9%E8%BD%AC-jni%E6%96%B9%E6%B3%95%E5%9C%B0%E5%9D%80%E8%BF%BD%E8%B8%AA-&#43;-%E6%8C%87%E4%BB%A4%E5%8F%8D%E6%B1%87%E7%BC%96-&#43;-patch-%E6%B3%A8%E5%85%A5/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Frida 反汇编 Frida 提供了反汇编 API，主要用于对目标进程的代码进行动态分析，例如：&#xA;获取函数的机器代码并将其反汇编为汇编指令。&#xA;分析内存中的指令流。&#xA;这些功能在 Frida 的 Instruction 类中实现，基于 Capstone 实现的反汇编功能。&#xA;https://frida.re/docs/javascript-api/#instruction&#xA;比如，可以通过 Instruction.parse 方法反汇编指定地址的汇编信息&#xA;[Remote::AndroidExample]-&amp;gt; Instruction.parse(ptr(&amp;#34;0x7e7acdb9a0&amp;#34;));&#xD;{&#xD;&amp;#34;address&amp;#34;: &amp;#34;0x7e7acdb9a0&amp;#34;,&#xD;&amp;#34;groups&amp;#34;: [],&#xD;&amp;#34;mnemonic&amp;#34;: &amp;#34;sub&amp;#34;,&#xD;&amp;#34;next&amp;#34;: &amp;#34;0x7e7acdb9a4&amp;#34;,&#xD;&amp;#34;opStr&amp;#34;: &amp;#34;sp, sp, #0x10&amp;#34;,&#xD;&amp;#34;operands&amp;#34;: [&#xD;{&#xD;&amp;#34;type&amp;#34;: &amp;#34;reg&amp;#34;,&#xD;&amp;#34;value&amp;#34;: &amp;#34;sp&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;type&amp;#34;: &amp;#34;reg&amp;#34;,&#xD;&amp;#34;value&amp;#34;: &amp;#34;sp&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;type&amp;#34;: &amp;#34;imm&amp;#34;,&#xD;&amp;#34;value&amp;#34;: &amp;#34;16&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;regsRead&amp;#34;: [],&#xD;&amp;#34;regsWritten&amp;#34;: [],&#xD;&amp;#34;size&amp;#34;: 4&#xD;} Android 示例代码 定义一个 native 函数 add，计算 1+ 1 + 1 并返回结果。</description>
    </item>
    <item>
      <title>Unicorn Hook 机制全解析：指令、代码块、内存、系统调用</title>
      <link>https://cyrus-studio.github.io/blog/posts/unicorn-hook-%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90%E6%8C%87%E4%BB%A4%E4%BB%A3%E7%A0%81%E5%9D%97%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Fri, 11 Jul 2025 00:41:47 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/unicorn-hook-%E6%9C%BA%E5%88%B6%E5%85%A8%E8%A7%A3%E6%9E%90%E6%8C%87%E4%BB%A4%E4%BB%A3%E7%A0%81%E5%9D%97%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Hook 主要类型 在 Unicorn 中，Hook（钩子）用于在模拟过程中拦截 CPU 指令执行、内存访问等操作，以便分析和修改执行行为。&#xA;Unicorn 提供了多种 Hook 类型，每种类型用于不同场景：&#xA;Hook 类型 说明 示例 UC_HOOK_CODE 拦截每一条指令执行 监控指令流，反调试 UC_HOOK_BLOCK 拦截每个基本块执行 统计基本块执行次数 UC_HOOK_INTR 拦截中断指令（如 svc #0） 监控系统调用 UC_HOOK_MEM_READ 读取内存前触发 监视变量读取 UC_HOOK_MEM_WRITE 写入内存前触发 监视变量修改 UC_HOOK_MEM_FETCH 取指令前触发 捕获未映射代码执行 UC_HOOK_MEM_READ_UNMAPPED 读取未映射内存 捕获非法内存读取 UC_HOOK_MEM_WRITE_UNMAPPED 写入未映射内存 捕获非法内存写入 UC_HOOK_MEM_FETCH_UNMAPPED 取指未映射内存 捕获非法指令执行 UC_HOOK_INSN 拦截特定指令 监控 syscall、hlt 等 Hook 指令执行 (UC_HOOK_CODE) 用途 ：&#xA;监控所有执行的指令&#xA;记录寄存器变化&#xA;反调试&#xA;示例代码&#xA;from unicorn import *&#xD;from unicorn.arm64_const import *&#xD;# Hook 回调函数&#xD;def hook_code(mu, address, size, user_data):&#xD;print(f&amp;#34;Executing instruction at 0x{address:X}, size={size}&amp;#34;)&#xD;# 初始化 Unicorn ARM64&#xD;mu = Uc(UC_ARCH_ARM64, UC_MODE_ARM)&#xD;# 分配内存&#xD;BASE = 0x1000&#xD;mu.</description>
    </item>
    <item>
      <title>深入 Android syscall 实现：内联汇编系统调用 &#43; NDK 汇编构建</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5-android-syscall-%E5%AE%9E%E7%8E%B0%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-&#43;-ndk-%E6%B1%87%E7%BC%96%E6%9E%84%E5%BB%BA/</link>
      <pubDate>Fri, 11 Jul 2025 00:29:50 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%B7%B1%E5%85%A5-android-syscall-%E5%AE%9E%E7%8E%B0%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-&#43;-ndk-%E6%B1%87%E7%BC%96%E6%9E%84%E5%BB%BA/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;什么是系统调用 (syscall) 系统调用是操作系统提供给应用程序的一组接口，允许用户空间程序与内核进行交互。&#xA;在 Android（基于 Linux 内核）中，系统调用由 软中断 实现，通常通过 svc 指令（在 ARM 架构中）触发。系统调用会将 CPU 从用户模式切换到内核模式，使得程序可以执行更高权限的操作。&#xA;Android 使用的 C 库是 Bionic，它是为移动设备优化的轻量级 C 库。对应的模块为 libc.so。&#xA;Bionic 提供了对系统调用的封装。大多数标准库函数（如 printf、malloc、pthread_create）都通过 Bionic 实现，底层调用了相应的系统调用。&#xA;在 NDK 目录中可以找到相关的系统调用号定义头文件。例如&#xA;&amp;lt;NDK_PATH&amp;gt;\27.1.12297006\toolchains\llvm\prebuilt\windows-x86_64\sysroot\usr\include\asm-generic\unistd.h 搜索 bionic 模块 可以找到不同CPU架构下的 syscall 实现&#xA;在 bionic/libc/arch-arm64/syscalls/ 可以找到 Android 中所有系统调用的汇编代码文件&#xA;https://cs.android.com/android/platform/superproject/+/android10-release:bionic/libc/arch-arm64/syscalls/&#xA;syscall 在 Android 上的应用场景 系统工具和调试：如 strace、lsof 等工具，通过 syscall 获取系统状态。&#xA;安全与反调试：某些安全检测和反调试技术会直接使用 syscall 绕过标准的 libc 函数，以防止被 hook。&#xA;嵌入式开发：在一些嵌入式系统中，开发者需要直接控制硬件，这时通常会使用 syscall。&#xA;如何在 Android 中使用 syscall 假设我们希望通过 syscall 直接读取文件内容，编写 native 方法代码如下</description>
    </item>
    <item>
      <title>Android 下内联汇编开发指南：从基础语法到多架构适配全掌握</title>
      <link>https://cyrus-studio.github.io/blog/posts/android-%E4%B8%8B%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%BB%8E%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%88%B0%E5%A4%9A%E6%9E%B6%E6%9E%84%E9%80%82%E9%85%8D%E5%85%A8%E6%8E%8C%E6%8F%A1/</link>
      <pubDate>Thu, 10 Jul 2025 23:45:23 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-%E4%B8%8B%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%BB%8E%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%88%B0%E5%A4%9A%E6%9E%B6%E6%9E%84%E9%80%82%E9%85%8D%E5%85%A8%E6%8E%8C%E6%8F%A1/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;内联汇编 Android 内联汇编非常适用于 ARM 架构的性能优化和底层操作，通常用于加密、解密、特定指令优化等领域。&#xA;1. 基础语法 内联汇编在 C/C++ 代码中通过 asm 或 asm 关键字进行声明，格式如下&#xA;asm (&amp;#34;汇编指令&amp;#34; : 输出操作数 : 输入操作数 : 破坏描述符); 详细说明：&#xA;汇编指令：这是我们想要执行的汇编代码，通常是 ARM 或 ARM64 指令。&#xA;输出操作数：指定汇编代码的输出结果如何映射到 C++ 变量。&#xA;输入操作数：指定传递给汇编代码的输入。&#xA;破坏描述符：用于告诉编译器哪些寄存器或内存位置将被汇编代码修改，以避免编译器优化引起的问题。&#xA;2. 占位符 占位符用于在汇编指令中插入 C++ 变量，格式为 %0、%1 等，对应输出和输入操作数的顺序。&#xA;例如&#xA;int x = 10, y = 20, result;&#xD;asm(&amp;#34;add %0, %1, %2&amp;#34; : &amp;#34;=r&amp;#34;(result) : &amp;#34;r&amp;#34;(x), &amp;#34;r&amp;#34;(y)); 上面的代码将 x 和 y 相加并将结果存入 result。&#xA;3. 输出操作数和输入操作数 =r 表示输出操作数是一个通用寄存器类型。</description>
    </item>
    <item>
      <title>彻底搞懂 ARM 汇编中的条件标志：N、Z、C、V 有什么用？</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-arm-%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%A0%87%E5%BF%97nzcv-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/</link>
      <pubDate>Thu, 10 Jul 2025 23:35:38 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-arm-%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%A0%87%E5%BF%97nzcv-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;条件标志 在 ARM 指令集中，条件标志是控制指令执行的一种机制，它们用于实现条件分支、比较和其他逻辑操作。&#xA;我们平时使用 IDA 调试程序时，在 general registers 窗口中看到的条件标志&#xA;ARM 处理器通常使用四个主要的条件标志，它们的状态影响指令的执行。这些条件标志包括：&#xA;1、N (Negative): 负标志，用于指示最后一次操作的结果是否为负值。若结果为负，则 N 被置为 1；否则为 0。&#xA;2、Z (Zero): 零标志，用于指示最后一次操作的结果是否为零。如果结果为零，则 Z 被置为 1；否则为 0。&#xA;3、C (Carry): 进位标志，用于指示加法操作是否产生了进位或减法操作是否没有借位。对于加法，若产生进位，则 C 被置为 1；对于减法，若没有借位，则 C 被置为 1。&#xA;4、V (Overflow): 溢出标志，用于指示最后一次算术操作是否发生了溢出。当两个有符号数相加或相减时，如果结果的符号与操作数的符号不一致，表示发生了溢出，V 被置为 1。&#xA;在 ARM 指令中，条件执行可以通过附加条件码实现，例如：&#xA;EQ (Equal): 当 Z = 1 时执行（相等）。&#xA;NE (Not Equal): 当 Z = 0 时执行（不相等）。&#xA;GT (Greater Than): 当 Z = 0 且 N = V 时执行（大于）。</description>
    </item>
    <item>
      <title>搞懂 Thumb 汇编：指令集、编码方式与调试技巧全解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%90%9E%E6%87%82-thumb-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E4%B8%8E%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E5%85%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 10 Jul 2025 23:17:03 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%90%9E%E6%87%82-thumb-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E4%B8%8E%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E5%85%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Thumb指令集 ARM 指令集：最早在 1985 年随第一代 ARM 处理器问世。ARM 指令集一开始是 32 位固定长度的指令，用于各种计算任务。&#xA;Thumb 指令集：在 1994 年的 ARM7TDMI 处理器中首次引入。这是在 ARM 指令集基础上开发的一个 16 位指令集，旨在优化嵌入式系统中代码密度和内存效率。&#xA;寄存器 Thumb 跟 ARM 是一样的。&#xA;随着 ARM 架构的演进，后来加入了 32 位的 Thumb 指令，称为 Thumb-2 指令集。&#xA;以简单的加载立即数到寄存器为例，解释一下 16 位和 32 位的 Thumb 指令的区别&#xA;16 位 Thumb 指令&#xA;MOVS R0, #1 // 将立即数 1 加载到 R0，指令长度为 16 位 32 位 Thumb 指令&#xA;MOV.W R0, #65535 // 将较大的立即数 65535 加载到 R0，指令长度为 32 位 由于 16 位 Thumb 指令长度有限，无法直接处理大立即数，而 32 位 Thumb 指令支持更大的立即数范围。32 位指令格式可以容纳更多位的立即数、更复杂的操作码。</description>
    </item>
    <item>
      <title>ARM64 汇编实战指南：寻址方式 &#43; 指令分类 &#43; 编码原理全掌握</title>
      <link>https://cyrus-studio.github.io/blog/posts/arm64-%E6%B1%87%E7%BC%96%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-&#43;-%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB-&#43;-%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E5%85%A8%E6%8E%8C%E6%8F%A1/</link>
      <pubDate>Sat, 05 Jul 2025 19:34:40 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/arm64-%E6%B1%87%E7%BC%96%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-&#43;-%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB-&#43;-%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E5%85%A8%E6%8E%8C%E6%8F%A1/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;ARM64汇编寻址 1. 立即数寻址（Immediate Addressing） 这种方式直接将立即数作为操作数，适合小数据或常量。ARM64的立即数在指令中直接编码。&#xA;MOV X0, #10 ; 将常数10加载到寄存器X0中 2. 寄存器间接寻址（Register Indirect Addressing） 使用寄存器中的地址作为内存地址。适合基于寄存器值进行偏移的简单访问方式。&#xA;LDR X1, [X0] ; 将地址X0指向的内存内容加载到X1中 3. 偏移寻址（Offset Addressing） 在基地址寄存器的基础上添加一个偏移量来确定目标地址，偏移量可以是立即数或寄存器值。&#xA;LDR X1, [X0, #8] ; 从地址X0 + 8的位置加载数据到X1中 4. 预索引寻址（Pre-indexed Addressing） 使用基地址加上偏移量来访问内存，访问完成后，将偏移量更新到基地址寄存器中。&#xA;LDR X1, [X0, #8]! ; 从地址X0 + 8加载数据到X1中，同时更新X0为X0 + 8 5. 后索引寻址（Post-indexed Addressing） 先使用基地址来访问内存，再将偏移量加到基地址寄存器中。这样偏移的效果在读取数据后才生效。&#xA;LDR X1, [X0], #8 ; 先从X0指向的地址加载数据到X1中，随后X0增加8 6. 寄存器偏移寻址（Register Offset Addressing） 偏移量用另一个寄存器指定，便于灵活的偏移操作，特别适合对数据结构的访问。&#xA;LDR X1, [X0, X2] ; 从X0 + X2指向的内存地址加载数据到X1中 7.</description>
    </item>
    <item>
      <title>ARM64 可执行程序是如何诞生的？编译流程 &#43; 指令调试全解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/arm64-%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%AF%9E%E7%94%9F%E7%9A%84%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B-&#43;-%E6%8C%87%E4%BB%A4%E8%B0%83%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 05 Jul 2025 19:33:58 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/arm64-%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%AF%9E%E7%94%9F%E7%9A%84%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B-&#43;-%E6%8C%87%E4%BB%A4%E8%B0%83%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;ARM64可执行程序的生成过程 根据 ARM64 可执行程序生成的四个主要步骤：预处理、编译、汇编、链接，我们可以详细分解整个过程如下&#xA;1. 预处理（Preprocessing） 预处理是源代码文件在正式编译前的准备工作，由预处理器完成。其主要任务包括：&#xA;宏替换：处理 #define 定义的宏，将代码中出现的宏替换为实际值。&#xA;文件包含：处理 #include 指令，将所需的头文件内容直接插入代码中，确保所有引用的函数和变量声明都在同一文件中。&#xA;条件编译：处理 #ifdef、#ifndef 等条件编译指令，以控制代码中不同部分的编译。&#xA;预处理后的输出仍然是代码文件，但没有任何宏、条件编译等指令，通常以 .i 或 .ii 作为扩展名。&#xA;2. 编译（Compilation） 编译器（如 GCC 或 Clang）将预处理后的代码文件转换为汇编代码，产生汇编语言表示的文件。此阶段包括以下子步骤：&#xA;词法分析：将源代码转化为基本的语法单元（token），如变量名、运算符、关键字等。&#xA;语法分析：将代码组织成抽象语法树（AST），根据编程语言的语法规则生成层次结构。&#xA;语义分析：检查语法树的正确性，如类型检查、作用域检查等，确保代码符合语言语义。&#xA;中间代码生成：编译器生成与平台无关的中间代码，方便后续优化。&#xA;优化：编译器对中间代码进行优化，如消除冗余代码、进行循环优化等，以提升程序效率。&#xA;生成汇编代码：编译器将优化后的中间代码转换为特定平台（如 ARM64）的汇编代码，通常输出 .s 文件。&#xA;编译阶段的最终输出是汇编代码文件，包含了基于 ARM64 指令集的指令。&#xA;3. 汇编（Assemble） 汇编器（如 GNU Assembler，as）将汇编代码文件（.s 文件）转换为机器代码，生成二进制的目标文件（.o 文件）。目标文件包含了二进制的机器指令，但符号引用还未解析，因此目标文件本身并非独立的可执行文件。&#xA;汇编阶段的主要工作包括：&#xA;指令翻译：将汇编语言指令转换为 ARM64 指令集对应的二进制机器指令。&#xA;符号表生成：记录所有函数和变量的符号地址，以便链接阶段使用。&#xA;机器码生成：生成目标文件（.o），将每条指令翻译成可执行的机器码。&#xA;目标文件是 ARM64 可执行程序生成过程中不可或缺的中间文件。&#xA;4. 链接（Linking） 链接器（如 GNU Linker，ld）将一个或多个目标文件链接在一起，并解决外部依赖，生成最终的可执行文件。链接的过程分为静态链接和动态链接两种：&#xA;静态链接：将程序所需的库代码直接嵌入到可执行文件中，生成一个完全自包含的文件。&#xA;动态链接：生成的可执行文件依赖外部共享库（如 .so 文件），在程序运行时加载这些共享库。&#xA;链接阶段的关键步骤包括：&#xA;符号解析：将不同目标文件中的符号（如函数和变量）解析为对应的内存地址，解决跨文件调用。&#xA;重定位：调整目标文件中指令和数据的地址，使得所有模块可以在一个统一的地址空间中正常运行。&#xA;生成可执行文件：链接器根据 ELF（Executable and Linkable Format）等格式生成最终的可执行文件，包含程序代码段、数据段、以及其他加载器所需的元信息。</description>
    </item>
    <item>
      <title>Capstone &#43; Keystone &#43; Unicorn：逆向分析三件套全解</title>
      <link>https://cyrus-studio.github.io/blog/posts/capstone-&#43;-keystone-&#43;-unicorn%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B8%89%E4%BB%B6%E5%A5%97%E5%85%A8%E8%A7%A3/</link>
      <pubDate>Sat, 05 Jul 2025 18:41:44 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/capstone-&#43;-keystone-&#43;-unicorn%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B8%89%E4%BB%B6%E5%A5%97%E5%85%A8%E8%A7%A3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Capstone 简介 Capstone 是一个强大的多平台开源反汇编框架，用于将机器码翻译为汇编代码。&#xA;官网：https://www.capstone-engine.org/&#xA;源码地址：https://github.com/capstone-engine/capstone&#xA;文档：https://www.capstone-engine.org/documentation.html&#xA;相关应用：&#xA;Radare2 内部使用 Capstone 作为其反汇编引擎之一。&#xA;Frida 的底层核心使用 Capstone 作为反汇编引擎，用于分析运行时的指令流、解码和显示二进制代码（例如，用户可以通过 Frida 的 API 获取内存中的指令数据，并使用 Capstone 对其进行解码和分析。）&#xA;使用 Capstone 反汇编 .so 文件中的机器码 要反汇编 .so 文件，首先需要提取其中的代码段内容（通常为 .text 段），然后利用 Capstone 进行反汇编。&#xA;1. 安装 capstone pip install capstone 2. 提取 .so 文件中的代码段 使用 readelf 工具获取 .text 段的偏移和大小（ -A 1：表示匹配行后再输出 1 行）：&#xA;readelf -S libvmp-lib.so | grep -A 1 .text&#xD;[14] .text PROGBITS 000000000009d480 0009d480&#xD;00000000000af0f8 0000000000000000 AX 0 0 16 关键信息：</description>
    </item>
    <item>
      <title>逆向还原变异 CRC32 算法：Unicorn &#43; 汇编分析 &#43; 模拟执行</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E8%BF%98%E5%8E%9F%E5%8F%98%E5%BC%82-crc32-%E7%AE%97%E6%B3%95unicorn-&#43;-%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90-&#43;-%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Sun, 29 Jun 2025 16:51:34 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E8%BF%98%E5%8E%9F%E5%8F%98%E5%BC%82-crc32-%E7%AE%97%E6%B3%95unicorn-&#43;-%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90-&#43;-%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;ARM64Emulator ARM64Emulator 是基于 Unicorn 实现一个轻量级的 ARM64 模拟器，具备代码加载、内存映射、指令执行、反汇编、寄存器监控、Hook、Patch、字符串处理等功能&#xA;项目地址：https://github.com/CYRUS-STUDIO/ARM64Emulator&#xA;这里主要使用 ARM64Emulator 模拟执行 so 中的汇编指令实现算法还原。&#xA;目标应用信息 app 中实现一个 CRC32 算法变形，具体实现在 so 中 modifiedCRC32 函数，现在要通过 unicorn 和 IDA Pro 逆向还原 so 中的算法。&#xA;项目地址：https://github.com/CYRUS-STUDIO/AndroidExample&#xA;目标 so 文件地址：https://github.com/CYRUS-STUDIO/ARM64Emulator/tree/main/examples&#xA;使用 ARM64Emulator 加载 so 并执行 modifiedCRC32 函数的汇编指令实现算法还原。&#xA;from unicorn.arm64_const import *&#xD;import struct&#xD;import re&#xD;from ARM64Emulator import ARM64Emulator&#xD;def modifiedCRC32(data):&#xD;emulator = ARM64Emulator(&amp;#34;libcrc32.so&amp;#34;)&#xD;mu = emulator.mu&#xD;# 字符串地址&#xD;str_addr = emulator.STACK_BASE + emulator.STACK_SIZE&#xD;emulator.mu.mem_map(str_addr, 0x1000) # 4KB&#xD;.</description>
    </item>
    <item>
      <title>基于 Unicorn 实现轻量级 ARM64 模拟器：支持 Hook、Patch、寄存器监控等功能</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8E-unicorn-%E5%AE%9E%E7%8E%B0%E8%BD%BB%E9%87%8F%E7%BA%A7-arm64-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%94%AF%E6%8C%81-hookpatch%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%91%E6%8E%A7%E7%AD%89%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sun, 29 Jun 2025 16:41:05 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8E-unicorn-%E5%AE%9E%E7%8E%B0%E8%BD%BB%E9%87%8F%E7%BA%A7-arm64-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%94%AF%E6%8C%81-hookpatch%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%91%E6%8E%A7%E7%AD%89%E5%8A%9F%E8%83%BD/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 基于 Unicorn 实现一个轻量级的 ARM64 模拟器，具备代码加载、内存映射、指令执行、反汇编、寄存器监控、Hook、Patch、字符串处理等功能，适合用于逆向分析或调试 ARM64 代码。&#xA;初始化与内存管理 代码加载：通过 _load_binary() 将 so 文件加载到内存中。&#xA;内存映射：在 _setup_memory() 中分配 10MB 的代码区和 1MB 的栈区。&#xA;寄存器初始化：在 _setup_registers() 中设置栈指针（SP）和程序计数器（PC）。&#xA;寄存器设置：提供了 set_x0()、set_x1() 和 set_x2() 等方法，用于直接设置寄存器值。&#xA;import capstone&#xD;from unicorn import *&#xD;from unicorn.arm64_const import *&#xD;class ARM64Emulator:&#xD;def __init__(self, so_file: str):&#xD;self.so_file = so_file&#xD;# 分配代码区（TEXT 段）&#xD;self.CODE_BASE = 0x000000 # 假设代码段起始地址&#xD;self.CODE_SIZE = 1024 * 1024 * 10 # 10MB&#xD;# 分配栈区（STACK 段）&#xD;self.</description>
    </item>
    <item>
      <title>如何魔改 CRC32 算法？从标准实现到加密扰动的变形逻辑解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E9%AD%94%E6%94%B9-crc32-%E7%AE%97%E6%B3%95%E4%BB%8E%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0%E5%88%B0%E5%8A%A0%E5%AF%86%E6%89%B0%E5%8A%A8%E7%9A%84%E5%8F%98%E5%BD%A2%E9%80%BB%E8%BE%91%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 29 Jun 2025 16:33:46 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E9%AD%94%E6%94%B9-crc32-%E7%AE%97%E6%B3%95%E4%BB%8E%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0%E5%88%B0%E5%8A%A0%E5%AF%86%E6%89%B0%E5%8A%A8%E7%9A%84%E5%8F%98%E5%BD%A2%E9%80%BB%E8%BE%91%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 CRC32 是一种常用的校验算法，用于快速检测数据在传输或存储过程中是否发生了变化，具有计算速度快、实现简单等特点。&#xA;关于 CRC32 算法介绍可以参考这篇文章：一文搞懂常用加解密算法：编码、哈希、对称&amp;amp;非对称加密与压缩全解析&#xA;标准 CRC32 算法 创建 crc32.cpp，使用 C++ 实现标准 CRC32 算法&#xA;#include &amp;lt;jni.h&amp;gt;&#xD;#include &amp;lt;string&amp;gt;&#xD;#include &amp;lt;android/log.h&amp;gt;&#xD;#define TAG &amp;#34;CRC32&amp;#34;&#xD;unsigned int crc32_table[256];&#xD;// 初始化 CRC32 查找表&#xD;void init_crc32_table() {&#xD;unsigned int crc;&#xD;for (int i = 0; i &amp;lt; 256; i++) {&#xD;crc = i;&#xD;for (int j = 8; j &amp;gt; 0; j--) {&#xD;if (crc &amp;amp; 1) {&#xD;crc = (crc &amp;gt;&amp;gt; 1) ^ 0xedb88320;&#xD;} else {&#xD;crc &amp;gt;&amp;gt;= 1;&#xD;}&#xD;}&#xD;crc32_table[i] = crc;&#xD;}&#xD;}&#xD;// 计算 CRC32&#xD;unsigned int crc32(const std::string&amp;amp; str) {&#xD;unsigned int crc = 0xffffffff;&#xD;for (size_t i = 0; i &amp;lt; str.</description>
    </item>
    <item>
      <title>逆向还原魔改 Base64 算法：动态码表 &#43; 汇编代码 &#43; C 语言重构</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E8%BF%98%E5%8E%9F%E9%AD%94%E6%94%B9-base64-%E7%AE%97%E6%B3%95%E5%8A%A8%E6%80%81%E7%A0%81%E8%A1%A8-&#43;-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81-&#43;-c-%E8%AF%AD%E8%A8%80%E9%87%8D%E6%9E%84/</link>
      <pubDate>Sun, 29 Jun 2025 16:10:40 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E8%BF%98%E5%8E%9F%E9%AD%94%E6%94%B9-base64-%E7%AE%97%E6%B3%95%E5%8A%A8%E6%80%81%E7%A0%81%E8%A1%A8-&#43;-%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81-&#43;-c-%E8%AF%AD%E8%A8%80%E9%87%8D%E6%9E%84/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 可以看到 app 中共有 4 种 Base64 算法。选中一个随机字符串，可以选择其中一种算法进行编码解码。&#xA;app地址：https://github.com/CYRUS-STUDIO/AndroidExample&#xA;标准 Java Base64 算法还原 使用 jadx 反编译 apk，搜索找到按钮的代码&#xA;因为 app 中 ui 是用 Compose 实现的，所有 ui 都是 Function，所以这里看到 Text 是一个 Function&#xA;在 Function f57lambda2 上按 X 找到调用该 Function 的地方&#xA;再继续找 m6044getLambda2$app_release 的上层调用是 rememberedValue6&#xA;可以看到 rememberedValue6 中实际是调用了Base64ActivityKt.Base64App&amp;hellip;$lambda$16 方法&#xA;rememberedValue6 = new Function0() { // from class: com.cyrus.example.base64.Base64ActivityKt$$ExternalSyntheticLambda6&#xD;@Override // kotlin.jvm.functions.Function0&#xD;public final Object invoke() {&#xD;Unit Base64App$lambda$37$lambda$36$lambda$20$lambda$17$lambda$16;&#xD;Base64App$lambda$37$lambda$36$lambda$20$lambda$17$lambda$16 = Base64ActivityKt.Base64App$lambda$37$lambda$36$lambda$20$lambda$17$lambda$16(Base64App$lambda$4, mutableState2);&#xD;return Base64App$lambda$37$lambda$36$lambda$20$lambda$17$lambda$16;&#xD;}&#xD;}; $lambda$16 方法实现如下：</description>
    </item>
    <item>
      <title>标准 Base64 太好逆？试试自定义码表 &#43; 动态规则的魔改版本</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%A0%87%E5%87%86-base64-%E5%A4%AA%E5%A5%BD%E9%80%86%E8%AF%95%E8%AF%95%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A0%81%E8%A1%A8-&#43;-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E7%9A%84%E9%AD%94%E6%94%B9%E7%89%88%E6%9C%AC/</link>
      <pubDate>Sun, 29 Jun 2025 15:50:01 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%A0%87%E5%87%86-base64-%E5%A4%AA%E5%A5%BD%E9%80%86%E8%AF%95%E8%AF%95%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A0%81%E8%A1%A8-&#43;-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E7%9A%84%E9%AD%94%E6%94%B9%E7%89%88%E6%9C%AC/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Java 实现标准 Base64 编码和解码 Base64 编码：&#xA;val encoded = Base64.encodeToString(str.toByteArray(), Base64.DEFAULT) Base64 解码：&#xA;val decoded = Base64.decode(str, Base64.DEFAULT)&#xD;val decodedString = String(decoded) C++ 实现标准 Base64 编码和解码 创建 base64.cpp 实现 Base64 编码和解码&#xA;#include &amp;lt;jni.h&amp;gt;&#xD;#include &amp;lt;string&amp;gt;&#xD;#include &amp;lt;android/log.h&amp;gt;&#xD;static const std::string base64_chars =&#xD;&amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34;&#xD;&amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34;&#xD;&amp;#34;0123456789+/&amp;#34;;&#xD;// 检查字符是否是 Base64 字符&#xD;static inline bool is_base64(unsigned char c) {&#xD;return (isalnum(c) || (c == &amp;#39;+&amp;#39;) || (c == &amp;#39;/&amp;#39;));&#xD;}&#xD;// Base64 编码函数&#xD;std::string base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len) {&#xD;std::string ret;&#xD;int i = 0;&#xD;int j = 0;&#xD;unsigned char char_array_3[3];&#xD;unsigned char char_array_4[4];&#xD;while (in_len--) {&#xD;char_array_3[i++] = *(bytes_to_encode++);&#xD;if (i == 3) {&#xD;char_array_4[0] = (char_array_3[0] &amp;amp; 0xfc) &amp;gt;&amp;gt; 2;&#xD;char_array_4[1] = ((char_array_3[0] &amp;amp; 0x03) &amp;lt;&amp;lt; 4) + ((char_array_3[1] &amp;amp; 0xf0) &amp;gt;&amp;gt; 4);&#xD;char_array_4[2] = ((char_array_3[1] &amp;amp; 0x0f) &amp;lt;&amp;lt; 2) + ((char_array_3[2] &amp;amp; 0xc0) &amp;gt;&amp;gt; 6);&#xD;char_array_4[3] = char_array_3[2] &amp;amp; 0x3f;&#xD;for (i = 0; i &amp;lt; 4; i++) {&#xD;ret += base64_chars[char_array_4[i]];&#xD;}&#xD;i = 0;&#xD;}&#xD;}&#xD;if (i) {&#xD;for (int j = i; j &amp;lt; 3; j++) {&#xD;char_array_3[j] = &amp;#39;\0&amp;#39;;&#xD;}&#xD;char_array_4[0] = (char_array_3[0] &amp;amp; 0xfc) &amp;gt;&amp;gt; 2;&#xD;char_array_4[1] = ((char_array_3[0] &amp;amp; 0x03) &amp;lt;&amp;lt; 4) + ((char_array_3[1] &amp;amp; 0xf0) &amp;gt;&amp;gt; 4);&#xD;char_array_4[2] = ((char_array_3[1] &amp;amp; 0x0f) &amp;lt;&amp;lt; 2) + ((char_array_3[2] &amp;amp; 0xc0) &amp;gt;&amp;gt; 6);&#xD;char_array_4[3] = char_array_3[2] &amp;amp; 0x3f;&#xD;for (int j = 0; j &amp;lt; i + 1; j++) {&#xD;ret += base64_chars[char_array_4[j]];&#xD;}&#xD;while ((i++ &amp;lt; 3)) {&#xD;ret += &amp;#39;=&amp;#39;;&#xD;}&#xD;}&#xD;return ret;&#xD;}&#xD;// Base64 解码函数&#xD;std::string base64_decode(std::string const&amp;amp; encoded_string) {&#xD;int in_len = encoded_string.</description>
    </item>
    <item>
      <title>一文搞懂常用加解密算法：编码、哈希、对称&amp;非对称加密与压缩全解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E5%B8%B8%E7%94%A8%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95%E7%BC%96%E7%A0%81%E5%93%88%E5%B8%8C%E5%AF%B9%E7%A7%B0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%8E%8B%E7%BC%A9%E5%85%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 29 Jun 2025 15:41:35 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E5%B8%B8%E7%94%A8%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95%E7%BC%96%E7%A0%81%E5%93%88%E5%B8%8C%E5%AF%B9%E7%A7%B0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%8E%8B%E7%BC%A9%E5%85%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;常见加解密工具 CyberChef CyberChef 是一个功能强大的数据处理工具，由 GCHQ（英国政府通信总部）开发。它提供了一系列 加密、解密、编码、解码、数据转换、压缩、哈希、取证分析 等功能，适用于安全研究、数据处理和取证分析等场景。&#xA;CyberChef Web 地址：https://gchq.github.io/CyberChef/&#xA;项目地址：https://github.com/gchq/CyberChef&#xA;openssl OpenSSL 是一个开源加密库，支持 SSL/TLS 协议，实现 RSA、AES、SM2、SM4 等算法，提供加密、证书管理、哈希计算等功能，广泛用于网络安全、身份认证和数据保护。&#xA;项目地址：https://github.com/openssl/openssl&#xA;各种常见的加密算法在 openssl 中都有实现&#xA;cryptopp Crypto++ 是一个开源 C++ 加密库。&#xA;cryptopp 编译相对于 openssl 比较简便，不需要安装特殊依赖环境。&#xA;项目地址：https://github.com/weidai11/cryptopp&#xA;chilkat Chilkat 是一个跨平台加密和网络通信库，收费，不开源，但是已经编译好各种平台的库，直接拿来就用。&#xA;下载地址：https://www.chilkatsoft.com/downloads.asp&#xA;编码算法 编码算法是一种用于数据转换的方法，它将信息从一种格式转换为另一种格式，便于存储和传输。&#xA;Hex Hex 编码是一种将二进制数据转换为十六进制字符串的编码方式&#xA;data = b&amp;#34;Hello&amp;#34;&#xD;hex_encoded = data.hex()&#xD;print(&amp;#34;Hex 编码:&amp;#34;, hex_encoded)&#xD;hex_decoded = bytes.fromhex(hex_encoded)&#xD;print(&amp;#34;Hex 解码:&amp;#34;, hex_decoded.decode()) 输出如下：&#xA;Hex 编码: 48656c6c6f&#xD;Hex 解码: Hello URL Encode / URL Decode URL 编码 是一种用于在 URL 中安全传输特殊字符的编码方式，将非 ASCII 字符、特殊字符转换为百分号（%）+ 两位十六进制数的格式。</description>
    </item>
    <item>
      <title>HMAC 加密算法是如何运作的？如何在 Android 上实现变体？</title>
      <link>https://cyrus-studio.github.io/blog/posts/hmac-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84%E5%A6%82%E4%BD%95%E5%9C%A8-android-%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%8F%98%E4%BD%93/</link>
      <pubDate>Sun, 29 Jun 2025 15:31:38 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/hmac-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84%E5%A6%82%E4%BD%95%E5%9C%A8-android-%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%8F%98%E4%BD%93/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;HMAC HMAC（Hash-based Message Authentication Code）是一种基于哈希函数的消息认证码，用于验证数据的完整性和真实性。&#xA;HMAC 主要依赖于以下几个要素：&#xA;消息（Message）：需要验证的数据。&#xA;密钥（Key）：共享的秘密密钥，用于保护消息。&#xA;哈希函数（Hash Function）：如 MD5、SHA-256 等。&#xA;HMAC 的计算公式如下：&#xA;其中：&#xA;H 是哈希函数。&#xA;K 是密钥。&#xA;M 是消息。&#xA;opad 是外部填充（0x5c）。&#xA;ipad 是内部填充（0x36）。&#xA;∥ 表示拼接。&#xA;⊕ 表示按位异或。&#xA;所以 HMAC 返回字符串长度取决于具体的哈希函数。&#xA;比如，哈希函数是 MD5 则返回的字符串就是 16 字节（128位），通常由长度为 32 的 十六进制字符串 表示 。&#xA;比如，哈希函数是 SHA256 则返回的字符串就是 32 字节（256位），通常由长度为 64 的 十六进制字符串 表示 。&#xA;HMAC MD5 标准 HMAC MD5 算法实现如下：&#xA;1、Key 处理：&#xA;如果密钥过长，用 MD5 进行压缩至 16 字节。&#xA;如果密钥不足 64 字节，用 0x00 填充至 64 字节。</description>
    </item>
    <item>
      <title>如何变形 SHA-1 算法？从标准实现到 Android 定制加密实践</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E5%8F%98%E5%BD%A2-sha-1-%E7%AE%97%E6%B3%95%E4%BB%8E%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0%E5%88%B0-android-%E5%AE%9A%E5%88%B6%E5%8A%A0%E5%AF%86%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 29 Jun 2025 15:22:49 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E5%8F%98%E5%BD%A2-sha-1-%E7%AE%97%E6%B3%95%E4%BB%8E%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0%E5%88%B0-android-%E5%AE%9A%E5%88%B6%E5%8A%A0%E5%AF%86%E5%AE%9E%E8%B7%B5/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;标准 SHA1 SHA1（Secure Hash Algorithm 1）是一种广泛使用的 加密哈希函数，用于生成固定长度的 160 位（20 字节）哈希值。它由 美国国家安全局（NSA） 设计，并由 NIST（美国国家标准与技术研究院） 在 1995 年作为 FIPS PUB 180-1 标准发布。&#xA;SHA1 的基本特点&#xA;输出长度：160 位（20 字节）的哈希值，通常以长度为 40 的 hex 字符串表示&#xA;使用 5 个固定的初始哈希值（MD5 是 4 个）&#xA;不可逆性：无法从哈希值反推出原文&#xA;固定性：相同的输入始终会产生相同的输出&#xA;雪崩效应：输入的微小变化会导致输出哈希值的巨大变化&#xA;抗碰撞性（已破坏）：理论上很难找到两个不同的输入产生相同的哈希值&#xA;SHA1 C++ 标准实现如下：&#xA;sha1.h&#xA;#ifndef SHA1_H&#xD;#define SHA1_H&#xD;#include &amp;lt;stdlib.h&amp;gt;&#xD;#include &amp;lt;string.h&amp;gt;&#xD;#include &amp;lt;asm/types.h&amp;gt;&#xD;#define os_memcpy memcpy&#xD;#define os_memset memset&#xD;#define os_memcmp memcmp&#xD;#define os_strlen strlen&#xD;#define MAX_SHA1_LEN 32&#xD;#define SHA1_MAC_LEN 20&#xD;typedef __u8 u8;&#xD;typedef __u32 u32;&#xD;struct SHA1Context {&#xD;u32 state[5];&#xD;u32 count[2];&#xD;unsigned char buffer[64];&#xD;};&#xD;typedef struct SHA1Context SHA1_CTX;&#xD;void SHA1Init(SHA1_CTX *context);&#xD;void SHA1Update(SHA1_CTX *context, const unsigned char *data, u32 len);&#xD;void SHA1Final(unsigned char digest[20], SHA1_CTX *context);&#xD;#endif /* SHA1_H */ sha1.</description>
    </item>
    <item>
      <title>如何变形一个 MD5 算法？Android 实现 &#43; OLLVM 防护实战解析</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E5%8F%98%E5%BD%A2%E4%B8%80%E4%B8%AA-md5-%E7%AE%97%E6%B3%95android-%E5%AE%9E%E7%8E%B0-&#43;-ollvm-%E9%98%B2%E6%8A%A4%E5%AE%9E%E6%88%98%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 29 Jun 2025 04:29:58 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%A6%82%E4%BD%95%E5%8F%98%E5%BD%A2%E4%B8%80%E4%B8%AA-md5-%E7%AE%97%E6%B3%95android-%E5%AE%9E%E7%8E%B0-&#43;-ollvm-%E9%98%B2%E6%8A%A4%E5%AE%9E%E6%88%98%E8%A7%A3%E6%9E%90/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;MD5是一种哈希函数，用于将任意长度的数据映射为一个固定长度的哈希值。它由 Ron Rivest 在 1991 年设计，是继 MD4 之后的改进版本。&#xA;MD5 的基本特征：&#xA;固定长度输出：将任意长度的数据转换为 128 位（16 字节） 的哈希值，通常以 32 位十六进制 字符串表示。&#xA;不可逆性：无法从哈希值反推原始数据。&#xA;雪崩效应：输入的微小变化会导致哈希值完全不同。&#xA;抗碰撞性较弱：不同输入产生相同哈希值的概率较低，但已存在有效的碰撞攻击。&#xA;计算速度快：采用简单的位运算，处理速度快，适合大数据量。&#xA;标准 MD5 标准 MD5 的 C++ 实现如下：&#xA;md5.h&#xA;#ifndef __MD5_INCLUDE__&#xD;/* typedef a 32-bit type */&#xD;#ifdef _LP64&#xD;typedef unsigned int UINT4;&#xD;typedef int INT4;&#xD;#else&#xD;typedef unsigned long UINT4;&#xD;typedef long INT4;&#xD;#endif&#xD;#define _UINT4_T&#xD;/* Data structure for MD5 (Message-Digest) computation */&#xD;typedef struct {&#xD;UINT4 i[2]; /* number of _bits_ handled mod 2^64 */&#xD;UINT4 buf[4]; /* scratch buffer */&#xD;unsigned char in[64]; /* input buffer */&#xD;unsigned char digest[16]; /* actual digest after MD5Final call */&#xD;} MD5_CTX;&#xD;void MD5_Init (MD5_CTX *mdContext);&#xD;void MD5_Update (MD5_CTX *mdContext, unsigned char *inBuf, unsigned int inLen);&#xD;void MD5_Final (unsigned char hash[], MD5_CTX *mdContext);&#xD;#define __MD5_INCLUDE__&#xD;#endif /* __MD5_INCLUDE__ */ md5.</description>
    </item>
    <item>
      <title>全面解析 Android App 启动流程与事件循环机制底层原理</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90-android-app-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 28 Jun 2025 11:11:38 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90-android-app-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;APP 启动流程 app 启动流程大概如下：&#xA;发起进程（startActivity/startService...）&#xD;↓&#xD;↓（Binder方式）&#xD;↓&#xD;system_server进程（Process.start）&#xD;↓&#xD;↓（Socket方式）&#xD;↓&#xD;Zygote进程（ZygoteInit.runSelectLoop()） ↓&#xD;新建进程（ActivityThread.main） ActivityThread.main() 是 Android 应用进程的入口函数。&#xA;1. 应用 → AMS（Binder） 由 ActivityManager.getService() 返回的 Binder 接口对象调用系统服务：&#xA;// 应用进程&#xD;ContextImpl.startActivity()&#xD;└── Instrumentation.execStartActivity()&#xD;└── ActivityManager.getService().startActivity() ← AIDL Binder 跨进程&#xD;└── ActivityManagerService.startActivity() 通过 AIDL 实现 Binder 跨进程通信，连接系统服务。&#xA;关于 Android 中 AIDL 实现 Binder 跨进程通信 可以参考：Android中的Service与进程间通信（IPC）详解&#xA;AMS 接口实现：&#xA;https://cs.android.com/android/platform/superproject/+/android-10.0.0_r47:frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java;l=3496&#xA;2. AMS/system_server → zygote（Socket） startActivity 最终调用到 Process.start 方法&#xA;475 /**&#xD;476 * State associated with the zygote process.</description>
    </item>
    <item>
      <title>安卓抓包实战：使用 Charles 抓取 App 数据全流程详解</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%BD%BF%E7%94%A8-charles-%E6%8A%93%E5%8F%96-app-%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 27 Jun 2025 15:39:56 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E4%BD%BF%E7%94%A8-charles-%E6%8A%93%E5%8F%96-app-%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;抓包环境准备 1. 下载安装charles charles下载地址：https://www.charlesproxy.com/latest-release/download.do&#xA;2. SSL代理设置 SSL Proxying Settings&amp;hellip;&#xA;说明：如果需要抓 PC 上的数据就开启 Windows Proxy，如果只是抓手机上的数据可以不用开启。&#xA;配置说明：&#xA;*:443 — 表示拦截所有域名的 HTTPS 请求&#xA;*:80 — 表示拦截所有域名的 HTTP 请求&#xA;3. Enable transparent HTTP proxying 打开 Proxy Settings 勾选 Enable transparent HTTP proxying&#xA;transparent HTTP proxying：客户端无需设置代理，Charles 通过网络层拦截（如防火墙、端口转发、网关路由等）来强制把 HTTP 流量转发到 Charles&#xA;4. 设置Charles与Clash共存 如果开启了Clash，需要设置Charles与Clash共存&#xA;打开扩展代理设置&#xA;分别点击 Web Proxy、Seure Web Proxy 和 SOCKS Proxy 设置一下Clash的地址和端口&#xA;5. 共享热点 通过 ipconfig 命令找到电脑的 ip 地址&#xA;或者打开【网络和Internet】找到电脑的 ip 地址</description>
    </item>
    <item>
      <title>全面解析 OkHttp 原理与实战：从拦截器机制到 Frida Hook 打印请求响应</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90-okhttp-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98%E4%BB%8E%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%BA%E5%88%B6%E5%88%B0-frida-hook-%E6%89%93%E5%8D%B0%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/</link>
      <pubDate>Fri, 27 Jun 2025 14:51:22 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90-okhttp-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98%E4%BB%8E%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%BA%E5%88%B6%E5%88%B0-frida-hook-%E6%89%93%E5%8D%B0%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;OkHttp OkHttp 是一个高效的 HTTP 客户端库，由 Square 公司开发，广泛应用于 Android 开发中。它支持同步和异步请求、连接池、压缩、缓存、拦截器等高级特性，是 Android 网络请求的主流选择之一。&#xA;开源地址：https://github.com/square/okhttp&#xA;OkHttp 的核心特点：&#xA;支持 HTTP/1.1 和 HTTP/2&#xA;自动连接重用与请求队列复用&#xA;支持透明的 GZIP 压缩&#xA;支持缓存响应数据以减少重复请求&#xA;支持自定义拦截器（用于日志、请求修改、认证等）&#xA;异步请求基于线程池，不阻塞主线程&#xA;在 Android Studio 中使用 OkHttp 在 build.gradle(:app) 中加入 OkHttp 的依赖项：&#xA;dependencies {&#xD;implementation(&amp;#34;com.squareup.okhttp3:okhttp:4.12.0&amp;#34;)&#xD;} 可选：日志拦截器（用于打印请求和响应）&#xA;implementation(&amp;#34;com.squareup.okhttp3:logging-interceptor:4.12.0&amp;#34;) Kotlin 封装的 OkHttpClient 单例 功能说明：&#xA;单例模式（线程安全）&#xA;可选注册日志拦截器&#xA;封装常用请求方法：GET、POST(JSON / 表单)、PUT、DELETE&#xA;支持 全局请求头（如 Authorization Token）&#xA;支持 协程版 suspend 函数（适合 ViewModelScope 等使用）&#xA;支持 文件上传 Multipart 请求&#xA;保留原有 Callback 异步接口（兼容老代码）</description>
    </item>
    <item>
      <title>打造基于 ART 的 Android 函数抽取壳：原理剖析与完整源码实战</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%89%93%E9%80%A0%E5%9F%BA%E4%BA%8E-art-%E7%9A%84-android-%E5%87%BD%E6%95%B0%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81%E5%AE%9E%E6%88%98/</link>
      <pubDate>Wed, 25 Jun 2025 17:08:04 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%89%93%E9%80%A0%E5%9F%BA%E4%BA%8E-art-%E7%9A%84-android-%E5%87%BD%E6%95%B0%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81%E5%AE%9E%E6%88%98/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;ART 下类加载流程 1. 类加载的时机 1、隐式加载：&#xA;创建类的实例&#xA;访问类的静态变量，或者为静态变量赋值&#xA;调用类的静态方法&#xA;使用反射方式来强制创建某个类或接口对应的 java.lang.Class 对象&#xA;初始化某个类的子类&#xA;2、显示加载：&#xA;使用 loadClass() 加载&#xA;使用 forName() 加载&#xA;两者又有所不同。&#xA;2. 类加载的流程 loadClass 和 forName 也是有区别的；&#xA;loadClass 只完成了第一步，就是加载；&#xA;Class.forName 是完成了3步，加载、链接和初始化。&#xA;阶段 发生了什么 加载 字节码文件 -&amp;gt; Class 对象 验证 检查字节码合法性 准备 静态变量分配内存，默认值 解析 符号引用 → 真实引用 初始化 调用 &amp;lt;clinit&amp;gt; 函数，static 代码块执行，静态变量赋值 一个类从“加载” 到 “可以使用” 的完整生命周期：加载（Loading）→ 连接（Linking）→ 初始化（Initialization）。&#xA;加载（Loading）&#xD;↓&#xD;连接（Linking）&#xD;→ 验证（Verification）&#xD;→ 准备（Preparation）&#xD;→ 解析（Resolution）&#xD;↓&#xD;初始化（Initialization）&#xD;↓&#xD;使用（Use）&#xD;↓&#xD;卸载（Unload） 相关文章：Android 下的 ClassLoader 与 双亲委派机制</description>
    </item>
    <item>
      <title>手把手教你用 Chrome 断点调试 Frida 脚本，JS 调试不再是黑盒</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-chrome-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95-frida-%E8%84%9A%E6%9C%ACjs-%E8%B0%83%E8%AF%95%E4%B8%8D%E5%86%8D%E6%98%AF%E9%BB%91%E7%9B%92/</link>
      <pubDate>Tue, 24 Jun 2025 21:07:57 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8-chrome-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95-frida-%E8%84%9A%E6%9C%ACjs-%E8%B0%83%E8%AF%95%E4%B8%8D%E5%86%8D%E6%98%AF%E9%BB%91%E7%9B%92/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;使用 Chrome 断点调试 JS 只需要在执行 frida 命令时，加上下面参数即可：&#xA;--runtime=v8 --debug 参数说明：&#xA;&amp;ndash;runtime=v8，指定 Frida 使用 V8 引擎（Google Chrome 使用的 JS 引擎）来运行 JS 脚本。默认 Frida 使用 QuickJS 引擎（轻量但功能有限，调试能力较差）。&#xA;&amp;ndash;debug，启用调试模式，输出更多细节信息，包括：脚本加载日志、错误栈追踪、JS 异常信息等&#xA;关于 Frida 的详细使用参考：一文搞懂如何使用 Frida Hook Android App&#xA;比如：&#xA;启动应用并附加到当前启动进程 frida -H 127.0.0.1:1234 -l classloader_utils.js -f com.shizhuang.duapp --runtime=v8 --debug 附加到当前设备的前台应用 frida -H 127.0.0.1:1234 -F -l classloader_utils.js --runtime=v8 --debug 当你看到：Chrome Inspector server listening on port 9229，这说明你已经成功开启了一个 Frida（V8 模式）调试服务&#xA;(anti-app) PS D:\Python\anti-app\frida_java&amp;gt; frida -H 127.</description>
    </item>
    <item>
      <title>逆向某物 App 登录接口：热修复逻辑挖掘隐藏参数、接口完整调用</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%83%AD%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91%E6%8C%96%E6%8E%98%E9%9A%90%E8%97%8F%E5%8F%82%E6%95%B0%E6%8E%A5%E5%8F%A3%E5%AE%8C%E6%95%B4%E8%B0%83%E7%94%A8/</link>
      <pubDate>Sun, 22 Jun 2025 22:38:57 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%83%AD%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91%E6%8C%96%E6%8E%98%E9%9A%90%E8%97%8F%E5%8F%82%E6%95%B0%E6%8E%A5%E5%8F%A3%E5%AE%8C%E6%95%B4%E8%B0%83%E7%94%A8/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;uuid 参数分析 通过反编译 ff.l0.c 方法可以知道 uuid 来自于 he.a.i.t() 方法&#xA;map.put(&amp;#34;uuid&amp;#34;, he.a.i.t()); 具体参考：&#xA;逆向某物 App 登录接口：抓包分析 + Frida Hook 还原加密算法&#xA;逆向某物 App 登录接口：还原 newSign 算法全流程&#xA;查找一下 he.a.i 在哪些 dex 有引用&#xA;2|wayne:/data/data/com.shizhuang.duapp/cyrus # grep -rl &amp;#34;he.a.i&amp;#34; *.txt&#xD;11994176_class_list.txt&#xD;11994176_class_list_execute.txt&#xD;1321896_class_list_execute.txt&#xD;1571616_class_list.txt&#xD;1571616_class_list_execute.txt&#xD;8183732_class_list.txt&#xD;8183732_class_list_execute.txt&#xD;8391604_class_list_execute.txt&#xD;9085048_class_list.txt&#xD;9085048_class_list_execute.txt 通过 jadx 反编译 he.a 源码如下：&#xA;package he;&#xD;/* loaded from: 11994176_dex_file_execute.jar:he/a.class */&#xD;public class a {&#xD;public static i i = new C0253a();&#xD;/* renamed from: he.</description>
    </item>
    <item>
      <title>逆向某物 App 登录接口：还原 newSign 算法全流程</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E8%BF%98%E5%8E%9F-newsign-%E7%AE%97%E6%B3%95%E5%85%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 22 Jun 2025 21:24:23 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E8%BF%98%E5%8E%9F-newsign-%E7%AE%97%E6%B3%95%E5%85%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;newSign 参数分析 通过 Hook Java 层加密算法得到 newSign 参数相关信息如下：&#xA;具体参考：逆向某物 App 登录接口：抓包分析 + Frida Hook 还原加密算法&#xA;入参：&#xA;MD5 update data Utf8: dWWoXlbR3K87j2N27Dkv4uOPUnOsh0xrJ5t+atsiQXC+/dIN8Kof9Gm2x1kil7S/A+KLRtWKw+AfFWotfKtx+5J+ONciO*********************************************************************************************kK+Xiqtb6FajKK3aJ2vwB5l5lAKIhnvpOWXFWqYSQJy5g7oQ61Vwo+6MVB3U/wBT2CpM7AKDFH2Xj9Krb/0jNsPgNnA== MD5 加密后的结果：&#xA;MD5 digest result Hex: 8f03e2117c**********d9b9b18c58 调用堆栈：&#xA;MessageDigest.digest() is called!&#xD;java.lang.Throwable&#xD;at java.security.MessageDigest.digest(Native Method)&#xD;at ff.l0.h(RequestUtils.java:3)&#xD;at ff.l0.c(RequestUtils.java:12)&#xD;at lte.NCall.IL(Native Method)&#xD;at com.shizhuang.duapp.common.helper.net.interceptor.HttpRequestInterceptor.intercept(HttpRequestInterceptor.java)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:10)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:1)&#xD;at kb.b.intercept(MergeHostAfterInterceptor.java:11)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:10)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:1)&#xD;at kb.d.intercept(MergeHostInterceptor.java:8)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:10)&#xD;at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:1)&#xD;at okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:13)&#xD;at okhttp3.RealCall.execute(RealCall.java:8)&#xD;at retrofit2.OkHttpCall.execute(OkHttpCall.java:18)&#xD;at retrofit2.</description>
    </item>
    <item>
      <title>逆向某物 App 登录接口：抓包分析 &#43; Frida Hook 还原加密算法</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90-&#43;-frida-hook-%E8%BF%98%E5%8E%9F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 21 Jun 2025 16:33:56 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E9%80%86%E5%90%91%E6%9F%90%E7%89%A9-app-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90-&#43;-frida-hook-%E8%BF%98%E5%8E%9F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;登录接口抓包分析 使用 Charles 分析登录接口，打开 APP，输入用户名和密码，点击登录后，可以看到会调用一个 unionLogin 接口&#xA;Charles 的详细使用教程参考：安卓抓包实战：使用 Charles 抓取 App 数据全流程详解&#xA;response：&#xA;{&#xD;&amp;#34;code&amp;#34;: 704,&#xD;&amp;#34;data&amp;#34;: &amp;#34;3YlD20Mglo7XabT4cSg0p_sFlOH7UrRp2-SV2xAVsXYfLssqWSX1NpUQ9HhlWEnRgXF0phtI-2BfqI9Cl1cGmih8veCmWZU-ItqKSv_gs3stFlw_*****************************************fRv25yucw==&amp;#34;,&#xD;&amp;#34;status&amp;#34;: 704&#xD;} curl 转 request（https://spidertools.cn/#/curl2Request）&#xA;通过 Python 请求接口&#xA;import requests&#xD;import json&#xD;headers = {&#xD;&amp;#34;ipvx&amp;#34;: &amp;#34;**************&amp;#34;,&#xD;&amp;#34;webua&amp;#34;: &amp;#34;Mozilla/5.0 (Linux; Android 7.1.2; MI8 Build/N2G47J; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/66.0.3359.158 Mobile Safari/537.36/duapp/5.43.0(android;7.1.2)&amp;#34;,&#xD;&amp;#34;app_build&amp;#34;: &amp;#34;5.43.0.10&amp;#34;,&#xD;&amp;#34;cookieToken&amp;#34;: &amp;#34;&amp;#34;,&#xD;&amp;#34;ltk&amp;#34;: &amp;#34;*****************************************&amp;#34;,&#xD;&amp;#34;duplatform&amp;#34;: &amp;#34;android&amp;#34;,&#xD;&amp;#34;appId&amp;#34;: &amp;#34;duapp&amp;#34;,&#xD;&amp;#34;duchannel&amp;#34;: &amp;#34;xiaomi&amp;#34;,&#xD;&amp;#34;humeChannel&amp;#34;: &amp;#34;&amp;#34;,&#xD;&amp;#34;duv&amp;#34;: &amp;#34;5.</description>
    </item>
    <item>
      <title>破解 VMP&#43;OLLVM 混淆：通过 Hook jstring 快速定位加密算法入口</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E7%A0%B4%E8%A7%A3-vmp&#43;ollvm-%E6%B7%B7%E6%B7%86%E9%80%9A%E8%BF%87-hook-jstring-%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%85%A5%E5%8F%A3/</link>
      <pubDate>Fri, 20 Jun 2025 16:43:26 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E7%A0%B4%E8%A7%A3-vmp&#43;ollvm-%E6%B7%B7%E6%B7%86%E9%80%9A%E8%BF%87-hook-jstring-%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%85%A5%E5%8F%A3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;VMP 壳 + OLLVM 的加密算法 某电商APP的加密算法经过dex脱壳分析，找到参数加密的方法在 DuHelper.doWork 中&#xA;package com.shizhuang.duapp.common.helper.ee;&#xD;import com.meituan.robust.ChangeQuickRedirect;&#xD;import lte.NCall;&#xD;/* loaded from: base.apk_classes9.jar:com/shizhuang/duapp/common/helper/ee/DuHelper.class */&#xD;public class DuHelper {&#xD;public static ChangeQuickRedirect changeQuickRedirect;&#xD;static {&#xD;NCall.IV(new Object[]{282});&#xD;}&#xD;public static native int checkSignature(Object obj);&#xD;public static String doWork(Object obj, String str) {&#xD;return (String) NCall.IL(new Object[]{283, obj, str});&#xD;}&#xD;public static native String encodeByte(byte[] bArr, String str);&#xD;public static native String getByteValues();&#xD;public static native String getLeanCloudAppID();&#xD;public static native String getLeanCloudAppKey();&#xD;public static native String getWxAppId(Object obj);&#xD;public static native String getWxAppKey();&#xD;} DuHelper.</description>
    </item>
    <item>
      <title>Frida Stalker Trace 指令跟踪&amp;寄存器变化监控</title>
      <link>https://cyrus-studio.github.io/blog/posts/frida-stalker-trace-%E6%8C%87%E4%BB%A4%E8%B7%9F%E8%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E5%8C%96%E7%9B%91%E6%8E%A7/</link>
      <pubDate>Mon, 07 Apr 2025 19:37:54 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/frida-stalker-trace-%E6%8C%87%E4%BB%A4%E8%B7%9F%E8%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E5%8C%96%E7%9B%91%E6%8E%A7/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Frida Stalker Frida 的 Stalker 是一个强大的代码追踪工具。&#xA;主要功能&#xA;指令级跟踪：Stalker 可精确到指令级别，对应用的原生代码进行实时监控。&#xA;代码插桩：支持在指定指令前后插入自定义的代码逻辑。&#xA;内存访问监控：可以监视内存读写操作，分析数据流向。&#xA;自定义回调：提供回调函数，方便记录和分析执行轨迹。&#xA;文档：https://frida.re/docs/javascript-api/#stalker&#xA;相关文章：&#xA;使用 Frida Hook Android App&#xA;使用 Frida Stalker 反 OLLVM 算法还原&#xA;Frida Stalker Trace 指令跟踪 在 Stalker.follow 的 transform 回调函数中 处理目标线程执行的每一条汇编指令。&#xA;iterator 是一个 指令迭代器对象，它让你能够 逐条处理目标线程将要执行的原始机器指令。&#xA;iterator 支持的方法&#xA;方法 作用 next() 获取下一条指令 keep() 保留指令（否则会被跳过） putCallout(fn) 插入 JS 回调（运行在主线程） 通过实现 transform 回调 trace 指定函数，打印地址、指令、模块信息&#xA;function getModuleByAddressSafe(address) {&#xD;try {&#xD;// 尝试获取模块&#xD;var module = Process.getModuleByAddress(address);&#xD;// 如果模块存在，返回模块&#xD;if (module) {&#xD;return module;&#xD;} else {&#xD;// 如果没有找到模块，返回 null&#xD;return null;&#xD;}&#xD;} catch (e) {&#xD;// 捕获异常，返回 null&#xD;return null;&#xD;}&#xD;}&#xD;/**&#xD;* 指令跟踪&#xD;*&#xD;* @param targetModuleName 目标模块名&#xD;* @param targetSymbol 函数偏移（或导出名）&#xD;*/&#xD;function trace(targetModuleName, targetSymbol) {&#xD;// 获取模块基地址&#xD;const base = Module.</description>
    </item>
    <item>
      <title>Android Dex VMP 动态加载加密指令流 </title>
      <link>https://cyrus-studio.github.io/blog/posts/android-dex-vmp-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%8A%A0%E5%AF%86%E6%8C%87%E4%BB%A4%E6%B5%81-/</link>
      <pubDate>Mon, 13 Jan 2025 21:33:28 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/android-dex-vmp-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%8A%A0%E5%AF%86%E6%8C%87%E4%BB%A4%E6%B5%81-/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;上一篇【详解如何自定义 Android Dex VMP 保护壳】实现了 VMP 保护壳。&#xA;为了进一步加强对 dex 指令的保护，实现指令流加密和动态加载，比如使用 AES 加密指令流，在运行时解密执行。&#xA;保存指令流到文件 在 010Editor 中搜索找到 sign 方法的字节码并复制&#xA;新建 Hex 文件&#xA;把 sign 方法字节码粘贴到新建的文件保存文件为 sign&#xA;AES加解密 编写一个 kotlin 语言 AES 加解密算法工具类&#xA;package com.cyrus.vmp&#xD;import java.io.ByteArrayOutputStream&#xD;import java.io.File&#xD;import java.io.FileInputStream&#xD;import java.io.FileOutputStream&#xD;import javax.crypto.Cipher&#xD;import javax.crypto.KeyGenerator&#xD;import javax.crypto.SecretKey&#xD;import javax.crypto.spec.SecretKeySpec&#xD;object AESUtils {&#xD;private const val ALGORITHM = &amp;#34;AES&amp;#34;&#xD;private const val TRANSFORMATION = &amp;#34;AES/ECB/PKCS5Padding&amp;#34; // AES 加密模式&#xD;// 生成一个 128 位的 AES 密钥&#xD;fun generateSecretKey(): SecretKey {&#xD;val keyGenerator = KeyGenerator.</description>
    </item>
    <item>
      <title>详解如何自定义 Android Dex VMP 保护壳</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E8%AF%A6%E8%A7%A3%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89-android-dex-vmp-%E4%BF%9D%E6%8A%A4%E5%A3%B3/</link>
      <pubDate>Mon, 13 Jan 2025 21:14:45 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E8%AF%A6%E8%A7%A3%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89-android-dex-vmp-%E4%BF%9D%E6%8A%A4%E5%A3%B3/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;前言 Android Dex VMP（Virtual Machine Protection，虚拟机保护）壳是一种常见的应用保护技术，主要用于保护 Android 应用的代码免受反编译和逆向工程的攻击。&#xA;VMP 保护壳通过将应用的原始 Dex（Dalvik Executable）文件进行加密、混淆、虚拟化等处理，使得恶意用户无法轻易获取到应用的原始代码和逻辑。&#xA;比如，实现一个 Android 下的 Dex VMP 保护壳，用来保护 Kotlin 层 sign 算法，防止被逆向。&#xA;假设 sign 算法源码如下：&#xA;package com.cyrus.example.vmp&#xD;import java.security.MessageDigest&#xD;import java.util.Base64&#xD;object SignUtil {&#xD;/**&#xD;* 对输入字符串进行签名并返回 Base64 编码后的字符串&#xD;* @param input 要签名的字符串&#xD;* @return Base64 编码后的字符串&#xD;*/&#xD;fun sign(input: String): String {&#xD;// 使用 SHA-256 计算摘要&#xD;val digest = MessageDigest.getInstance(&amp;#34;SHA-256&amp;#34;)&#xD;val hash = digest.digest(input.toByteArray())&#xD;// 使用 Base64 编码&#xD;return Base64.</description>
    </item>
    <item>
      <title>Windows下创建FTP服务器，实现文件共享</title>
      <link>https://cyrus-studio.github.io/blog/posts/windows%E4%B8%8B%E5%88%9B%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</link>
      <pubDate>Mon, 28 Oct 2024 22:21:39 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/windows%E4%B8%8B%E5%88%9B%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;创建FTP服务器 使用 Windows+R 打开的【运行】窗口中直接执行 optionalfeatures 打开 Windows 功能对话框。或者直接搜索【启用或关闭 Windows 功能】。 在【启用和关闭 Windows 功能】中选中【FTP服务】【IIS管理控制台】 应用更改完成后，重启电脑。&#xA;执行 ipconfig 命令查看当前电脑的ip，比如这里ip地址为 192.168.0.112&#xA;无线局域网适配器 WLAN:&#xD;连接特定的 DNS 后缀 . . . . . . . :&#xD;本地链接 IPv6 地址. . . . . . . . : fe80::74b9:ae56:5d90:79ff%6&#xD;IPv4 地址 . . . . . . . . . . . . : 192.168.0.112&#xD;子网掩码 . . . . . . . . .</description>
    </item>
    <item>
      <title>IDA静态分析中伪代码显示优化</title>
      <link>https://cyrus-studio.github.io/blog/posts/ida%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E4%B8%AD%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%98%BE%E7%A4%BA%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 07 Oct 2024 03:27:58 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/ida%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E4%B8%AD%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%98%BE%E7%A4%BA%E4%BC%98%E5%8C%96/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;1. 导入一个头文件 jni.h jni.h文件下载地址：https://github.com/CYRUS-STUDIO/blog/blob/main/assets/files/jni.h&#xA;2.还原jni函数名 点“OK”之后，当前页面好像更容易理解些，就是调用了一些jni方法 3.但是这样还不够直观，还有最后一步，如下图： 4.最后变成这样，是不是更直观呢 参考：使用IDA进行动态调试与过反调试（上）（三）</description>
    </item>
    <item>
      <title>常见的 256 条 Dalvik 字节码指令</title>
      <link>https://cyrus-studio.github.io/blog/posts/%E5%B8%B8%E8%A7%81%E7%9A%84-256-%E6%9D%A1-dalvik-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Sat, 05 Oct 2024 03:10:33 +0800</pubDate>
      <guid>https://cyrus-studio.github.io/blog/posts/%E5%B8%B8%E8%A7%81%E7%9A%84-256-%E6%9D%A1-dalvik-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</guid>
      <description>版权归作者所有，如有转发，请注明文章出处：https://cyrus-studio.github.io/blog/&#xA;Dalvik 字节码指令是 Android 虚拟机的指令集，广泛用于处理 .dex 文件中的代码。下面列出一些常用的 Dalvik 指令，但 Dalvik 指令集有很多操作码，这里仅列出 256 个常用指令及其功能简述。为简明起见，指令按类别分类。&#xA;1. 常量加载 const vA, #+B - 加载常量 B 到寄存器 vA const/4 vA, #+B - 加载 4 位常量 B 到寄存器 vA const/16 vA, #+BBBB - 加载 16 位常量 B 到寄存器 vA const/high16 vA, #+BBBB0000 - 加载高 16 位常量 const-wide vA, #+BBBBBBBBBBBBBBBB - 加载 64 位常量 const-wide/16 vA, #+BBBB - 加载 16 位宽常量 const-wide/high16 vA, #+BBBB000000000000 - 加载高 16 位宽常量 2.</description>
    </item>
  </channel>
</rss>
