<!doctype html>
<html lang="zh-cn">
  <head>
    <title>åŸºäº Unicorn å®ç°è½»é‡çº§ ARM64 æ¨¡æ‹Ÿå™¨ï¼šæ”¯æŒ Hookã€Patchã€å¯„å­˜å™¨ç›‘æ§ç­‰åŠŸèƒ½ // CYRUS STUDIO</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.131.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <meta name="keywords" content="CYRUS STUDIO, å®‰å“é€†å‘, Android Reverse Engineering, ç§»åŠ¨å¼€å‘, å®‰å“å¼€å‘, Python">
    <meta name="robots" content="index, follow">
    <link rel="stylesheet" href="/blog/css/main.min.d970c1dc93ec518baa03345e73aafb7a5a0879e5830ca966a23c6d3552430ab1.css" />
    

    
  


    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="åŸºäº Unicorn å®ç°è½»é‡çº§ ARM64 æ¨¡æ‹Ÿå™¨ï¼šæ”¯æŒ Hookã€Patchã€å¯„å­˜å™¨ç›‘æ§ç­‰åŠŸèƒ½">
  <meta name="twitter:description" content="ç‰ˆæƒå½’ä½œè€…æ‰€æœ‰ï¼Œå¦‚æœ‰è½¬å‘ï¼Œè¯·æ³¨æ˜æ–‡ç« å‡ºå¤„ï¼šhttps://cyrus-studio.github.io/blog/
å‰è¨€ åŸºäº Unicorn å®ç°ä¸€ä¸ªè½»é‡çº§çš„ ARM64 æ¨¡æ‹Ÿå™¨ï¼Œå…·å¤‡ä»£ç åŠ è½½ã€å†…å­˜æ˜ å°„ã€æŒ‡ä»¤æ‰§è¡Œã€åæ±‡ç¼–ã€å¯„å­˜å™¨ç›‘æ§ã€Hookã€Patchã€å­—ç¬¦ä¸²å¤„ç†ç­‰åŠŸèƒ½ï¼Œé€‚åˆç”¨äºé€†å‘åˆ†ææˆ–è°ƒè¯• ARM64 ä»£ç ã€‚
åˆå§‹åŒ–ä¸å†…å­˜ç®¡ç† ä»£ç åŠ è½½ï¼šé€šè¿‡ _load_binary() å°† so æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­ã€‚
å†…å­˜æ˜ å°„ï¼šåœ¨ _setup_memory() ä¸­åˆ†é… 10MB çš„ä»£ç åŒºå’Œ 1MB çš„æ ˆåŒºã€‚
å¯„å­˜å™¨åˆå§‹åŒ–ï¼šåœ¨ _setup_registers() ä¸­è®¾ç½®æ ˆæŒ‡é’ˆï¼ˆSPï¼‰å’Œç¨‹åºè®¡æ•°å™¨ï¼ˆPCï¼‰ã€‚
å¯„å­˜å™¨è®¾ç½®ï¼šæä¾›äº† set_x0()ã€set_x1() å’Œ set_x2() ç­‰æ–¹æ³•ï¼Œç”¨äºç›´æ¥è®¾ç½®å¯„å­˜å™¨å€¼ã€‚
import capstonefrom unicorn import *from unicorn.arm64_const import *class ARM64Emulator:def __init__(self, so_file: str):self.so_file = so_file# åˆ†é…ä»£ç åŒºï¼ˆTEXT æ®µï¼‰self.CODE_BASE = 0x000000 # å‡è®¾ä»£ç æ®µèµ·å§‹åœ°å€self.CODE_SIZE = 1024 * 1024 * 10 # 10MB# åˆ†é…æ ˆåŒºï¼ˆSTACK æ®µï¼‰self.">

    <meta property="og:url" content="https://cyrus-studio.github.io/blog/posts/%E5%9F%BA%E4%BA%8E-unicorn-%E5%AE%9E%E7%8E%B0%E8%BD%BB%E9%87%8F%E7%BA%A7-arm64-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%94%AF%E6%8C%81-hookpatch%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%91%E6%8E%A7%E7%AD%89%E5%8A%9F%E8%83%BD/">
  <meta property="og:site_name" content="CYRUS STUDIO">
  <meta property="og:title" content="åŸºäº Unicorn å®ç°è½»é‡çº§ ARM64 æ¨¡æ‹Ÿå™¨ï¼šæ”¯æŒ Hookã€Patchã€å¯„å­˜å™¨ç›‘æ§ç­‰åŠŸèƒ½">
  <meta property="og:description" content="ç‰ˆæƒå½’ä½œè€…æ‰€æœ‰ï¼Œå¦‚æœ‰è½¬å‘ï¼Œè¯·æ³¨æ˜æ–‡ç« å‡ºå¤„ï¼šhttps://cyrus-studio.github.io/blog/
å‰è¨€ åŸºäº Unicorn å®ç°ä¸€ä¸ªè½»é‡çº§çš„ ARM64 æ¨¡æ‹Ÿå™¨ï¼Œå…·å¤‡ä»£ç åŠ è½½ã€å†…å­˜æ˜ å°„ã€æŒ‡ä»¤æ‰§è¡Œã€åæ±‡ç¼–ã€å¯„å­˜å™¨ç›‘æ§ã€Hookã€Patchã€å­—ç¬¦ä¸²å¤„ç†ç­‰åŠŸèƒ½ï¼Œé€‚åˆç”¨äºé€†å‘åˆ†ææˆ–è°ƒè¯• ARM64 ä»£ç ã€‚
åˆå§‹åŒ–ä¸å†…å­˜ç®¡ç† ä»£ç åŠ è½½ï¼šé€šè¿‡ _load_binary() å°† so æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­ã€‚
å†…å­˜æ˜ å°„ï¼šåœ¨ _setup_memory() ä¸­åˆ†é… 10MB çš„ä»£ç åŒºå’Œ 1MB çš„æ ˆåŒºã€‚
å¯„å­˜å™¨åˆå§‹åŒ–ï¼šåœ¨ _setup_registers() ä¸­è®¾ç½®æ ˆæŒ‡é’ˆï¼ˆSPï¼‰å’Œç¨‹åºè®¡æ•°å™¨ï¼ˆPCï¼‰ã€‚
å¯„å­˜å™¨è®¾ç½®ï¼šæä¾›äº† set_x0()ã€set_x1() å’Œ set_x2() ç­‰æ–¹æ³•ï¼Œç”¨äºç›´æ¥è®¾ç½®å¯„å­˜å™¨å€¼ã€‚
import capstonefrom unicorn import *from unicorn.arm64_const import *class ARM64Emulator:def __init__(self, so_file: str):self.so_file = so_file# åˆ†é…ä»£ç åŒºï¼ˆTEXT æ®µï¼‰self.CODE_BASE = 0x000000 # å‡è®¾ä»£ç æ®µèµ·å§‹åœ°å€self.CODE_SIZE = 1024 * 1024 * 10 # 10MB# åˆ†é…æ ˆåŒºï¼ˆSTACK æ®µï¼‰self.">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-29T16:41:05+08:00">
    <meta property="article:modified_time" content="2025-06-29T16:41:05+08:00">


  </head>
  <body>
    <header class="app-header">
      <a href="https://cyrus-studio.github.io/blog/"><img class="app-header-avatar" src="/blog/avatar.jpg" alt="John Doe" /></a>
      <span class="app-header-title">CYRUS STUDIO</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/blog/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/blog/about/">About</a>
             - 
          
          <a class="app-header-menu-item" href="https://github.com/CYRUS-STUDIO">GitHub</a>
      </nav>
      <p>å…¬ä¼—å·ï¼šCYRUS STUDIO</p>
      

      <div class="qrcode-container">
          <img src="/blog/gongzhonghao.jpg" alt="å…¬ä¼—å·äºŒç»´ç " class="qrcode-image">
          <p class="qrcode-text">æ‰«ç å…³æ³¨å…¬ä¼—å·</p>
      </div>

      <div class="visitor-counter">               
        
        <div id="pageview-wrapper" style="display: none; margin-top: 1rem; font-size: 0.9rem; color: #888;">
          ğŸ‘€ è®¿é—®æ¬¡æ•°ï¼š<span class="waline-pageview-count" data-path="/">0</span>
        </div>
      </div>

      <script type="module">
        import { pageviewCount } from 'https://unpkg.com/@waline/client@v3/dist/pageview.js';

        
        pageviewCount({
          serverURL: 'https://waline-15wtwfoa7-cyrus-studios-projects.vercel.app',
          path: '/',
          update: true
        });

        
        setTimeout(() => {
          const el = document.querySelector('.waline-pageview-count[data-path="/"]');
          const count = el?.innerText?.trim();
          if (count && count !== '0') {
            document.getElementById('pageview-wrapper').style.display = 'block';
          }
        }, 2000);
      </script>

    </header>
    <main class="app-container">
      
<article class="post">
  <header class="post-header">
    <meta charset="UTF-8"/>
    <h1 class="post-title">åŸºäº Unicorn å®ç°è½»é‡çº§ ARM64 æ¨¡æ‹Ÿå™¨ï¼šæ”¯æŒ Hookã€Patchã€å¯„å­˜å™¨ç›‘æ§ç­‰åŠŸèƒ½</h1>
    <div class="post-meta" style="display: flex; gap: 1em; flex-wrap: wrap; align-items: center;">
      <div>
        <span class="meta-item">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-eye">
  <title>eye</title>
  <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>
</svg>
          é˜…è¯»é‡: <span class="waline-pageview-count" data-path="/blog/posts/%E5%9F%BA%E4%BA%8E-unicorn-%E5%AE%9E%E7%8E%B0%E8%BD%BB%E9%87%8F%E7%BA%A7-arm64-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%94%AF%E6%8C%81-hookpatch%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%91%E6%8E%A7%E7%AD%89%E5%8A%9F%E8%83%BD/"></span>
        </span>
      </div>
      <div>
        <span class="meta-item">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jun 29, 2025
        </span>
      </div>
      <div>
        <span class="meta-item">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          8 min read
        </span>
      </div>
    </div>

    <link
      rel="stylesheet"
      href="https://unpkg.com/@waline/client@v3/dist/waline.css"
    />

  </header>
  <div class="post-content">
    <blockquote>
<p>ç‰ˆæƒå½’ä½œè€…æ‰€æœ‰ï¼Œå¦‚æœ‰è½¬å‘ï¼Œè¯·æ³¨æ˜æ–‡ç« å‡ºå¤„ï¼š<a href="https://cyrus-studio.github.io/blog/">https://cyrus-studio.github.io/blog/</a></p>
</blockquote>
<h1 id="å‰è¨€">å‰è¨€</h1>
<p>åŸºäº Unicorn å®ç°ä¸€ä¸ªè½»é‡çº§çš„ ARM64 æ¨¡æ‹Ÿå™¨ï¼Œå…·å¤‡ä»£ç åŠ è½½ã€å†…å­˜æ˜ å°„ã€æŒ‡ä»¤æ‰§è¡Œã€åæ±‡ç¼–ã€å¯„å­˜å™¨ç›‘æ§ã€Hookã€Patchã€å­—ç¬¦ä¸²å¤„ç†ç­‰åŠŸèƒ½ï¼Œé€‚åˆç”¨äºé€†å‘åˆ†ææˆ–è°ƒè¯• ARM64 ä»£ç ã€‚</p>
<h1 id="åˆå§‹åŒ–ä¸å†…å­˜ç®¡ç†">åˆå§‹åŒ–ä¸å†…å­˜ç®¡ç†</h1>
<ul>
<li>
<p>ä»£ç åŠ è½½ï¼šé€šè¿‡ _load_binary() å°† so æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­ã€‚</p>
</li>
<li>
<p>å†…å­˜æ˜ å°„ï¼šåœ¨ _setup_memory() ä¸­åˆ†é… 10MB çš„ä»£ç åŒºå’Œ 1MB çš„æ ˆåŒºã€‚</p>
</li>
<li>
<p>å¯„å­˜å™¨åˆå§‹åŒ–ï¼šåœ¨ _setup_registers() ä¸­è®¾ç½®æ ˆæŒ‡é’ˆï¼ˆSPï¼‰å’Œç¨‹åºè®¡æ•°å™¨ï¼ˆPCï¼‰ã€‚</p>
</li>
<li>
<p>å¯„å­˜å™¨è®¾ç½®ï¼šæä¾›äº† set_x0()ã€set_x1() å’Œ set_x2() ç­‰æ–¹æ³•ï¼Œç”¨äºç›´æ¥è®¾ç½®å¯„å­˜å™¨å€¼ã€‚</p>
</li>
</ul>
<pre tabindex="0"><code>import capstone
from unicorn import *
from unicorn.arm64_const import *


class ARM64Emulator:

    def __init__(self, so_file: str):
        self.so_file = so_file

        # åˆ†é…ä»£ç åŒºï¼ˆTEXT æ®µï¼‰
        self.CODE_BASE = 0x000000  # å‡è®¾ä»£ç æ®µèµ·å§‹åœ°å€
        self.CODE_SIZE = 1024 * 1024 * 10  # 10MB

        # åˆ†é…æ ˆåŒºï¼ˆSTACK æ®µï¼‰
        self.STACK_BASE = self.CODE_BASE + self.CODE_SIZE
        self.STACK_SIZE = 1024 * 1024 * 1  # 1MB

        # åˆå§‹åŒ– Unicorn
        self.mu = Uc(UC_ARCH_ARM64, UC_MODE_ARM)

        self._load_binary()
        self._setup_memory()
        self._setup_registers()
        self._setup_hooks()

    def _load_binary(self):
        with open(self.so_file, &#34;rb&#34;) as f:
            self.CODE = f.read()

    def _setup_memory(self):
        self.mu.mem_map(self.CODE_BASE, self.CODE_SIZE)
        self.mu.mem_map(self.STACK_BASE, self.STACK_SIZE)
        # å†™å…¥æŒ‡ä»¤
        self.mu.mem_write(self.CODE_BASE, self.CODE)

    def _setup_registers(self):
        self.mu.reg_write(UC_ARM64_REG_SP, self.STACK_BASE + self.STACK_SIZE - 4)  # ä½¿ SP ä»æ ˆçš„é¡¶éƒ¨å¾€ä¸‹ç§»åŠ¨ 4 å­—èŠ‚ï¼Œä»¥ é¢„ç•™ä¸€ç‚¹ç©ºé—´ï¼Œé¿å…è¶Šç•Œé”™è¯¯ã€‚
        self.mu.reg_write(UC_ARM64_REG_PC, self.CODE_BASE)

    def set_x0(self, value):
        self.mu.reg_write(UC_ARM64_REG_X0, value)

    def set_x1(self, value):
        self.mu.reg_write(UC_ARM64_REG_X1, value)


    def set_x2(self, value):
        self.mu.reg_write(UC_ARM64_REG_X2, value)
</code></pre><h1 id="æ‰“å°å¯„å­˜å™¨">æ‰“å°å¯„å­˜å™¨</h1>
<p>dump_registers() æ‰“å°æ‰€æœ‰ ARM64 å¯„å­˜å™¨çš„å½“å‰å€¼ã€‚</p>
<pre tabindex="0"><code>def dump_registers(self):
    &#34;&#34;&#34; æ‰“å° Unicorn ARM64 CPU çš„æ‰€æœ‰å¯„å­˜å™¨ &#34;&#34;&#34;
    print(&#34;\n====== Registers Dump ======&#34;)

    # éå† X0 - X30
    for i in range(31):  # X0 ~ X30
        reg_id = getattr(arm64_const, f&#39;UC_ARM64_REG_X{i}&#39;)
        value = self.mu.reg_read(reg_id)
        print(f&#34;X{i:02}: 0x{value:016x}&#34;)

    # æ‰“å° SPï¼ˆæ ˆæŒ‡é’ˆï¼‰å’Œ PCï¼ˆç¨‹åºè®¡æ•°å™¨ï¼‰
    sp = self.mu.reg_read(UC_ARM64_REG_SP)
    pc = self.mu.reg_read(UC_ARM64_REG_PC)

    print(f&#34;\nSP:  0x{sp:016x}&#34;)
    print(f&#34;PC:  0x{pc:016x}&#34;)
    print(&#34;============================\n&#34;)
</code></pre><h1 id="è¿è¡Œç¨‹åº">è¿è¡Œç¨‹åº</h1>
<p>run() ä½¿ç”¨ emu_start() è¿è¡Œä» start_address åˆ° end_address çš„æŒ‡ä»¤ã€‚</p>
<pre tabindex="0"><code>def run(self, start_address, end_address):
    print(&#34;\nBefore execution:&#34;)
    self.dump_registers()
    # è¿è¡Œ Unicorn
    self.mu.emu_start(self.CODE_BASE + start_address, self.CODE_BASE + end_address)
    print(&#34;\nAfter execution:&#34;)
    self.dump_registers()
</code></pre><h1 id="åæ±‡ç¼–">åæ±‡ç¼–</h1>
<p>disassembly() ä½¿ç”¨ Capstone å¯¹æŒ‡å®šåœ°å€çš„å†…å­˜æ•°æ®è¿›è¡Œåæ±‡ç¼–ã€‚</p>
<pre tabindex="0"><code>class ARM64Emulator:

    def __init__(self, so_file: str):
        
        # åˆå§‹åŒ– Capstone åæ±‡ç¼–å™¨ (é’ˆå¯¹ ARM64 æ¶æ„)
        self.cs = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)

    def disassembly(self, start_address, end_address):
        &#34;&#34;&#34;
        åæ±‡ç¼–æŒ‡å®šåœ°å€çš„å­—èŠ‚ç 
        :param start_address: å¼€å§‹åœ°å€
        :param end_address: ç»“æŸåœ°å€
        &#34;&#34;&#34;
        # æå–ç›®æ ‡æ–¹æ³•çš„å­—èŠ‚ç 
        target_data = self.CODE[start_address:end_address]
        # åæ±‡ç¼–å­—èŠ‚ç 
        print(&#34;Disassembly:&#34;)
        for instruction in self.cs.disasm(target_data, start_address):
            print(f&#34;0x{instruction.address:x}:\t{instruction.mnemonic}\t{instruction.op_str}&#34;)
            
</code></pre><h1 id="hook-ç®¡ç†">Hook ç®¡ç†</h1>
<ul>
<li>
<p>ä»£ç  Hookï¼šåœ¨ _setup_hooks() ä¸­è®¾ç½® UC_HOOK_CODE é’©å­ï¼Œæ¯æ¬¡æ‰§è¡Œåˆ°ä¸€æ¡æŒ‡ä»¤æ—¶è§¦å‘ hook_code()ã€‚</p>
</li>
<li>
<p>æ³¨å†Œ Hookï¼šregister_hook() å…è®¸ç”¨æˆ·åœ¨ç‰¹å®šåœ°å€æ³¨å†Œè‡ªå®šä¹‰çš„ Hook å‡½æ•°ã€‚</p>
</li>
<li>
<p>å–æ¶ˆ Hookï¼šunregister_hook() æä¾›å–æ¶ˆ Hook çš„åŠŸèƒ½ã€‚</p>
</li>
</ul>
<pre tabindex="0"><code>class ARM64Emulator:

    def __init__(self, so_file: str):
        
        self._hooks = [] # å­˜å‚¨æ‰€æœ‰æ³¨å†Œçš„ Hook
        
        self._setup_hooks()
        
    def _setup_hooks(self):
        self.mu.hook_add(UC_HOOK_CODE, self.hook_code)
        
    def hook_code(self, mu, address, size, user_data):
        code = mu.mem_read(address, size)
        # åæ±‡ç¼–å¹¶æ‰“å°å½“å‰æ‰§è¡Œçš„æŒ‡ä»¤
        for i in self.cs.disasm(code, 0, len(code)):
            print(&#34;[addr:%x;code:%s]:%s %s&#34; % (address, code.hex(), i.mnemonic, i.op_str))
    
        # éå†æ‰€æœ‰å·²æ³¨å†Œçš„ Hookï¼Œå¹¶æ‰§è¡ŒåŒ¹é…çš„ Hook
        for hook_addr, hook_fn in self._hooks:
            if address == hook_addr:
                hook_fn()
                
    def register_hook(self, address: int, hook_fn):
        &#34;&#34;&#34;
        æ³¨å†Œ Hook
        :param address: éœ€è¦ Hook çš„åœ°å€
        :param hook_fn: Hook å¤„ç†å‡½æ•°
        &#34;&#34;&#34;
        self._hooks.append((address, hook_fn))
        print(f&#34;Hook registered at {hex(address)}&#34;)
    
    def unregister_hook(self, address: int):
        &#34;&#34;&#34;
        å–æ¶ˆ Hook
        :param address: éœ€è¦è§£é™¤ Hook çš„åœ°å€
        &#34;&#34;&#34;
        self._hooks = [(addr, fn) for addr, fn in self._hooks if addr != address]
        print(f&#34;Hook unregistered at {hex(address)}&#34;)
</code></pre><h1 id="å¯„å­˜å™¨ç›‘æ§">å¯„å­˜å™¨ç›‘æ§</h1>
<ul>
<li>
<p>ç›‘æ§å¯„å­˜å™¨å˜æ›´ï¼šwatch_registers() æ”¯æŒç›‘æ§ç‰¹å®šå¯„å­˜å™¨çš„å˜åŒ–ï¼Œå¹¶åœ¨å˜åŒ–æ—¶æ‰“å°ç›¸å…³ä¿¡æ¯ã€‚</p>
</li>
<li>
<p>è‡ªåŠ¨æ›´æ–°å¯„å­˜å™¨å€¼ï¼šåœ¨ hook_code() ä¸­æ£€æµ‹å˜åŒ–ï¼Œå¹¶è¾“å‡ºå˜åŒ–ä¿¡æ¯ã€‚</p>
</li>
</ul>
<pre tabindex="0"><code>class ARM64Emulator:

    def __init__(self, so_file: str):

        self._last_registers = {}  # è®°å½•ä¸Šæ¬¡çš„å¯„å­˜å™¨å€¼
        self._watch_registers = set()  # å­˜å‚¨éœ€è¦ç›‘æ§çš„å¯„å­˜å™¨
    
    def hook_code(self, mu, address, size, user_data):
        code = mu.mem_read(address, size)
    
        insn = next(self.cs.disasm(code, 0, len(code)), None)
        if not insn:
            return
    
        # æ£€æŸ¥ç›‘æ§çš„å¯„å­˜å™¨æ˜¯å¦å˜åŒ–
        for reg in self._watch_registers:
            new_value = mu.reg_read(reg)
            if self._last_registers[reg] != new_value:
                print(f&#34;&gt;&gt; PC: 0x{address:X}, {insn.mnemonic} {insn.op_str}, {reg} changed: 0x{self._last_registers[reg]:X} -&gt; 0x{new_value:X}&#34;)
                self._last_registers[reg] = new_value  # æ›´æ–°å€¼
    
    def watch_registers(self, *regs):
        &#34;&#34;&#34;
        æ·»åŠ è¦ç›‘æ§çš„å¯„å­˜å™¨
    
        ä½¿ç”¨ç¤ºä¾‹: emu.watch_registers(&#34;X4&#34;, &#34;X8&#34;)  # ç›‘æ§ X4 å’Œ X8
    
        &#34;&#34;&#34;
        reg_map = {
            &#34;X0&#34;: UC_ARM64_REG_X0, &#34;X1&#34;: UC_ARM64_REG_X1, &#34;X2&#34;: UC_ARM64_REG_X2, &#34;X3&#34;: UC_ARM64_REG_X3,
            &#34;X4&#34;: UC_ARM64_REG_X4, &#34;X5&#34;: UC_ARM64_REG_X5, &#34;X6&#34;: UC_ARM64_REG_X6, &#34;X7&#34;: UC_ARM64_REG_X7,
            &#34;X8&#34;: UC_ARM64_REG_X8, &#34;X9&#34;: UC_ARM64_REG_X9, &#34;X10&#34;: UC_ARM64_REG_X10, &#34;X11&#34;: UC_ARM64_REG_X11,
            &#34;X12&#34;: UC_ARM64_REG_X12, &#34;X13&#34;: UC_ARM64_REG_X13, &#34;X14&#34;: UC_ARM64_REG_X14, &#34;X15&#34;: UC_ARM64_REG_X15,
            &#34;X16&#34;: UC_ARM64_REG_X16, &#34;X17&#34;: UC_ARM64_REG_X17, &#34;X18&#34;: UC_ARM64_REG_X18, &#34;X19&#34;: UC_ARM64_REG_X19,
            &#34;X20&#34;: UC_ARM64_REG_X20, &#34;X21&#34;: UC_ARM64_REG_X21, &#34;X22&#34;: UC_ARM64_REG_X22, &#34;X23&#34;: UC_ARM64_REG_X23,
            &#34;X24&#34;: UC_ARM64_REG_X24, &#34;X25&#34;: UC_ARM64_REG_X25, &#34;X26&#34;: UC_ARM64_REG_X26, &#34;X27&#34;: UC_ARM64_REG_X27,
            &#34;X28&#34;: UC_ARM64_REG_X28, &#34;FP&#34;: UC_ARM64_REG_FP, &#34;LR&#34;: UC_ARM64_REG_LR, &#34;SP&#34;: UC_ARM64_REG_SP,
            &#34;PC&#34;: UC_ARM64_REG_PC
        }
        for reg in regs:
            if reg in reg_map:
                self._watch_registers.add(reg_map[reg])
                self._last_registers[reg_map[reg]] = 0  # åˆå§‹åŒ–è®°å½•å€¼
</code></pre><h1 id="patch-nop">Patch NOP</h1>
<ul>
<li>
<p>patch_nop()ï¼šå°†ç»™å®šåœ°å€åˆ—è¡¨ä¸­çš„æŒ‡ä»¤æ›¿æ¢ä¸º NOPï¼ˆ0xD503201Fï¼‰ã€‚</p>
</li>
<li>
<p>patch_nop_range()ï¼šå°†æŒ‡å®šåœ°å€èŒƒå›´å†…çš„æ‰€æœ‰æŒ‡ä»¤æ›¿æ¢ä¸º NOPã€‚</p>
</li>
</ul>
<pre tabindex="0"><code>def patch_nop_range(self, start_addr: int, end_addr: int):
    &#34;&#34;&#34;
    åœ¨æŒ‡å®šèŒƒå›´å†…å°†æŒ‡ä»¤ patch ä¸º NOP (0xD503201F)ï¼Œ**åŒ…æ‹¬ end_addr ä½ç½®**

    :param start_addr: éœ€è¦ patch çš„èµ·å§‹åœ°å€ (å¿…é¡» 4 å­—èŠ‚å¯¹é½)
    :param end_addr: éœ€è¦ patch çš„ç»“æŸåœ°å€ (å¿…é¡» 4 å­—èŠ‚å¯¹é½ï¼ŒåŒ…å«æ­¤åœ°å€)
    &#34;&#34;&#34;
    # ç¡®ä¿åœ°å€å¯¹é½
    if start_addr % 4 != 0 or end_addr % 4 != 0:
        raise ValueError(&#34;Start and end addresses must be 4-byte aligned.&#34;)

    if end_addr &lt; start_addr:
        raise ValueError(&#34;End address must be greater than or equal to start address.&#34;)

    # NOP æŒ‡ä»¤åœ¨ AArch64 ä¸‹çš„ç¼–ç 
    NOP_INSTRUCTION = b&#39;\x1F\x20\x03\xD5&#39;  # 0xD503201F

    # è®¡ç®— patch çš„æŒ‡ä»¤æ•°é‡ (åŒ…æ‹¬ end_addr)
    nop_count = ((end_addr - start_addr) // 4) + 1

    # ç”Ÿæˆ NOP æŒ‡ä»¤åºåˆ—
    nop_data = NOP_INSTRUCTION * nop_count

    # å†™å…¥ Unicorn å†…å­˜
    self.mu.mem_write(start_addr, nop_data)

    print(f&#34;Patched {nop_count} instructions to NOP from {hex(start_addr)} to {hex(end_addr)} (inclusive)&#34;)

def patch_nop(self, addr_list: list):
    &#34;&#34;&#34;
    å°†åœ°å€åˆ—è¡¨ä¸­çš„æ¯ä¸ªåœ°å€ patch ä¸º NOP (0xD503201F)

    :param addr_list: éœ€è¦ patch çš„åœ°å€åˆ—è¡¨ (æ¯ä¸ªåœ°å€å¿…é¡» 4 å­—èŠ‚å¯¹é½)
    &#34;&#34;&#34;
    # NOP æŒ‡ä»¤åœ¨ AArch64 ä¸‹çš„ç¼–ç 
    NOP_INSTRUCTION = b&#39;\x1F\x20\x03\xD5&#39;  # 0xD503201F

    for addr in addr_list:
        if addr % 4 != 0:
            raise ValueError(f&#34;Address {hex(addr)} is not 4-byte aligned.&#34;)

        self.mu.mem_write(addr, NOP_INSTRUCTION)
        print(f&#34;Patched NOP at {hex(addr)}&#34;)
</code></pre><h1 id="å­—ç¬¦ä¸²æ“ä½œ">å­—ç¬¦ä¸²æ“ä½œ</h1>
<ul>
<li>
<p>get_string_utf_chars() æ¨¡æ‹Ÿäº† GetStringUTFChars()ï¼Œåœ¨æŒ‡å®šå†…å­˜åœ°å€å†™å…¥ UTF-8 ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›æŒ‡é’ˆåœ°å€ã€‚</p>
</li>
<li>
<p>read_c_string() ä»ä»¿çœŸå™¨å†…å­˜ä¸­è¯»å–ä»¥ NULL ç»“å°¾çš„ C è¯­è¨€å­—ç¬¦ä¸²ã€‚</p>
</li>
</ul>
<pre tabindex="0"><code>def get_string_utf_chars(self, input_str: str, str_addr: int):
    &#34;&#34;&#34;
    æ¨¡æ‹Ÿ GetStringUTFCharsï¼ŒæŠŠ Python å‚æ•° `input_str` ä½œä¸ºè¿”å›çš„ UTF-8 å­—ç¬¦ä¸²
    &#34;&#34;&#34;
    utf8_str = input_str.encode(&#34;utf-8&#34;) + b&#34;\x00&#34;  # UTF-8 ç¼–ç å¹¶åŠ  NULL ç»ˆæ­¢ç¬¦

    # å†™å…¥ Unicorn å†…å­˜
    self.mu.mem_write(str_addr, utf8_str)

    # è®¾ç½® X0 è¿”å›å€¼ (UTF-8 å­—ç¬¦ä¸²åœ°å€)
    self.mu.reg_write(UC_ARM64_REG_X0, str_addr)

    print(f&#34;GetStringUTFChars Hooked: &#39;{input_str}&#39; -&gt; {hex(str_addr)}&#34;)

def read_c_string(self, addr, max_len=256):
    &#34;&#34;&#34; ä» Unicorn æ¨¡æ‹Ÿå†…å­˜ä¸­è¯»å– C è¯­è¨€å­—ç¬¦ä¸²ï¼ˆä»¥ null ç»“å°¾ï¼‰ &#34;&#34;&#34;
    result = b&#34;&#34;
    for i in range(max_len):
        byte = self.mu.mem_read(addr + i, 1)
        if byte == b&#34;\x00&#34;:  # é‡åˆ° null ç»ˆæ­¢ç¬¦
            break
        result += byte
    return result.decode(&#34;utf-8&#34;, errors=&#34;ignore&#34;)
</code></pre><h1 id="å®Œæ•´æºç ">å®Œæ•´æºç </h1>
<pre tabindex="0"><code>import capstone
from unicorn import *
from unicorn.arm64_const import *


class ARM64Emulator:

    def __init__(self, so_file: str):
        self.so_file = so_file

        self._hooks = [] # å­˜å‚¨æ‰€æœ‰æ³¨å†Œçš„ Hook
        self._last_registers = {}  # è®°å½•ä¸Šæ¬¡çš„å¯„å­˜å™¨å€¼
        self._watch_registers = set()  # å­˜å‚¨éœ€è¦ç›‘æ§çš„å¯„å­˜å™¨

        # åˆ†é…ä»£ç åŒºï¼ˆTEXT æ®µï¼‰
        self.CODE_BASE = 0x000000  # å‡è®¾ä»£ç æ®µèµ·å§‹åœ°å€
        self.CODE_SIZE = 1024 * 1024 * 10  # 10MB

        # åˆ†é…æ ˆåŒºï¼ˆSTACK æ®µï¼‰
        self.STACK_BASE = self.CODE_BASE + self.CODE_SIZE
        self.STACK_SIZE = 1024 * 1024 * 1  # 1MB

        # åˆå§‹åŒ– Unicorn
        self.mu = Uc(UC_ARCH_ARM64, UC_MODE_ARM)
        # åˆå§‹åŒ– Capstone åæ±‡ç¼–å™¨ (é’ˆå¯¹ ARM64 æ¶æ„)
        self.cs = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)

        self._load_binary()
        self._setup_memory()
        self._setup_registers()
        self._setup_hooks()

    def _load_binary(self):
        with open(self.so_file, &#34;rb&#34;) as f:
            self.CODE = f.read()

    def _setup_memory(self):
        self.mu.mem_map(self.CODE_BASE, self.CODE_SIZE)
        self.mu.mem_map(self.STACK_BASE, self.STACK_SIZE)
        # å†™å…¥æŒ‡ä»¤
        self.mu.mem_write(self.CODE_BASE, self.CODE)

    def _setup_registers(self):
        self.mu.reg_write(UC_ARM64_REG_SP, self.STACK_BASE + self.STACK_SIZE - 4)  # ä½¿ SP ä»æ ˆçš„é¡¶éƒ¨å¾€ä¸‹ç§»åŠ¨ 4 å­—èŠ‚ï¼Œä»¥ é¢„ç•™ä¸€ç‚¹ç©ºé—´ï¼Œé¿å…è¶Šç•Œé”™è¯¯ã€‚
        self.mu.reg_write(UC_ARM64_REG_PC, self.CODE_BASE)

    def set_x0(self, value):
        self.mu.reg_write(UC_ARM64_REG_X0, value)


    def set_x1(self, value):
        self.mu.reg_write(UC_ARM64_REG_X1, value)


    def set_x2(self, value):
        self.mu.reg_write(UC_ARM64_REG_X2, value)

    def _setup_hooks(self):
        self.mu.hook_add(UC_HOOK_CODE, self.hook_code)


    def dump_registers(self):
        &#34;&#34;&#34; æ‰“å° Unicorn ARM64 CPU çš„æ‰€æœ‰å¯„å­˜å™¨ &#34;&#34;&#34;
        print(&#34;\n====== Registers Dump ======&#34;)

        # éå† X0 - X30
        for i in range(31):  # X0 ~ X30
            reg_id = getattr(arm64_const, f&#39;UC_ARM64_REG_X{i}&#39;)
            value = self.mu.reg_read(reg_id)
            print(f&#34;X{i:02}: 0x{value:016x}&#34;)

        # æ‰“å° SPï¼ˆæ ˆæŒ‡é’ˆï¼‰å’Œ PCï¼ˆç¨‹åºè®¡æ•°å™¨ï¼‰
        sp = self.mu.reg_read(UC_ARM64_REG_SP)
        pc = self.mu.reg_read(UC_ARM64_REG_PC)

        print(f&#34;\nSP:  0x{sp:016x}&#34;)
        print(f&#34;PC:  0x{pc:016x}&#34;)
        print(&#34;============================\n&#34;)

    def run(self, start_address, end_address):
        print(&#34;\nBefore execution:&#34;)
        self.dump_registers()
        # è¿è¡Œ Unicorn
        self.mu.emu_start(self.CODE_BASE + start_address, self.CODE_BASE + end_address)
        print(&#34;\nAfter execution:&#34;)
        self.dump_registers()

    def disassembly(self, start_address, end_address):
        &#34;&#34;&#34;
        åæ±‡ç¼–æŒ‡å®šåœ°å€çš„å­—èŠ‚ç 
        :param start_address: å¼€å§‹åœ°å€
        :param end_address: ç»“æŸåœ°å€
        &#34;&#34;&#34;
        # æå–ç›®æ ‡æ–¹æ³•çš„å­—èŠ‚ç 
        target_data = self.CODE[start_address:end_address]
        # åæ±‡ç¼–å­—èŠ‚ç 
        print(&#34;Disassembly:&#34;)
        for instruction in self.cs.disasm(target_data, start_address):
            print(f&#34;0x{instruction.address:x}:\t{instruction.mnemonic}\t{instruction.op_str}&#34;)


    def hook_code(self, mu, address, size, user_data):
        code = mu.mem_read(address, size)
        # åæ±‡ç¼–å¹¶æ‰“å°å½“å‰æ‰§è¡Œçš„æŒ‡ä»¤
        for i in self.cs.disasm(code, 0, len(code)):
            print(&#34;[addr:%x;code:%s]:%s %s&#34; % (address, code.hex(), i.mnemonic, i.op_str))

        # éå†æ‰€æœ‰å·²æ³¨å†Œçš„ Hookï¼Œå¹¶æ‰§è¡ŒåŒ¹é…çš„ Hook
        for hook_addr, hook_fn in self._hooks:
            if address == hook_addr:
                hook_fn()

        insn = next(self.cs.disasm(code, 0, len(code)), None)
        if not insn:
            return

        # æ£€æŸ¥ç›‘æ§çš„å¯„å­˜å™¨æ˜¯å¦å˜åŒ–
        for reg in self._watch_registers:
            new_value = mu.reg_read(reg)
            if self._last_registers[reg] != new_value:
                print(f&#34;&gt;&gt; PC: 0x{address:X}, {insn.mnemonic} {insn.op_str}, {reg} changed: 0x{self._last_registers[reg]:X} -&gt; 0x{new_value:X}&#34;)
                self._last_registers[reg] = new_value  # æ›´æ–°å€¼


    def register_hook(self, address: int, hook_fn):
        &#34;&#34;&#34;
        æ³¨å†Œ Hook
        :param address: éœ€è¦ Hook çš„åœ°å€
        :param hook_fn: Hook å¤„ç†å‡½æ•°
        &#34;&#34;&#34;
        self._hooks.append((address, hook_fn))
        print(f&#34;Hook registered at {hex(address)}&#34;)

    def unregister_hook(self, address: int):
        &#34;&#34;&#34;
        å–æ¶ˆ Hook
        :param address: éœ€è¦è§£é™¤ Hook çš„åœ°å€
        &#34;&#34;&#34;
        self._hooks = [(addr, fn) for addr, fn in self._hooks if addr != address]
        print(f&#34;Hook unregistered at {hex(address)}&#34;)

    def watch_registers(self, *regs):
        &#34;&#34;&#34;
        æ·»åŠ è¦ç›‘æ§çš„å¯„å­˜å™¨

        ä½¿ç”¨ç¤ºä¾‹: emu.watch_registers(&#34;X4&#34;, &#34;X8&#34;)  # ç›‘æ§ X4 å’Œ X8

        &#34;&#34;&#34;
        reg_map = {
            &#34;X0&#34;: UC_ARM64_REG_X0, &#34;X1&#34;: UC_ARM64_REG_X1, &#34;X2&#34;: UC_ARM64_REG_X2, &#34;X3&#34;: UC_ARM64_REG_X3,
            &#34;X4&#34;: UC_ARM64_REG_X4, &#34;X5&#34;: UC_ARM64_REG_X5, &#34;X6&#34;: UC_ARM64_REG_X6, &#34;X7&#34;: UC_ARM64_REG_X7,
            &#34;X8&#34;: UC_ARM64_REG_X8, &#34;X9&#34;: UC_ARM64_REG_X9, &#34;X10&#34;: UC_ARM64_REG_X10, &#34;X11&#34;: UC_ARM64_REG_X11,
            &#34;X12&#34;: UC_ARM64_REG_X12, &#34;X13&#34;: UC_ARM64_REG_X13, &#34;X14&#34;: UC_ARM64_REG_X14, &#34;X15&#34;: UC_ARM64_REG_X15,
            &#34;X16&#34;: UC_ARM64_REG_X16, &#34;X17&#34;: UC_ARM64_REG_X17, &#34;X18&#34;: UC_ARM64_REG_X18, &#34;X19&#34;: UC_ARM64_REG_X19,
            &#34;X20&#34;: UC_ARM64_REG_X20, &#34;X21&#34;: UC_ARM64_REG_X21, &#34;X22&#34;: UC_ARM64_REG_X22, &#34;X23&#34;: UC_ARM64_REG_X23,
            &#34;X24&#34;: UC_ARM64_REG_X24, &#34;X25&#34;: UC_ARM64_REG_X25, &#34;X26&#34;: UC_ARM64_REG_X26, &#34;X27&#34;: UC_ARM64_REG_X27,
            &#34;X28&#34;: UC_ARM64_REG_X28, &#34;FP&#34;: UC_ARM64_REG_FP, &#34;LR&#34;: UC_ARM64_REG_LR, &#34;SP&#34;: UC_ARM64_REG_SP,
            &#34;PC&#34;: UC_ARM64_REG_PC
        }
        for reg in regs:
            if reg in reg_map:
                self._watch_registers.add(reg_map[reg])
                self._last_registers[reg_map[reg]] = 0  # åˆå§‹åŒ–è®°å½•å€¼

    def patch_nop_range(self, start_addr: int, end_addr: int):
        &#34;&#34;&#34;
        åœ¨æŒ‡å®šèŒƒå›´å†…å°†æŒ‡ä»¤ patch ä¸º NOP (0xD503201F)ï¼Œ**åŒ…æ‹¬ end_addr ä½ç½®**

        :param start_addr: éœ€è¦ patch çš„èµ·å§‹åœ°å€ (å¿…é¡» 4 å­—èŠ‚å¯¹é½)
        :param end_addr: éœ€è¦ patch çš„ç»“æŸåœ°å€ (å¿…é¡» 4 å­—èŠ‚å¯¹é½ï¼ŒåŒ…å«æ­¤åœ°å€)
        &#34;&#34;&#34;
        # ç¡®ä¿åœ°å€å¯¹é½
        if start_addr % 4 != 0 or end_addr % 4 != 0:
            raise ValueError(&#34;Start and end addresses must be 4-byte aligned.&#34;)

        if end_addr &lt; start_addr:
            raise ValueError(&#34;End address must be greater than or equal to start address.&#34;)

        # NOP æŒ‡ä»¤åœ¨ AArch64 ä¸‹çš„ç¼–ç 
        NOP_INSTRUCTION = b&#39;\x1F\x20\x03\xD5&#39;  # 0xD503201F

        # è®¡ç®— patch çš„æŒ‡ä»¤æ•°é‡ (åŒ…æ‹¬ end_addr)
        nop_count = ((end_addr - start_addr) // 4) + 1

        # ç”Ÿæˆ NOP æŒ‡ä»¤åºåˆ—
        nop_data = NOP_INSTRUCTION * nop_count

        # å†™å…¥ Unicorn å†…å­˜
        self.mu.mem_write(start_addr, nop_data)

        print(f&#34;Patched {nop_count} instructions to NOP from {hex(start_addr)} to {hex(end_addr)} (inclusive)&#34;)

    def patch_nop(self, addr_list: list):
        &#34;&#34;&#34;
        å°†åœ°å€åˆ—è¡¨ä¸­çš„æ¯ä¸ªåœ°å€ patch ä¸º NOP (0xD503201F)

        :param addr_list: éœ€è¦ patch çš„åœ°å€åˆ—è¡¨ (æ¯ä¸ªåœ°å€å¿…é¡» 4 å­—èŠ‚å¯¹é½)
        &#34;&#34;&#34;
        # NOP æŒ‡ä»¤åœ¨ AArch64 ä¸‹çš„ç¼–ç 
        NOP_INSTRUCTION = b&#39;\x1F\x20\x03\xD5&#39;  # 0xD503201F

        for addr in addr_list:
            if addr % 4 != 0:
                raise ValueError(f&#34;Address {hex(addr)} is not 4-byte aligned.&#34;)

            self.mu.mem_write(addr, NOP_INSTRUCTION)
            print(f&#34;Patched NOP at {hex(addr)}&#34;)

    def get_string_utf_chars(self, input_str: str, str_addr: int):
        &#34;&#34;&#34;
        æ¨¡æ‹Ÿ GetStringUTFCharsï¼ŒæŠŠ Python å‚æ•° `input_str` ä½œä¸ºè¿”å›çš„ UTF-8 å­—ç¬¦ä¸²
        &#34;&#34;&#34;
        utf8_str = input_str.encode(&#34;utf-8&#34;) + b&#34;\x00&#34;  # UTF-8 ç¼–ç å¹¶åŠ  NULL ç»ˆæ­¢ç¬¦

        # å†™å…¥ Unicorn å†…å­˜
        self.mu.mem_write(str_addr, utf8_str)

        # è®¾ç½® X0 è¿”å›å€¼ (UTF-8 å­—ç¬¦ä¸²åœ°å€)
        self.mu.reg_write(UC_ARM64_REG_X0, str_addr)

        print(f&#34;GetStringUTFChars Hooked: &#39;{input_str}&#39; -&gt; {hex(str_addr)}&#34;)

    def read_c_string(self, addr, max_len=256):
        &#34;&#34;&#34; ä» Unicorn æ¨¡æ‹Ÿå†…å­˜ä¸­è¯»å– C è¯­è¨€å­—ç¬¦ä¸²ï¼ˆä»¥ null ç»“å°¾ï¼‰ &#34;&#34;&#34;
        result = b&#34;&#34;
        for i in range(max_len):
            byte = self.mu.mem_read(addr + i, 1)
            if byte == b&#34;\x00&#34;:  # é‡åˆ° null ç»ˆæ­¢ç¬¦
                break
            result += byte
        return result.decode(&#34;utf-8&#34;, errors=&#34;ignore&#34;)
</code></pre><p>å¼€æºåœ°å€ï¼š<a href="https://github.com/CYRUS-STUDIO/ARM64Emulator">https://github.com/CYRUS-STUDIO/ARM64Emulator</a></p>

  </div>


  <div class="post-footer">

    
    

    
    <hr class="section-divider" />

    <div id="waline"></div>
    <script type="module">
      import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';

      init({
        el: '#waline',
        serverURL: 'https://waline-15wtwfoa7-cyrus-studios-projects.vercel.app',
        path: location.pathname, 
        pageview: true,          
      });
    </script>
  </div>

</article>



<div id="toc" class="toc-container hidden"></div>


<button id="toc-toggle" class="toc-toggle" aria-label="ç›®å½•">
  &#9776;
</button>


<script src="/blog/js/toc.js"></script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
      
      document.querySelectorAll('pre').forEach(function(block) {
          
          var button = document.createElement('button');
          button.className = 'copy-btn';
          button.textContent = 'å¤åˆ¶';

          
          block.appendChild(button);

          
          var clipboard = new ClipboardJS(button, {
              target: function() {
                  return block.querySelector('code');
              }
          });

          
          clipboard.on('success', function(e) {
              e.trigger.textContent = 'å¤åˆ¶æˆåŠŸ';
              setTimeout(function() {
                  e.trigger.textContent = 'å¤åˆ¶';
              }, 2000);
          });

          
          clipboard.on('error', function(e) {
              e.trigger.textContent = 'å¤åˆ¶å¤±è´¥';
          });
      });
  });
</script>



    </main>
  </body>
</html>
